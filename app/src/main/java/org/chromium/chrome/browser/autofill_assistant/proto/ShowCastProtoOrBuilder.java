// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

public interface ShowCastProtoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:autofill_assistant.ShowCastProto)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * Element to scroll to.
   * </pre>
   *
   * <code>optional .autofill_assistant.SelectorProto element_to_present = 1;</code>
   * @return Whether the elementToPresent field is set.
   */
  boolean hasElementToPresent();
  /**
   * <pre>
   * Element to scroll to.
   * </pre>
   *
   * <code>optional .autofill_assistant.SelectorProto element_to_present = 1;</code>
   * @return The elementToPresent.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto getElementToPresent();

  /**
   * <pre>
   * Optional title to show in the status bar.
   * </pre>
   *
   * <code>optional string title = 2;</code>
   * @return Whether the title field is set.
   */
  boolean hasTitle();
  /**
   * <pre>
   * Optional title to show in the status bar.
   * </pre>
   *
   * <code>optional string title = 2;</code>
   * @return The title.
   */
  java.lang.String getTitle();
  /**
   * <pre>
   * Optional title to show in the status bar.
   * </pre>
   *
   * <code>optional string title = 2;</code>
   * @return The bytes for title.
   */
  com.google.protobuf.ByteString
      getTitleBytes();

  /**
   * <pre>
   * Restrict interaction to the area spanned by the given elements.
   * Deprecated: use touchable_element_area instead. Ignored if
   * touchable_element_area is non-empty.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto deprecated_touchable_elements = 5;</code>
   */
  java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto> 
      getDeprecatedTouchableElementsList();
  /**
   * <pre>
   * Restrict interaction to the area spanned by the given elements.
   * Deprecated: use touchable_element_area instead. Ignored if
   * touchable_element_area is non-empty.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto deprecated_touchable_elements = 5;</code>
   */
  org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto getDeprecatedTouchableElements(int index);
  /**
   * <pre>
   * Restrict interaction to the area spanned by the given elements.
   * Deprecated: use touchable_element_area instead. Ignored if
   * touchable_element_area is non-empty.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto deprecated_touchable_elements = 5;</code>
   */
  int getDeprecatedTouchableElementsCount();

  /**
   * <pre>
   * Restrict interaction to a series of rectangular areas.
   * </pre>
   *
   * <code>optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;</code>
   * @return Whether the touchableElementArea field is set.
   */
  boolean hasTouchableElementArea();
  /**
   * <pre>
   * Restrict interaction to a series of rectangular areas.
   * </pre>
   *
   * <code>optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;</code>
   * @return The touchableElementArea.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.ElementAreaProto getTouchableElementArea();

  /**
   * <pre>
   * The padding that will be added between the focused element and the top.
   * </pre>
   *
   * <code>optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;</code>
   * @return Whether the topPadding field is set.
   */
  boolean hasTopPadding();
  /**
   * <pre>
   * The padding that will be added between the focused element and the top.
   * </pre>
   *
   * <code>optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;</code>
   * @return The topPadding.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.ShowCastProto.TopPadding getTopPadding();

  /**
   * <pre>
   * Configure whether the scrolling should wait for the element to be stable
   * before scrolling.
   * If set to REQUIRE_STEP_SUCCESS, scrolling may fail with ELEMENT_UNSTABLE.
   * </pre>
   *
   * <code>optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;</code>
   * @return Whether the waitForStableElement field is set.
   */
  boolean hasWaitForStableElement();
  /**
   * <pre>
   * Configure whether the scrolling should wait for the element to be stable
   * before scrolling.
   * If set to REQUIRE_STEP_SUCCESS, scrolling may fail with ELEMENT_UNSTABLE.
   * </pre>
   *
   * <code>optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;</code>
   * @return The waitForStableElement.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.OptionalStep getWaitForStableElement();

  /**
   * <pre>
   * Maximum rounds to stable check.
   * </pre>
   *
   * <code>optional int32 stable_check_max_rounds = 10 [default = 50];</code>
   * @return Whether the stableCheckMaxRounds field is set.
   */
  boolean hasStableCheckMaxRounds();
  /**
   * <pre>
   * Maximum rounds to stable check.
   * </pre>
   *
   * <code>optional int32 stable_check_max_rounds = 10 [default = 50];</code>
   * @return The stableCheckMaxRounds.
   */
  int getStableCheckMaxRounds();

  /**
   * <pre>
   * Interval for stable check in ms.
   * </pre>
   *
   * <code>optional int32 stable_check_interval_ms = 11 [default = 200];</code>
   * @return Whether the stableCheckIntervalMs field is set.
   */
  boolean hasStableCheckIntervalMs();
  /**
   * <pre>
   * Interval for stable check in ms.
   * </pre>
   *
   * <code>optional int32 stable_check_interval_ms = 11 [default = 200];</code>
   * @return The stableCheckIntervalMs.
   */
  int getStableCheckIntervalMs();
}
