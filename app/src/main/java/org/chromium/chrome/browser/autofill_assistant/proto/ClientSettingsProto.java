// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

/**
 * Protobuf type {@code autofill_assistant.ClientSettingsProto}
 */
public  final class ClientSettingsProto extends
    com.google.protobuf.GeneratedMessageLite<
        ClientSettingsProto, ClientSettingsProto.Builder> implements
    // @@protoc_insertion_point(message_implements:autofill_assistant.ClientSettingsProto)
    ClientSettingsProtoOrBuilder {
  private ClientSettingsProto() {
  }
  public interface IntegrationTestSettingsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Disables animations for the poodle and the progress bar.
     * </pre>
     *
     * <code>optional bool disable_header_animations = 1;</code>
     * @return Whether the disableHeaderAnimations field is set.
     */
    boolean hasDisableHeaderAnimations();
    /**
     * <pre>
     * Disables animations for the poodle and the progress bar.
     * </pre>
     *
     * <code>optional bool disable_header_animations = 1;</code>
     * @return The disableHeaderAnimations.
     */
    boolean getDisableHeaderAnimations();

    /**
     * <pre>
     * Disables change animations in the actions carousel.
     * </pre>
     *
     * <code>optional bool disable_carousel_change_animations = 2;</code>
     * @return Whether the disableCarouselChangeAnimations field is set.
     */
    boolean hasDisableCarouselChangeAnimations();
    /**
     * <pre>
     * Disables change animations in the actions carousel.
     * </pre>
     *
     * <code>optional bool disable_carousel_change_animations = 2;</code>
     * @return The disableCarouselChangeAnimations.
     */
    boolean getDisableCarouselChangeAnimations();
  }
  /**
   * Protobuf type {@code autofill_assistant.ClientSettingsProto.IntegrationTestSettings}
   */
  public  static final class IntegrationTestSettings extends
      com.google.protobuf.GeneratedMessageLite<
          IntegrationTestSettings, IntegrationTestSettings.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
      IntegrationTestSettingsOrBuilder {
    private IntegrationTestSettings() {
    }
    private int bitField0_;
    public static final int DISABLE_HEADER_ANIMATIONS_FIELD_NUMBER = 1;
    private boolean disableHeaderAnimations_;
    /**
     * <pre>
     * Disables animations for the poodle and the progress bar.
     * </pre>
     *
     * <code>optional bool disable_header_animations = 1;</code>
     * @return Whether the disableHeaderAnimations field is set.
     */
    @java.lang.Override
    public boolean hasDisableHeaderAnimations() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Disables animations for the poodle and the progress bar.
     * </pre>
     *
     * <code>optional bool disable_header_animations = 1;</code>
     * @return The disableHeaderAnimations.
     */
    @java.lang.Override
    public boolean getDisableHeaderAnimations() {
      return disableHeaderAnimations_;
    }
    /**
     * <pre>
     * Disables animations for the poodle and the progress bar.
     * </pre>
     *
     * <code>optional bool disable_header_animations = 1;</code>
     * @param value The disableHeaderAnimations to set.
     */
    private void setDisableHeaderAnimations(boolean value) {
      bitField0_ |= 0x00000001;
      disableHeaderAnimations_ = value;
    }
    /**
     * <pre>
     * Disables animations for the poodle and the progress bar.
     * </pre>
     *
     * <code>optional bool disable_header_animations = 1;</code>
     */
    private void clearDisableHeaderAnimations() {
      bitField0_ = (bitField0_ & ~0x00000001);
      disableHeaderAnimations_ = false;
    }

    public static final int DISABLE_CAROUSEL_CHANGE_ANIMATIONS_FIELD_NUMBER = 2;
    private boolean disableCarouselChangeAnimations_;
    /**
     * <pre>
     * Disables change animations in the actions carousel.
     * </pre>
     *
     * <code>optional bool disable_carousel_change_animations = 2;</code>
     * @return Whether the disableCarouselChangeAnimations field is set.
     */
    @java.lang.Override
    public boolean hasDisableCarouselChangeAnimations() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Disables change animations in the actions carousel.
     * </pre>
     *
     * <code>optional bool disable_carousel_change_animations = 2;</code>
     * @return The disableCarouselChangeAnimations.
     */
    @java.lang.Override
    public boolean getDisableCarouselChangeAnimations() {
      return disableCarouselChangeAnimations_;
    }
    /**
     * <pre>
     * Disables change animations in the actions carousel.
     * </pre>
     *
     * <code>optional bool disable_carousel_change_animations = 2;</code>
     * @param value The disableCarouselChangeAnimations to set.
     */
    private void setDisableCarouselChangeAnimations(boolean value) {
      bitField0_ |= 0x00000002;
      disableCarouselChangeAnimations_ = value;
    }
    /**
     * <pre>
     * Disables change animations in the actions carousel.
     * </pre>
     *
     * <code>optional bool disable_carousel_change_animations = 2;</code>
     */
    private void clearDisableCarouselChangeAnimations() {
      bitField0_ = (bitField0_ & ~0x00000002);
      disableCarouselChangeAnimations_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.ClientSettingsProto.IntegrationTestSettings}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettingsOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Disables animations for the poodle and the progress bar.
       * </pre>
       *
       * <code>optional bool disable_header_animations = 1;</code>
       * @return Whether the disableHeaderAnimations field is set.
       */
      @java.lang.Override
      public boolean hasDisableHeaderAnimations() {
        return instance.hasDisableHeaderAnimations();
      }
      /**
       * <pre>
       * Disables animations for the poodle and the progress bar.
       * </pre>
       *
       * <code>optional bool disable_header_animations = 1;</code>
       * @return The disableHeaderAnimations.
       */
      @java.lang.Override
      public boolean getDisableHeaderAnimations() {
        return instance.getDisableHeaderAnimations();
      }
      /**
       * <pre>
       * Disables animations for the poodle and the progress bar.
       * </pre>
       *
       * <code>optional bool disable_header_animations = 1;</code>
       * @param value The disableHeaderAnimations to set.
       * @return This builder for chaining.
       */
      public Builder setDisableHeaderAnimations(boolean value) {
        copyOnWrite();
        instance.setDisableHeaderAnimations(value);
        return this;
      }
      /**
       * <pre>
       * Disables animations for the poodle and the progress bar.
       * </pre>
       *
       * <code>optional bool disable_header_animations = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDisableHeaderAnimations() {
        copyOnWrite();
        instance.clearDisableHeaderAnimations();
        return this;
      }

      /**
       * <pre>
       * Disables change animations in the actions carousel.
       * </pre>
       *
       * <code>optional bool disable_carousel_change_animations = 2;</code>
       * @return Whether the disableCarouselChangeAnimations field is set.
       */
      @java.lang.Override
      public boolean hasDisableCarouselChangeAnimations() {
        return instance.hasDisableCarouselChangeAnimations();
      }
      /**
       * <pre>
       * Disables change animations in the actions carousel.
       * </pre>
       *
       * <code>optional bool disable_carousel_change_animations = 2;</code>
       * @return The disableCarouselChangeAnimations.
       */
      @java.lang.Override
      public boolean getDisableCarouselChangeAnimations() {
        return instance.getDisableCarouselChangeAnimations();
      }
      /**
       * <pre>
       * Disables change animations in the actions carousel.
       * </pre>
       *
       * <code>optional bool disable_carousel_change_animations = 2;</code>
       * @param value The disableCarouselChangeAnimations to set.
       * @return This builder for chaining.
       */
      public Builder setDisableCarouselChangeAnimations(boolean value) {
        copyOnWrite();
        instance.setDisableCarouselChangeAnimations(value);
        return this;
      }
      /**
       * <pre>
       * Disables change animations in the actions carousel.
       * </pre>
       *
       * <code>optional bool disable_carousel_change_animations = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDisableCarouselChangeAnimations() {
        copyOnWrite();
        instance.clearDisableCarouselChangeAnimations();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "disableHeaderAnimations_",
              "disableCarouselChangeAnimations_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1007\u0000\u0002" +
                "\u1007\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings DEFAULT_INSTANCE;
    static {
      IntegrationTestSettings defaultInstance = new IntegrationTestSettings();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        IntegrationTestSettings.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<IntegrationTestSettings> PARSER;

    public static com.google.protobuf.Parser<IntegrationTestSettings> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BackButtonSettingsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.ClientSettingsProto.BackButtonSettings)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @return Whether the message field is set.
     */
    boolean hasMessage();
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @return Whether the undoLabel field is set.
     */
    boolean hasUndoLabel();
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @return The undoLabel.
     */
    java.lang.String getUndoLabel();
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @return The bytes for undoLabel.
     */
    com.google.protobuf.ByteString
        getUndoLabelBytes();
  }
  /**
   * <pre>
   * Strings to define the back button behaviour. This will show the user a
   * message with an Undo button. If this setting is not present, the back
   * button will show a Snackbar with Undo option.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.ClientSettingsProto.BackButtonSettings}
   */
  public  static final class BackButtonSettings extends
      com.google.protobuf.GeneratedMessageLite<
          BackButtonSettings, BackButtonSettings.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.ClientSettingsProto.BackButtonSettings)
      BackButtonSettingsOrBuilder {
    private BackButtonSettings() {
      message_ = "";
      undoLabel_ = "";
    }
    private int bitField0_;
    public static final int MESSAGE_FIELD_NUMBER = 1;
    private java.lang.String message_;
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @return Whether the message field is set.
     */
    @java.lang.Override
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      return message_;
    }
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(message_);
    }
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @param value The message to set.
     */
    private void setMessage(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      message_ = value;
    }
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     */
    private void clearMessage() {
      bitField0_ = (bitField0_ & ~0x00000001);
      message_ = getDefaultInstance().getMessage();
    }
    /**
     * <pre>
     * The message being shown in the header.
     * </pre>
     *
     * <code>optional string message = 1;</code>
     * @param value The bytes for message to set.
     */
    private void setMessageBytes(
        com.google.protobuf.ByteString value) {
      message_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int UNDO_LABEL_FIELD_NUMBER = 2;
    private java.lang.String undoLabel_;
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @return Whether the undoLabel field is set.
     */
    @java.lang.Override
    public boolean hasUndoLabel() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @return The undoLabel.
     */
    @java.lang.Override
    public java.lang.String getUndoLabel() {
      return undoLabel_;
    }
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @return The bytes for undoLabel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUndoLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(undoLabel_);
    }
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @param value The undoLabel to set.
     */
    private void setUndoLabel(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000002;
      undoLabel_ = value;
    }
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     */
    private void clearUndoLabel() {
      bitField0_ = (bitField0_ & ~0x00000002);
      undoLabel_ = getDefaultInstance().getUndoLabel();
    }
    /**
     * <pre>
     * The label of the highlighted "Undo" action.
     * </pre>
     *
     * <code>optional string undo_label = 2;</code>
     * @param value The bytes for undoLabel to set.
     */
    private void setUndoLabelBytes(
        com.google.protobuf.ByteString value) {
      undoLabel_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Strings to define the back button behaviour. This will show the user a
     * message with an Undo button. If this setting is not present, the back
     * button will show a Snackbar with Undo option.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.ClientSettingsProto.BackButtonSettings}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.ClientSettingsProto.BackButtonSettings)
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettingsOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The message being shown in the header.
       * </pre>
       *
       * <code>optional string message = 1;</code>
       * @return Whether the message field is set.
       */
      @java.lang.Override
      public boolean hasMessage() {
        return instance.hasMessage();
      }
      /**
       * <pre>
       * The message being shown in the header.
       * </pre>
       *
       * <code>optional string message = 1;</code>
       * @return The message.
       */
      @java.lang.Override
      public java.lang.String getMessage() {
        return instance.getMessage();
      }
      /**
       * <pre>
       * The message being shown in the header.
       * </pre>
       *
       * <code>optional string message = 1;</code>
       * @return The bytes for message.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMessageBytes() {
        return instance.getMessageBytes();
      }
      /**
       * <pre>
       * The message being shown in the header.
       * </pre>
       *
       * <code>optional string message = 1;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        copyOnWrite();
        instance.setMessage(value);
        return this;
      }
      /**
       * <pre>
       * The message being shown in the header.
       * </pre>
       *
       * <code>optional string message = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        copyOnWrite();
        instance.clearMessage();
        return this;
      }
      /**
       * <pre>
       * The message being shown in the header.
       * </pre>
       *
       * <code>optional string message = 1;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMessageBytes(value);
        return this;
      }

      /**
       * <pre>
       * The label of the highlighted "Undo" action.
       * </pre>
       *
       * <code>optional string undo_label = 2;</code>
       * @return Whether the undoLabel field is set.
       */
      @java.lang.Override
      public boolean hasUndoLabel() {
        return instance.hasUndoLabel();
      }
      /**
       * <pre>
       * The label of the highlighted "Undo" action.
       * </pre>
       *
       * <code>optional string undo_label = 2;</code>
       * @return The undoLabel.
       */
      @java.lang.Override
      public java.lang.String getUndoLabel() {
        return instance.getUndoLabel();
      }
      /**
       * <pre>
       * The label of the highlighted "Undo" action.
       * </pre>
       *
       * <code>optional string undo_label = 2;</code>
       * @return The bytes for undoLabel.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUndoLabelBytes() {
        return instance.getUndoLabelBytes();
      }
      /**
       * <pre>
       * The label of the highlighted "Undo" action.
       * </pre>
       *
       * <code>optional string undo_label = 2;</code>
       * @param value The undoLabel to set.
       * @return This builder for chaining.
       */
      public Builder setUndoLabel(
          java.lang.String value) {
        copyOnWrite();
        instance.setUndoLabel(value);
        return this;
      }
      /**
       * <pre>
       * The label of the highlighted "Undo" action.
       * </pre>
       *
       * <code>optional string undo_label = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearUndoLabel() {
        copyOnWrite();
        instance.clearUndoLabel();
        return this;
      }
      /**
       * <pre>
       * The label of the highlighted "Undo" action.
       * </pre>
       *
       * <code>optional string undo_label = 2;</code>
       * @param value The bytes for undoLabel to set.
       * @return This builder for chaining.
       */
      public Builder setUndoLabelBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUndoLabelBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.ClientSettingsProto.BackButtonSettings)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "message_",
              "undoLabel_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u1008\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto.BackButtonSettings)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings DEFAULT_INSTANCE;
    static {
      BackButtonSettings defaultInstance = new BackButtonSettings();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BackButtonSettings.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BackButtonSettings> PARSER;

    public static com.google.protobuf.Parser<BackButtonSettings> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  private int bitField0_;
  public static final int PERIODIC_SCRIPT_CHECK_INTERVAL_MS_FIELD_NUMBER = 1;
  private int periodicScriptCheckIntervalMs_;
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   * @return Whether the periodicScriptCheckIntervalMs field is set.
   */
  @java.lang.Override
  public boolean hasPeriodicScriptCheckIntervalMs() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   * @return The periodicScriptCheckIntervalMs.
   */
  @java.lang.Override
  public int getPeriodicScriptCheckIntervalMs() {
    return periodicScriptCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   * @param value The periodicScriptCheckIntervalMs to set.
   */
  private void setPeriodicScriptCheckIntervalMs(int value) {
    bitField0_ |= 0x00000001;
    periodicScriptCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   */
  private void clearPeriodicScriptCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000001);
    periodicScriptCheckIntervalMs_ = 0;
  }

  public static final int PERIODIC_ELEMENT_CHECK_INTERVAL_MS_FIELD_NUMBER = 2;
  private int periodicElementCheckIntervalMs_;
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   * @return Whether the periodicElementCheckIntervalMs field is set.
   */
  @java.lang.Override
  public boolean hasPeriodicElementCheckIntervalMs() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   * @return The periodicElementCheckIntervalMs.
   */
  @java.lang.Override
  public int getPeriodicElementCheckIntervalMs() {
    return periodicElementCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   * @param value The periodicElementCheckIntervalMs to set.
   */
  private void setPeriodicElementCheckIntervalMs(int value) {
    bitField0_ |= 0x00000002;
    periodicElementCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   */
  private void clearPeriodicElementCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000002);
    periodicElementCheckIntervalMs_ = 0;
  }

  public static final int PERIODIC_SCRIPT_CHECK_COUNT_FIELD_NUMBER = 3;
  private int periodicScriptCheckCount_;
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   * @return Whether the periodicScriptCheckCount field is set.
   */
  @java.lang.Override
  public boolean hasPeriodicScriptCheckCount() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   * @return The periodicScriptCheckCount.
   */
  @java.lang.Override
  public int getPeriodicScriptCheckCount() {
    return periodicScriptCheckCount_;
  }
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   * @param value The periodicScriptCheckCount to set.
   */
  private void setPeriodicScriptCheckCount(int value) {
    bitField0_ |= 0x00000004;
    periodicScriptCheckCount_ = value;
  }
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   */
  private void clearPeriodicScriptCheckCount() {
    bitField0_ = (bitField0_ & ~0x00000004);
    periodicScriptCheckCount_ = 0;
  }

  public static final int ELEMENT_POSITION_UPDATE_INTERVAL_MS_FIELD_NUMBER = 4;
  private int elementPositionUpdateIntervalMs_;
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   * @return Whether the elementPositionUpdateIntervalMs field is set.
   */
  @java.lang.Override
  public boolean hasElementPositionUpdateIntervalMs() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   * @return The elementPositionUpdateIntervalMs.
   */
  @java.lang.Override
  public int getElementPositionUpdateIntervalMs() {
    return elementPositionUpdateIntervalMs_;
  }
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   * @param value The elementPositionUpdateIntervalMs to set.
   */
  private void setElementPositionUpdateIntervalMs(int value) {
    bitField0_ |= 0x00000008;
    elementPositionUpdateIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   */
  private void clearElementPositionUpdateIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000008);
    elementPositionUpdateIntervalMs_ = 0;
  }

  public static final int SHORT_WAIT_FOR_ELEMENT_DEADLINE_MS_FIELD_NUMBER = 5;
  private int shortWaitForElementDeadlineMs_;
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   * @return Whether the shortWaitForElementDeadlineMs field is set.
   */
  @java.lang.Override
  public boolean hasShortWaitForElementDeadlineMs() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   * @return The shortWaitForElementDeadlineMs.
   */
  @java.lang.Override
  public int getShortWaitForElementDeadlineMs() {
    return shortWaitForElementDeadlineMs_;
  }
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   * @param value The shortWaitForElementDeadlineMs to set.
   */
  private void setShortWaitForElementDeadlineMs(int value) {
    bitField0_ |= 0x00000010;
    shortWaitForElementDeadlineMs_ = value;
  }
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   */
  private void clearShortWaitForElementDeadlineMs() {
    bitField0_ = (bitField0_ & ~0x00000010);
    shortWaitForElementDeadlineMs_ = 0;
  }

  public static final int BOX_MODEL_CHECK_INTERVAL_MS_FIELD_NUMBER = 6;
  private int boxModelCheckIntervalMs_;
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   * @return Whether the boxModelCheckIntervalMs field is set.
   */
  @java.lang.Override
  public boolean hasBoxModelCheckIntervalMs() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   * @return The boxModelCheckIntervalMs.
   */
  @java.lang.Override
  public int getBoxModelCheckIntervalMs() {
    return boxModelCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   * @param value The boxModelCheckIntervalMs to set.
   */
  private void setBoxModelCheckIntervalMs(int value) {
    bitField0_ |= 0x00000020;
    boxModelCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   */
  private void clearBoxModelCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000020);
    boxModelCheckIntervalMs_ = 0;
  }

  public static final int BOX_MODEL_CHECK_COUNT_FIELD_NUMBER = 7;
  private int boxModelCheckCount_;
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   * @return Whether the boxModelCheckCount field is set.
   */
  @java.lang.Override
  public boolean hasBoxModelCheckCount() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   * @return The boxModelCheckCount.
   */
  @java.lang.Override
  public int getBoxModelCheckCount() {
    return boxModelCheckCount_;
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   * @param value The boxModelCheckCount to set.
   */
  private void setBoxModelCheckCount(int value) {
    bitField0_ |= 0x00000040;
    boxModelCheckCount_ = value;
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   */
  private void clearBoxModelCheckCount() {
    bitField0_ = (bitField0_ & ~0x00000040);
    boxModelCheckCount_ = 0;
  }

  public static final int DOCUMENT_READY_CHECK_TIMEOUT_MS_FIELD_NUMBER = 20;
  private int documentReadyCheckTimeoutMs_;
  /**
   * <pre>
   * Maximum time to wait until document has reached "ready" state.
   * </pre>
   *
   * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
   * @return Whether the documentReadyCheckTimeoutMs field is set.
   */
  @java.lang.Override
  public boolean hasDocumentReadyCheckTimeoutMs() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <pre>
   * Maximum time to wait until document has reached "ready" state.
   * </pre>
   *
   * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
   * @return The documentReadyCheckTimeoutMs.
   */
  @java.lang.Override
  public int getDocumentReadyCheckTimeoutMs() {
    return documentReadyCheckTimeoutMs_;
  }
  /**
   * <pre>
   * Maximum time to wait until document has reached "ready" state.
   * </pre>
   *
   * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
   * @param value The documentReadyCheckTimeoutMs to set.
   */
  private void setDocumentReadyCheckTimeoutMs(int value) {
    bitField0_ |= 0x00000080;
    documentReadyCheckTimeoutMs_ = value;
  }
  /**
   * <pre>
   * Maximum time to wait until document has reached "ready" state.
   * </pre>
   *
   * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
   */
  private void clearDocumentReadyCheckTimeoutMs() {
    bitField0_ = (bitField0_ & ~0x00000080);
    documentReadyCheckTimeoutMs_ = 0;
  }

  public static final int CANCEL_DELAY_MS_FIELD_NUMBER = 12;
  private int cancelDelayMs_;
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   * @return Whether the cancelDelayMs field is set.
   */
  @java.lang.Override
  public boolean hasCancelDelayMs() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   * @return The cancelDelayMs.
   */
  @java.lang.Override
  public int getCancelDelayMs() {
    return cancelDelayMs_;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   * @param value The cancelDelayMs to set.
   */
  private void setCancelDelayMs(int value) {
    bitField0_ |= 0x00000100;
    cancelDelayMs_ = value;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   */
  private void clearCancelDelayMs() {
    bitField0_ = (bitField0_ & ~0x00000100);
    cancelDelayMs_ = 0;
  }

  public static final int TAP_COUNT_FIELD_NUMBER = 13;
  private int tapCount_;
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   * @return Whether the tapCount field is set.
   */
  @java.lang.Override
  public boolean hasTapCount() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   * @return The tapCount.
   */
  @java.lang.Override
  public int getTapCount() {
    return tapCount_;
  }
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   * @param value The tapCount to set.
   */
  private void setTapCount(int value) {
    bitField0_ |= 0x00000200;
    tapCount_ = value;
  }
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   */
  private void clearTapCount() {
    bitField0_ = (bitField0_ & ~0x00000200);
    tapCount_ = 0;
  }

  public static final int TAP_TRACKING_DURATION_MS_FIELD_NUMBER = 14;
  private int tapTrackingDurationMs_;
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   * @return Whether the tapTrackingDurationMs field is set.
   */
  @java.lang.Override
  public boolean hasTapTrackingDurationMs() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   * @return The tapTrackingDurationMs.
   */
  @java.lang.Override
  public int getTapTrackingDurationMs() {
    return tapTrackingDurationMs_;
  }
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   * @param value The tapTrackingDurationMs to set.
   */
  private void setTapTrackingDurationMs(int value) {
    bitField0_ |= 0x00000400;
    tapTrackingDurationMs_ = value;
  }
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   */
  private void clearTapTrackingDurationMs() {
    bitField0_ = (bitField0_ & ~0x00000400);
    tapTrackingDurationMs_ = 0;
  }

  public static final int TAP_SHUTDOWN_DELAY_MS_FIELD_NUMBER = 15;
  private int tapShutdownDelayMs_;
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   * @return Whether the tapShutdownDelayMs field is set.
   */
  @java.lang.Override
  public boolean hasTapShutdownDelayMs() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   * @return The tapShutdownDelayMs.
   */
  @java.lang.Override
  public int getTapShutdownDelayMs() {
    return tapShutdownDelayMs_;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   * @param value The tapShutdownDelayMs to set.
   */
  private void setTapShutdownDelayMs(int value) {
    bitField0_ |= 0x00000800;
    tapShutdownDelayMs_ = value;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   */
  private void clearTapShutdownDelayMs() {
    bitField0_ = (bitField0_ & ~0x00000800);
    tapShutdownDelayMs_ = 0;
  }

  public static final int OVERLAY_IMAGE_FIELD_NUMBER = 16;
  private org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto overlayImage_;
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  @java.lang.Override
  public boolean hasOverlayImage() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto getOverlayImage() {
    return overlayImage_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.getDefaultInstance() : overlayImage_;
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  private void setOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
    value.getClass();
  overlayImage_ = value;
    bitField0_ |= 0x00001000;
    }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
    value.getClass();
  if (overlayImage_ != null &&
        overlayImage_ != org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.getDefaultInstance()) {
      overlayImage_ =
        org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.newBuilder(overlayImage_).mergeFrom(value).buildPartial();
    } else {
      overlayImage_ = value;
    }
    bitField0_ |= 0x00001000;
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  private void clearOverlayImage() {  overlayImage_ = null;
    bitField0_ = (bitField0_ & ~0x00001000);
  }

  public static final int INTEGRATION_TEST_SETTINGS_FIELD_NUMBER = 17;
  private org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings integrationTestSettings_;
  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   */
  @java.lang.Override
  public boolean hasIntegrationTestSettings() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings getIntegrationTestSettings() {
    return integrationTestSettings_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings.getDefaultInstance() : integrationTestSettings_;
  }
  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   */
  private void setIntegrationTestSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings value) {
    value.getClass();
  integrationTestSettings_ = value;
    bitField0_ |= 0x00002000;
    }
  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeIntegrationTestSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings value) {
    value.getClass();
  if (integrationTestSettings_ != null &&
        integrationTestSettings_ != org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings.getDefaultInstance()) {
      integrationTestSettings_ =
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings.newBuilder(integrationTestSettings_).mergeFrom(value).buildPartial();
    } else {
      integrationTestSettings_ = value;
    }
    bitField0_ |= 0x00002000;
  }
  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   */
  private void clearIntegrationTestSettings() {  integrationTestSettings_ = null;
    bitField0_ = (bitField0_ & ~0x00002000);
  }

  public static final int TALKBACK_SHEET_SIZE_FRACTION_FIELD_NUMBER = 18;
  private float talkbackSheetSizeFraction_;
  /**
   * <pre>
   * Optional setting defining the size of the bottom sheet when Talkback is
   * enabled as a fraction of the available height. When set, the bottomsheet
   * will stop resizing automatically in talkback mode. It will always have the
   * specified size instead.
   * </pre>
   *
   * <code>optional float talkback_sheet_size_fraction = 18;</code>
   * @return Whether the talkbackSheetSizeFraction field is set.
   */
  @java.lang.Override
  public boolean hasTalkbackSheetSizeFraction() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   * <pre>
   * Optional setting defining the size of the bottom sheet when Talkback is
   * enabled as a fraction of the available height. When set, the bottomsheet
   * will stop resizing automatically in talkback mode. It will always have the
   * specified size instead.
   * </pre>
   *
   * <code>optional float talkback_sheet_size_fraction = 18;</code>
   * @return The talkbackSheetSizeFraction.
   */
  @java.lang.Override
  public float getTalkbackSheetSizeFraction() {
    return talkbackSheetSizeFraction_;
  }
  /**
   * <pre>
   * Optional setting defining the size of the bottom sheet when Talkback is
   * enabled as a fraction of the available height. When set, the bottomsheet
   * will stop resizing automatically in talkback mode. It will always have the
   * specified size instead.
   * </pre>
   *
   * <code>optional float talkback_sheet_size_fraction = 18;</code>
   * @param value The talkbackSheetSizeFraction to set.
   */
  private void setTalkbackSheetSizeFraction(float value) {
    bitField0_ |= 0x00004000;
    talkbackSheetSizeFraction_ = value;
  }
  /**
   * <pre>
   * Optional setting defining the size of the bottom sheet when Talkback is
   * enabled as a fraction of the available height. When set, the bottomsheet
   * will stop resizing automatically in talkback mode. It will always have the
   * specified size instead.
   * </pre>
   *
   * <code>optional float talkback_sheet_size_fraction = 18;</code>
   */
  private void clearTalkbackSheetSizeFraction() {
    bitField0_ = (bitField0_ & ~0x00004000);
    talkbackSheetSizeFraction_ = 0F;
  }

  public static final int BACK_BUTTON_SETTINGS_FIELD_NUMBER = 19;
  private org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings backButtonSettings_;
  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   */
  @java.lang.Override
  public boolean hasBackButtonSettings() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings getBackButtonSettings() {
    return backButtonSettings_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings.getDefaultInstance() : backButtonSettings_;
  }
  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   */
  private void setBackButtonSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings value) {
    value.getClass();
  backButtonSettings_ = value;
    bitField0_ |= 0x00008000;
    }
  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeBackButtonSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings value) {
    value.getClass();
  if (backButtonSettings_ != null &&
        backButtonSettings_ != org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings.getDefaultInstance()) {
      backButtonSettings_ =
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings.newBuilder(backButtonSettings_).mergeFrom(value).buildPartial();
    } else {
      backButtonSettings_ = value;
    }
    bitField0_ |= 0x00008000;
  }
  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   */
  private void clearBackButtonSettings() {  backButtonSettings_ = null;
    bitField0_ = (bitField0_ & ~0x00008000);
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code autofill_assistant.ClientSettingsProto}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto, Builder> implements
      // @@protoc_insertion_point(builder_implements:autofill_assistant.ClientSettingsProto)
      org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProtoOrBuilder {
    // Construct using org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     * @return Whether the periodicScriptCheckIntervalMs field is set.
     */
    @java.lang.Override
    public boolean hasPeriodicScriptCheckIntervalMs() {
      return instance.hasPeriodicScriptCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     * @return The periodicScriptCheckIntervalMs.
     */
    @java.lang.Override
    public int getPeriodicScriptCheckIntervalMs() {
      return instance.getPeriodicScriptCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     * @param value The periodicScriptCheckIntervalMs to set.
     * @return This builder for chaining.
     */
    public Builder setPeriodicScriptCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setPeriodicScriptCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearPeriodicScriptCheckIntervalMs() {
      copyOnWrite();
      instance.clearPeriodicScriptCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     * @return Whether the periodicElementCheckIntervalMs field is set.
     */
    @java.lang.Override
    public boolean hasPeriodicElementCheckIntervalMs() {
      return instance.hasPeriodicElementCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     * @return The periodicElementCheckIntervalMs.
     */
    @java.lang.Override
    public int getPeriodicElementCheckIntervalMs() {
      return instance.getPeriodicElementCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     * @param value The periodicElementCheckIntervalMs to set.
     * @return This builder for chaining.
     */
    public Builder setPeriodicElementCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setPeriodicElementCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearPeriodicElementCheckIntervalMs() {
      copyOnWrite();
      instance.clearPeriodicElementCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     * @return Whether the periodicScriptCheckCount field is set.
     */
    @java.lang.Override
    public boolean hasPeriodicScriptCheckCount() {
      return instance.hasPeriodicScriptCheckCount();
    }
    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     * @return The periodicScriptCheckCount.
     */
    @java.lang.Override
    public int getPeriodicScriptCheckCount() {
      return instance.getPeriodicScriptCheckCount();
    }
    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     * @param value The periodicScriptCheckCount to set.
     * @return This builder for chaining.
     */
    public Builder setPeriodicScriptCheckCount(int value) {
      copyOnWrite();
      instance.setPeriodicScriptCheckCount(value);
      return this;
    }
    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearPeriodicScriptCheckCount() {
      copyOnWrite();
      instance.clearPeriodicScriptCheckCount();
      return this;
    }

    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     * @return Whether the elementPositionUpdateIntervalMs field is set.
     */
    @java.lang.Override
    public boolean hasElementPositionUpdateIntervalMs() {
      return instance.hasElementPositionUpdateIntervalMs();
    }
    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     * @return The elementPositionUpdateIntervalMs.
     */
    @java.lang.Override
    public int getElementPositionUpdateIntervalMs() {
      return instance.getElementPositionUpdateIntervalMs();
    }
    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     * @param value The elementPositionUpdateIntervalMs to set.
     * @return This builder for chaining.
     */
    public Builder setElementPositionUpdateIntervalMs(int value) {
      copyOnWrite();
      instance.setElementPositionUpdateIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearElementPositionUpdateIntervalMs() {
      copyOnWrite();
      instance.clearElementPositionUpdateIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     * @return Whether the shortWaitForElementDeadlineMs field is set.
     */
    @java.lang.Override
    public boolean hasShortWaitForElementDeadlineMs() {
      return instance.hasShortWaitForElementDeadlineMs();
    }
    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     * @return The shortWaitForElementDeadlineMs.
     */
    @java.lang.Override
    public int getShortWaitForElementDeadlineMs() {
      return instance.getShortWaitForElementDeadlineMs();
    }
    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     * @param value The shortWaitForElementDeadlineMs to set.
     * @return This builder for chaining.
     */
    public Builder setShortWaitForElementDeadlineMs(int value) {
      copyOnWrite();
      instance.setShortWaitForElementDeadlineMs(value);
      return this;
    }
    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearShortWaitForElementDeadlineMs() {
      copyOnWrite();
      instance.clearShortWaitForElementDeadlineMs();
      return this;
    }

    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     * @return Whether the boxModelCheckIntervalMs field is set.
     */
    @java.lang.Override
    public boolean hasBoxModelCheckIntervalMs() {
      return instance.hasBoxModelCheckIntervalMs();
    }
    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     * @return The boxModelCheckIntervalMs.
     */
    @java.lang.Override
    public int getBoxModelCheckIntervalMs() {
      return instance.getBoxModelCheckIntervalMs();
    }
    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     * @param value The boxModelCheckIntervalMs to set.
     * @return This builder for chaining.
     */
    public Builder setBoxModelCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setBoxModelCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearBoxModelCheckIntervalMs() {
      copyOnWrite();
      instance.clearBoxModelCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     * @return Whether the boxModelCheckCount field is set.
     */
    @java.lang.Override
    public boolean hasBoxModelCheckCount() {
      return instance.hasBoxModelCheckCount();
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     * @return The boxModelCheckCount.
     */
    @java.lang.Override
    public int getBoxModelCheckCount() {
      return instance.getBoxModelCheckCount();
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     * @param value The boxModelCheckCount to set.
     * @return This builder for chaining.
     */
    public Builder setBoxModelCheckCount(int value) {
      copyOnWrite();
      instance.setBoxModelCheckCount(value);
      return this;
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearBoxModelCheckCount() {
      copyOnWrite();
      instance.clearBoxModelCheckCount();
      return this;
    }

    /**
     * <pre>
     * Maximum time to wait until document has reached "ready" state.
     * </pre>
     *
     * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
     * @return Whether the documentReadyCheckTimeoutMs field is set.
     */
    @java.lang.Override
    public boolean hasDocumentReadyCheckTimeoutMs() {
      return instance.hasDocumentReadyCheckTimeoutMs();
    }
    /**
     * <pre>
     * Maximum time to wait until document has reached "ready" state.
     * </pre>
     *
     * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
     * @return The documentReadyCheckTimeoutMs.
     */
    @java.lang.Override
    public int getDocumentReadyCheckTimeoutMs() {
      return instance.getDocumentReadyCheckTimeoutMs();
    }
    /**
     * <pre>
     * Maximum time to wait until document has reached "ready" state.
     * </pre>
     *
     * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
     * @param value The documentReadyCheckTimeoutMs to set.
     * @return This builder for chaining.
     */
    public Builder setDocumentReadyCheckTimeoutMs(int value) {
      copyOnWrite();
      instance.setDocumentReadyCheckTimeoutMs(value);
      return this;
    }
    /**
     * <pre>
     * Maximum time to wait until document has reached "ready" state.
     * </pre>
     *
     * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
     * @return This builder for chaining.
     */
    public Builder clearDocumentReadyCheckTimeoutMs() {
      copyOnWrite();
      instance.clearDocumentReadyCheckTimeoutMs();
      return this;
    }

    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     * @return Whether the cancelDelayMs field is set.
     */
    @java.lang.Override
    public boolean hasCancelDelayMs() {
      return instance.hasCancelDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     * @return The cancelDelayMs.
     */
    @java.lang.Override
    public int getCancelDelayMs() {
      return instance.getCancelDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     * @param value The cancelDelayMs to set.
     * @return This builder for chaining.
     */
    public Builder setCancelDelayMs(int value) {
      copyOnWrite();
      instance.setCancelDelayMs(value);
      return this;
    }
    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     * @return This builder for chaining.
     */
    public Builder clearCancelDelayMs() {
      copyOnWrite();
      instance.clearCancelDelayMs();
      return this;
    }

    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     * @return Whether the tapCount field is set.
     */
    @java.lang.Override
    public boolean hasTapCount() {
      return instance.hasTapCount();
    }
    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     * @return The tapCount.
     */
    @java.lang.Override
    public int getTapCount() {
      return instance.getTapCount();
    }
    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     * @param value The tapCount to set.
     * @return This builder for chaining.
     */
    public Builder setTapCount(int value) {
      copyOnWrite();
      instance.setTapCount(value);
      return this;
    }
    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     * @return This builder for chaining.
     */
    public Builder clearTapCount() {
      copyOnWrite();
      instance.clearTapCount();
      return this;
    }

    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     * @return Whether the tapTrackingDurationMs field is set.
     */
    @java.lang.Override
    public boolean hasTapTrackingDurationMs() {
      return instance.hasTapTrackingDurationMs();
    }
    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     * @return The tapTrackingDurationMs.
     */
    @java.lang.Override
    public int getTapTrackingDurationMs() {
      return instance.getTapTrackingDurationMs();
    }
    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     * @param value The tapTrackingDurationMs to set.
     * @return This builder for chaining.
     */
    public Builder setTapTrackingDurationMs(int value) {
      copyOnWrite();
      instance.setTapTrackingDurationMs(value);
      return this;
    }
    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     * @return This builder for chaining.
     */
    public Builder clearTapTrackingDurationMs() {
      copyOnWrite();
      instance.clearTapTrackingDurationMs();
      return this;
    }

    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     * @return Whether the tapShutdownDelayMs field is set.
     */
    @java.lang.Override
    public boolean hasTapShutdownDelayMs() {
      return instance.hasTapShutdownDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     * @return The tapShutdownDelayMs.
     */
    @java.lang.Override
    public int getTapShutdownDelayMs() {
      return instance.getTapShutdownDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     * @param value The tapShutdownDelayMs to set.
     * @return This builder for chaining.
     */
    public Builder setTapShutdownDelayMs(int value) {
      copyOnWrite();
      instance.setTapShutdownDelayMs(value);
      return this;
    }
    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     * @return This builder for chaining.
     */
    public Builder clearTapShutdownDelayMs() {
      copyOnWrite();
      instance.clearTapShutdownDelayMs();
      return this;
    }

    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    @java.lang.Override
    public boolean hasOverlayImage() {
      return instance.hasOverlayImage();
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto getOverlayImage() {
      return instance.getOverlayImage();
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder setOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
      copyOnWrite();
      instance.setOverlayImage(value);
      return this;
      }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder setOverlayImage(
        org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.Builder builderForValue) {
      copyOnWrite();
      instance.setOverlayImage(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder mergeOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
      copyOnWrite();
      instance.mergeOverlayImage(value);
      return this;
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder clearOverlayImage() {  copyOnWrite();
      instance.clearOverlayImage();
      return this;
    }

    /**
     * <pre>
     * Optional settings intended for integration tests.
     * </pre>
     *
     * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
     */
    @java.lang.Override
    public boolean hasIntegrationTestSettings() {
      return instance.hasIntegrationTestSettings();
    }
    /**
     * <pre>
     * Optional settings intended for integration tests.
     * </pre>
     *
     * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings getIntegrationTestSettings() {
      return instance.getIntegrationTestSettings();
    }
    /**
     * <pre>
     * Optional settings intended for integration tests.
     * </pre>
     *
     * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
     */
    public Builder setIntegrationTestSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings value) {
      copyOnWrite();
      instance.setIntegrationTestSettings(value);
      return this;
      }
    /**
     * <pre>
     * Optional settings intended for integration tests.
     * </pre>
     *
     * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
     */
    public Builder setIntegrationTestSettings(
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings.Builder builderForValue) {
      copyOnWrite();
      instance.setIntegrationTestSettings(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Optional settings intended for integration tests.
     * </pre>
     *
     * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
     */
    public Builder mergeIntegrationTestSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings value) {
      copyOnWrite();
      instance.mergeIntegrationTestSettings(value);
      return this;
    }
    /**
     * <pre>
     * Optional settings intended for integration tests.
     * </pre>
     *
     * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
     */
    public Builder clearIntegrationTestSettings() {  copyOnWrite();
      instance.clearIntegrationTestSettings();
      return this;
    }

    /**
     * <pre>
     * Optional setting defining the size of the bottom sheet when Talkback is
     * enabled as a fraction of the available height. When set, the bottomsheet
     * will stop resizing automatically in talkback mode. It will always have the
     * specified size instead.
     * </pre>
     *
     * <code>optional float talkback_sheet_size_fraction = 18;</code>
     * @return Whether the talkbackSheetSizeFraction field is set.
     */
    @java.lang.Override
    public boolean hasTalkbackSheetSizeFraction() {
      return instance.hasTalkbackSheetSizeFraction();
    }
    /**
     * <pre>
     * Optional setting defining the size of the bottom sheet when Talkback is
     * enabled as a fraction of the available height. When set, the bottomsheet
     * will stop resizing automatically in talkback mode. It will always have the
     * specified size instead.
     * </pre>
     *
     * <code>optional float talkback_sheet_size_fraction = 18;</code>
     * @return The talkbackSheetSizeFraction.
     */
    @java.lang.Override
    public float getTalkbackSheetSizeFraction() {
      return instance.getTalkbackSheetSizeFraction();
    }
    /**
     * <pre>
     * Optional setting defining the size of the bottom sheet when Talkback is
     * enabled as a fraction of the available height. When set, the bottomsheet
     * will stop resizing automatically in talkback mode. It will always have the
     * specified size instead.
     * </pre>
     *
     * <code>optional float talkback_sheet_size_fraction = 18;</code>
     * @param value The talkbackSheetSizeFraction to set.
     * @return This builder for chaining.
     */
    public Builder setTalkbackSheetSizeFraction(float value) {
      copyOnWrite();
      instance.setTalkbackSheetSizeFraction(value);
      return this;
    }
    /**
     * <pre>
     * Optional setting defining the size of the bottom sheet when Talkback is
     * enabled as a fraction of the available height. When set, the bottomsheet
     * will stop resizing automatically in talkback mode. It will always have the
     * specified size instead.
     * </pre>
     *
     * <code>optional float talkback_sheet_size_fraction = 18;</code>
     * @return This builder for chaining.
     */
    public Builder clearTalkbackSheetSizeFraction() {
      copyOnWrite();
      instance.clearTalkbackSheetSizeFraction();
      return this;
    }

    /**
     * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
     */
    @java.lang.Override
    public boolean hasBackButtonSettings() {
      return instance.hasBackButtonSettings();
    }
    /**
     * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings getBackButtonSettings() {
      return instance.getBackButtonSettings();
    }
    /**
     * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
     */
    public Builder setBackButtonSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings value) {
      copyOnWrite();
      instance.setBackButtonSettings(value);
      return this;
      }
    /**
     * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
     */
    public Builder setBackButtonSettings(
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings.Builder builderForValue) {
      copyOnWrite();
      instance.setBackButtonSettings(builderForValue.build());
      return this;
    }
    /**
     * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
     */
    public Builder mergeBackButtonSettings(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings value) {
      copyOnWrite();
      instance.mergeBackButtonSettings(value);
      return this;
    }
    /**
     * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
     */
    public Builder clearBackButtonSettings() {  copyOnWrite();
      instance.clearBackButtonSettings();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:autofill_assistant.ClientSettingsProto)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "periodicScriptCheckIntervalMs_",
            "periodicElementCheckIntervalMs_",
            "periodicScriptCheckCount_",
            "elementPositionUpdateIntervalMs_",
            "shortWaitForElementDeadlineMs_",
            "boxModelCheckIntervalMs_",
            "boxModelCheckCount_",
            "cancelDelayMs_",
            "tapCount_",
            "tapTrackingDurationMs_",
            "tapShutdownDelayMs_",
            "overlayImage_",
            "integrationTestSettings_",
            "talkbackSheetSizeFraction_",
            "backButtonSettings_",
            "documentReadyCheckTimeoutMs_",
          };
          java.lang.String info =
              "\u0001\u0010\u0000\u0001\u0001\u0014\u0010\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
              "\u1004\u0001\u0003\u1004\u0002\u0004\u1004\u0003\u0005\u1004\u0004\u0006\u1004\u0005" +
              "\u0007\u1004\u0006\f\u1004\b\r\u1004\t\u000e\u1004\n\u000f\u1004\u000b\u0010\u1009" +
              "\f\u0011\u1009\r\u0012\u1001\u000e\u0013\u1009\u000f\u0014\u1004\u0007";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto)
  private static final org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto DEFAULT_INSTANCE;
  static {
    ClientSettingsProto defaultInstance = new ClientSettingsProto();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      ClientSettingsProto.class, defaultInstance);
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<ClientSettingsProto> PARSER;

  public static com.google.protobuf.Parser<ClientSettingsProto> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

