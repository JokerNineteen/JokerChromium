// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

/**
 * Protobuf type {@code autofill_assistant.DateTimeRangeProto}
 */
public  final class DateTimeRangeProto extends
    com.google.protobuf.GeneratedMessageLite<
        DateTimeRangeProto, DateTimeRangeProto.Builder> implements
    // @@protoc_insertion_point(message_implements:autofill_assistant.DateTimeRangeProto)
    DateTimeRangeProtoOrBuilder {
  private DateTimeRangeProto() {
    startDateLabel_ = "";
    startTimeLabel_ = "";
    endDateLabel_ = "";
    endTimeLabel_ = "";
    timeSlots_ = emptyProtobufList();
    dateNotSetError_ = "";
    timeNotSetError_ = "";
  }
  public interface TimeSlotOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.DateTimeRangeProto.TimeSlot)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @return Whether the label field is set.
     */
    boolean hasLabel();
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     * The comparison value to be used to compare this timeslot
     * to others. Smaller values indicate earlier times. This will be used to
     * prevent start &gt; end and vice-versa.
     * </pre>
     *
     * <code>optional int32 comparison_value = 2;</code>
     * @return Whether the comparisonValue field is set.
     */
    boolean hasComparisonValue();
    /**
     * <pre>
     * The comparison value to be used to compare this timeslot
     * to others. Smaller values indicate earlier times. This will be used to
     * prevent start &gt; end and vice-versa.
     * </pre>
     *
     * <code>optional int32 comparison_value = 2;</code>
     * @return The comparisonValue.
     */
    int getComparisonValue();
  }
  /**
   * Protobuf type {@code autofill_assistant.DateTimeRangeProto.TimeSlot}
   */
  public  static final class TimeSlot extends
      com.google.protobuf.GeneratedMessageLite<
          TimeSlot, TimeSlot.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.DateTimeRangeProto.TimeSlot)
      TimeSlotOrBuilder {
    private TimeSlot() {
      label_ = "";
    }
    private int bitField0_;
    public static final int LABEL_FIELD_NUMBER = 1;
    private java.lang.String label_;
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @return Whether the label field is set.
     */
    @java.lang.Override
    public boolean hasLabel() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      return label_;
    }
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(label_);
    }
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @param value The label to set.
     */
    private void setLabel(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      label_ = value;
    }
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     */
    private void clearLabel() {
      bitField0_ = (bitField0_ & ~0x00000001);
      label_ = getDefaultInstance().getLabel();
    }
    /**
     * <pre>
     * The label to display.
     * </pre>
     *
     * <code>optional string label = 1;</code>
     * @param value The bytes for label to set.
     */
    private void setLabelBytes(
        com.google.protobuf.ByteString value) {
      label_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int COMPARISON_VALUE_FIELD_NUMBER = 2;
    private int comparisonValue_;
    /**
     * <pre>
     * The comparison value to be used to compare this timeslot
     * to others. Smaller values indicate earlier times. This will be used to
     * prevent start &gt; end and vice-versa.
     * </pre>
     *
     * <code>optional int32 comparison_value = 2;</code>
     * @return Whether the comparisonValue field is set.
     */
    @java.lang.Override
    public boolean hasComparisonValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The comparison value to be used to compare this timeslot
     * to others. Smaller values indicate earlier times. This will be used to
     * prevent start &gt; end and vice-versa.
     * </pre>
     *
     * <code>optional int32 comparison_value = 2;</code>
     * @return The comparisonValue.
     */
    @java.lang.Override
    public int getComparisonValue() {
      return comparisonValue_;
    }
    /**
     * <pre>
     * The comparison value to be used to compare this timeslot
     * to others. Smaller values indicate earlier times. This will be used to
     * prevent start &gt; end and vice-versa.
     * </pre>
     *
     * <code>optional int32 comparison_value = 2;</code>
     * @param value The comparisonValue to set.
     */
    private void setComparisonValue(int value) {
      bitField0_ |= 0x00000002;
      comparisonValue_ = value;
    }
    /**
     * <pre>
     * The comparison value to be used to compare this timeslot
     * to others. Smaller values indicate earlier times. This will be used to
     * prevent start &gt; end and vice-versa.
     * </pre>
     *
     * <code>optional int32 comparison_value = 2;</code>
     */
    private void clearComparisonValue() {
      bitField0_ = (bitField0_ & ~0x00000002);
      comparisonValue_ = 0;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.DateTimeRangeProto.TimeSlot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.DateTimeRangeProto.TimeSlot)
        org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlotOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The label to display.
       * </pre>
       *
       * <code>optional string label = 1;</code>
       * @return Whether the label field is set.
       */
      @java.lang.Override
      public boolean hasLabel() {
        return instance.hasLabel();
      }
      /**
       * <pre>
       * The label to display.
       * </pre>
       *
       * <code>optional string label = 1;</code>
       * @return The label.
       */
      @java.lang.Override
      public java.lang.String getLabel() {
        return instance.getLabel();
      }
      /**
       * <pre>
       * The label to display.
       * </pre>
       *
       * <code>optional string label = 1;</code>
       * @return The bytes for label.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLabelBytes() {
        return instance.getLabelBytes();
      }
      /**
       * <pre>
       * The label to display.
       * </pre>
       *
       * <code>optional string label = 1;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <pre>
       * The label to display.
       * </pre>
       *
       * <code>optional string label = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }
      /**
       * <pre>
       * The label to display.
       * </pre>
       *
       * <code>optional string label = 1;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLabelBytes(value);
        return this;
      }

      /**
       * <pre>
       * The comparison value to be used to compare this timeslot
       * to others. Smaller values indicate earlier times. This will be used to
       * prevent start &gt; end and vice-versa.
       * </pre>
       *
       * <code>optional int32 comparison_value = 2;</code>
       * @return Whether the comparisonValue field is set.
       */
      @java.lang.Override
      public boolean hasComparisonValue() {
        return instance.hasComparisonValue();
      }
      /**
       * <pre>
       * The comparison value to be used to compare this timeslot
       * to others. Smaller values indicate earlier times. This will be used to
       * prevent start &gt; end and vice-versa.
       * </pre>
       *
       * <code>optional int32 comparison_value = 2;</code>
       * @return The comparisonValue.
       */
      @java.lang.Override
      public int getComparisonValue() {
        return instance.getComparisonValue();
      }
      /**
       * <pre>
       * The comparison value to be used to compare this timeslot
       * to others. Smaller values indicate earlier times. This will be used to
       * prevent start &gt; end and vice-versa.
       * </pre>
       *
       * <code>optional int32 comparison_value = 2;</code>
       * @param value The comparisonValue to set.
       * @return This builder for chaining.
       */
      public Builder setComparisonValue(int value) {
        copyOnWrite();
        instance.setComparisonValue(value);
        return this;
      }
      /**
       * <pre>
       * The comparison value to be used to compare this timeslot
       * to others. Smaller values indicate earlier times. This will be used to
       * prevent start &gt; end and vice-versa.
       * </pre>
       *
       * <code>optional int32 comparison_value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearComparisonValue() {
        copyOnWrite();
        instance.clearComparisonValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.DateTimeRangeProto.TimeSlot)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "label_",
              "comparisonValue_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u1004\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.DateTimeRangeProto.TimeSlot)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot DEFAULT_INSTANCE;
    static {
      TimeSlot defaultInstance = new TimeSlot();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TimeSlot.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TimeSlot> PARSER;

    public static com.google.protobuf.Parser<TimeSlot> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  private int bitField0_;
  public static final int START_DATE_FIELD_NUMBER = 15;
  private org.chromium.chrome.browser.autofill_assistant.proto.DateProto startDate_;
  /**
   * <pre>
   * The initial start date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
   */
  @java.lang.Override
  public boolean hasStartDate() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * The initial start date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getStartDate() {
    return startDate_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance() : startDate_;
  }
  /**
   * <pre>
   * The initial start date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
   */
  private void setStartDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  startDate_ = value;
    bitField0_ |= 0x00000001;
    }
  /**
   * <pre>
   * The initial start date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeStartDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  if (startDate_ != null &&
        startDate_ != org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance()) {
      startDate_ =
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.newBuilder(startDate_).mergeFrom(value).buildPartial();
    } else {
      startDate_ = value;
    }
    bitField0_ |= 0x00000001;
  }
  /**
   * <pre>
   * The initial start date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
   */
  private void clearStartDate() {  startDate_ = null;
    bitField0_ = (bitField0_ & ~0x00000001);
  }

  public static final int START_TIME_SLOT_FIELD_NUMBER = 13;
  private int startTimeSlot_;
  /**
   * <pre>
   * The index of the initial start time slot to select.
   * </pre>
   *
   * <code>optional int32 start_time_slot = 13;</code>
   * @return Whether the startTimeSlot field is set.
   */
  @java.lang.Override
  public boolean hasStartTimeSlot() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * The index of the initial start time slot to select.
   * </pre>
   *
   * <code>optional int32 start_time_slot = 13;</code>
   * @return The startTimeSlot.
   */
  @java.lang.Override
  public int getStartTimeSlot() {
    return startTimeSlot_;
  }
  /**
   * <pre>
   * The index of the initial start time slot to select.
   * </pre>
   *
   * <code>optional int32 start_time_slot = 13;</code>
   * @param value The startTimeSlot to set.
   */
  private void setStartTimeSlot(int value) {
    bitField0_ |= 0x00000002;
    startTimeSlot_ = value;
  }
  /**
   * <pre>
   * The index of the initial start time slot to select.
   * </pre>
   *
   * <code>optional int32 start_time_slot = 13;</code>
   */
  private void clearStartTimeSlot() {
    bitField0_ = (bitField0_ & ~0x00000002);
    startTimeSlot_ = 0;
  }

  public static final int END_DATE_FIELD_NUMBER = 16;
  private org.chromium.chrome.browser.autofill_assistant.proto.DateProto endDate_;
  /**
   * <pre>
   * The initial end date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
   */
  @java.lang.Override
  public boolean hasEndDate() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * The initial end date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getEndDate() {
    return endDate_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance() : endDate_;
  }
  /**
   * <pre>
   * The initial end date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
   */
  private void setEndDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  endDate_ = value;
    bitField0_ |= 0x00000004;
    }
  /**
   * <pre>
   * The initial end date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeEndDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  if (endDate_ != null &&
        endDate_ != org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance()) {
      endDate_ =
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.newBuilder(endDate_).mergeFrom(value).buildPartial();
    } else {
      endDate_ = value;
    }
    bitField0_ |= 0x00000004;
  }
  /**
   * <pre>
   * The initial end date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
   */
  private void clearEndDate() {  endDate_ = null;
    bitField0_ = (bitField0_ & ~0x00000004);
  }

  public static final int END_TIME_SLOT_FIELD_NUMBER = 14;
  private int endTimeSlot_;
  /**
   * <pre>
   * The index of the initial end time slot to select.
   * </pre>
   *
   * <code>optional int32 end_time_slot = 14;</code>
   * @return Whether the endTimeSlot field is set.
   */
  @java.lang.Override
  public boolean hasEndTimeSlot() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <pre>
   * The index of the initial end time slot to select.
   * </pre>
   *
   * <code>optional int32 end_time_slot = 14;</code>
   * @return The endTimeSlot.
   */
  @java.lang.Override
  public int getEndTimeSlot() {
    return endTimeSlot_;
  }
  /**
   * <pre>
   * The index of the initial end time slot to select.
   * </pre>
   *
   * <code>optional int32 end_time_slot = 14;</code>
   * @param value The endTimeSlot to set.
   */
  private void setEndTimeSlot(int value) {
    bitField0_ |= 0x00000008;
    endTimeSlot_ = value;
  }
  /**
   * <pre>
   * The index of the initial end time slot to select.
   * </pre>
   *
   * <code>optional int32 end_time_slot = 14;</code>
   */
  private void clearEndTimeSlot() {
    bitField0_ = (bitField0_ & ~0x00000008);
    endTimeSlot_ = 0;
  }

  public static final int MIN_DATE_FIELD_NUMBER = 3;
  private org.chromium.chrome.browser.autofill_assistant.proto.DateProto minDate_;
  /**
   * <pre>
   * The minimum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
   */
  @java.lang.Override
  public boolean hasMinDate() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <pre>
   * The minimum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getMinDate() {
    return minDate_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance() : minDate_;
  }
  /**
   * <pre>
   * The minimum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
   */
  private void setMinDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  minDate_ = value;
    bitField0_ |= 0x00000010;
    }
  /**
   * <pre>
   * The minimum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeMinDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  if (minDate_ != null &&
        minDate_ != org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance()) {
      minDate_ =
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.newBuilder(minDate_).mergeFrom(value).buildPartial();
    } else {
      minDate_ = value;
    }
    bitField0_ |= 0x00000010;
  }
  /**
   * <pre>
   * The minimum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
   */
  private void clearMinDate() {  minDate_ = null;
    bitField0_ = (bitField0_ & ~0x00000010);
  }

  public static final int MAX_DATE_FIELD_NUMBER = 4;
  private org.chromium.chrome.browser.autofill_assistant.proto.DateProto maxDate_;
  /**
   * <pre>
   * The maximum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
   */
  @java.lang.Override
  public boolean hasMaxDate() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <pre>
   * The maximum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getMaxDate() {
    return maxDate_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance() : maxDate_;
  }
  /**
   * <pre>
   * The maximum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
   */
  private void setMaxDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  maxDate_ = value;
    bitField0_ |= 0x00000020;
    }
  /**
   * <pre>
   * The maximum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeMaxDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
    value.getClass();
  if (maxDate_ != null &&
        maxDate_ != org.chromium.chrome.browser.autofill_assistant.proto.DateProto.getDefaultInstance()) {
      maxDate_ =
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.newBuilder(maxDate_).mergeFrom(value).buildPartial();
    } else {
      maxDate_ = value;
    }
    bitField0_ |= 0x00000020;
  }
  /**
   * <pre>
   * The maximum allowed date of the date/time range.
   * </pre>
   *
   * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
   */
  private void clearMaxDate() {  maxDate_ = null;
    bitField0_ = (bitField0_ & ~0x00000020);
  }

  public static final int START_DATE_LABEL_FIELD_NUMBER = 8;
  private java.lang.String startDateLabel_;
  /**
   * <pre>
   * The label for the start date (e.g., 'Pick up date').
   * </pre>
   *
   * <code>optional string start_date_label = 8;</code>
   * @return Whether the startDateLabel field is set.
   */
  @java.lang.Override
  public boolean hasStartDateLabel() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <pre>
   * The label for the start date (e.g., 'Pick up date').
   * </pre>
   *
   * <code>optional string start_date_label = 8;</code>
   * @return The startDateLabel.
   */
  @java.lang.Override
  public java.lang.String getStartDateLabel() {
    return startDateLabel_;
  }
  /**
   * <pre>
   * The label for the start date (e.g., 'Pick up date').
   * </pre>
   *
   * <code>optional string start_date_label = 8;</code>
   * @return The bytes for startDateLabel.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getStartDateLabelBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(startDateLabel_);
  }
  /**
   * <pre>
   * The label for the start date (e.g., 'Pick up date').
   * </pre>
   *
   * <code>optional string start_date_label = 8;</code>
   * @param value The startDateLabel to set.
   */
  private void setStartDateLabel(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000040;
    startDateLabel_ = value;
  }
  /**
   * <pre>
   * The label for the start date (e.g., 'Pick up date').
   * </pre>
   *
   * <code>optional string start_date_label = 8;</code>
   */
  private void clearStartDateLabel() {
    bitField0_ = (bitField0_ & ~0x00000040);
    startDateLabel_ = getDefaultInstance().getStartDateLabel();
  }
  /**
   * <pre>
   * The label for the start date (e.g., 'Pick up date').
   * </pre>
   *
   * <code>optional string start_date_label = 8;</code>
   * @param value The bytes for startDateLabel to set.
   */
  private void setStartDateLabelBytes(
      com.google.protobuf.ByteString value) {
    startDateLabel_ = value.toStringUtf8();
    bitField0_ |= 0x00000040;
  }

  public static final int START_TIME_LABEL_FIELD_NUMBER = 9;
  private java.lang.String startTimeLabel_;
  /**
   * <pre>
   * The label for the start time (e.g., 'Pick up time').
   * </pre>
   *
   * <code>optional string start_time_label = 9;</code>
   * @return Whether the startTimeLabel field is set.
   */
  @java.lang.Override
  public boolean hasStartTimeLabel() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <pre>
   * The label for the start time (e.g., 'Pick up time').
   * </pre>
   *
   * <code>optional string start_time_label = 9;</code>
   * @return The startTimeLabel.
   */
  @java.lang.Override
  public java.lang.String getStartTimeLabel() {
    return startTimeLabel_;
  }
  /**
   * <pre>
   * The label for the start time (e.g., 'Pick up time').
   * </pre>
   *
   * <code>optional string start_time_label = 9;</code>
   * @return The bytes for startTimeLabel.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getStartTimeLabelBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(startTimeLabel_);
  }
  /**
   * <pre>
   * The label for the start time (e.g., 'Pick up time').
   * </pre>
   *
   * <code>optional string start_time_label = 9;</code>
   * @param value The startTimeLabel to set.
   */
  private void setStartTimeLabel(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000080;
    startTimeLabel_ = value;
  }
  /**
   * <pre>
   * The label for the start time (e.g., 'Pick up time').
   * </pre>
   *
   * <code>optional string start_time_label = 9;</code>
   */
  private void clearStartTimeLabel() {
    bitField0_ = (bitField0_ & ~0x00000080);
    startTimeLabel_ = getDefaultInstance().getStartTimeLabel();
  }
  /**
   * <pre>
   * The label for the start time (e.g., 'Pick up time').
   * </pre>
   *
   * <code>optional string start_time_label = 9;</code>
   * @param value The bytes for startTimeLabel to set.
   */
  private void setStartTimeLabelBytes(
      com.google.protobuf.ByteString value) {
    startTimeLabel_ = value.toStringUtf8();
    bitField0_ |= 0x00000080;
  }

  public static final int END_DATE_LABEL_FIELD_NUMBER = 10;
  private java.lang.String endDateLabel_;
  /**
   * <pre>
   * The label for the end date (e.g., 'Drop off date').
   * </pre>
   *
   * <code>optional string end_date_label = 10;</code>
   * @return Whether the endDateLabel field is set.
   */
  @java.lang.Override
  public boolean hasEndDateLabel() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <pre>
   * The label for the end date (e.g., 'Drop off date').
   * </pre>
   *
   * <code>optional string end_date_label = 10;</code>
   * @return The endDateLabel.
   */
  @java.lang.Override
  public java.lang.String getEndDateLabel() {
    return endDateLabel_;
  }
  /**
   * <pre>
   * The label for the end date (e.g., 'Drop off date').
   * </pre>
   *
   * <code>optional string end_date_label = 10;</code>
   * @return The bytes for endDateLabel.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getEndDateLabelBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(endDateLabel_);
  }
  /**
   * <pre>
   * The label for the end date (e.g., 'Drop off date').
   * </pre>
   *
   * <code>optional string end_date_label = 10;</code>
   * @param value The endDateLabel to set.
   */
  private void setEndDateLabel(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000100;
    endDateLabel_ = value;
  }
  /**
   * <pre>
   * The label for the end date (e.g., 'Drop off date').
   * </pre>
   *
   * <code>optional string end_date_label = 10;</code>
   */
  private void clearEndDateLabel() {
    bitField0_ = (bitField0_ & ~0x00000100);
    endDateLabel_ = getDefaultInstance().getEndDateLabel();
  }
  /**
   * <pre>
   * The label for the end date (e.g., 'Drop off date').
   * </pre>
   *
   * <code>optional string end_date_label = 10;</code>
   * @param value The bytes for endDateLabel to set.
   */
  private void setEndDateLabelBytes(
      com.google.protobuf.ByteString value) {
    endDateLabel_ = value.toStringUtf8();
    bitField0_ |= 0x00000100;
  }

  public static final int END_TIME_LABEL_FIELD_NUMBER = 11;
  private java.lang.String endTimeLabel_;
  /**
   * <pre>
   * The label for the end time (e.g., 'Drop off time').
   * </pre>
   *
   * <code>optional string end_time_label = 11;</code>
   * @return Whether the endTimeLabel field is set.
   */
  @java.lang.Override
  public boolean hasEndTimeLabel() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <pre>
   * The label for the end time (e.g., 'Drop off time').
   * </pre>
   *
   * <code>optional string end_time_label = 11;</code>
   * @return The endTimeLabel.
   */
  @java.lang.Override
  public java.lang.String getEndTimeLabel() {
    return endTimeLabel_;
  }
  /**
   * <pre>
   * The label for the end time (e.g., 'Drop off time').
   * </pre>
   *
   * <code>optional string end_time_label = 11;</code>
   * @return The bytes for endTimeLabel.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getEndTimeLabelBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(endTimeLabel_);
  }
  /**
   * <pre>
   * The label for the end time (e.g., 'Drop off time').
   * </pre>
   *
   * <code>optional string end_time_label = 11;</code>
   * @param value The endTimeLabel to set.
   */
  private void setEndTimeLabel(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000200;
    endTimeLabel_ = value;
  }
  /**
   * <pre>
   * The label for the end time (e.g., 'Drop off time').
   * </pre>
   *
   * <code>optional string end_time_label = 11;</code>
   */
  private void clearEndTimeLabel() {
    bitField0_ = (bitField0_ & ~0x00000200);
    endTimeLabel_ = getDefaultInstance().getEndTimeLabel();
  }
  /**
   * <pre>
   * The label for the end time (e.g., 'Drop off time').
   * </pre>
   *
   * <code>optional string end_time_label = 11;</code>
   * @param value The bytes for endTimeLabel to set.
   */
  private void setEndTimeLabelBytes(
      com.google.protobuf.ByteString value) {
    endTimeLabel_ = value.toStringUtf8();
    bitField0_ |= 0x00000200;
  }

  public static final int TIME_SLOTS_FIELD_NUMBER = 12;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> timeSlots_;
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> getTimeSlotsList() {
    return timeSlots_;
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  public java.util.List<? extends org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlotOrBuilder> 
      getTimeSlotsOrBuilderList() {
    return timeSlots_;
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  @java.lang.Override
  public int getTimeSlotsCount() {
    return timeSlots_.size();
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot getTimeSlots(int index) {
    return timeSlots_.get(index);
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  public org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlotOrBuilder getTimeSlotsOrBuilder(
      int index) {
    return timeSlots_.get(index);
  }
  private void ensureTimeSlotsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> tmp = timeSlots_;
    if (!tmp.isModifiable()) {
      timeSlots_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  private void setTimeSlots(
      int index, org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot value) {
    value.getClass();
  ensureTimeSlotsIsMutable();
    timeSlots_.set(index, value);
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  private void addTimeSlots(org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot value) {
    value.getClass();
  ensureTimeSlotsIsMutable();
    timeSlots_.add(value);
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  private void addTimeSlots(
      int index, org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot value) {
    value.getClass();
  ensureTimeSlotsIsMutable();
    timeSlots_.add(index, value);
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  private void addAllTimeSlots(
      java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> values) {
    ensureTimeSlotsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, timeSlots_);
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  private void clearTimeSlots() {
    timeSlots_ = emptyProtobufList();
  }
  /**
   * <pre>
   * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
   * </pre>
   *
   * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
   */
  private void removeTimeSlots(int index) {
    ensureTimeSlotsIsMutable();
    timeSlots_.remove(index);
  }

  public static final int DATE_NOT_SET_ERROR_FIELD_NUMBER = 17;
  private java.lang.String dateNotSetError_;
  /**
   * <pre>
   * The error message to display if the date is not set.
   * </pre>
   *
   * <code>optional string date_not_set_error = 17;</code>
   * @return Whether the dateNotSetError field is set.
   */
  @java.lang.Override
  public boolean hasDateNotSetError() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <pre>
   * The error message to display if the date is not set.
   * </pre>
   *
   * <code>optional string date_not_set_error = 17;</code>
   * @return The dateNotSetError.
   */
  @java.lang.Override
  public java.lang.String getDateNotSetError() {
    return dateNotSetError_;
  }
  /**
   * <pre>
   * The error message to display if the date is not set.
   * </pre>
   *
   * <code>optional string date_not_set_error = 17;</code>
   * @return The bytes for dateNotSetError.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getDateNotSetErrorBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(dateNotSetError_);
  }
  /**
   * <pre>
   * The error message to display if the date is not set.
   * </pre>
   *
   * <code>optional string date_not_set_error = 17;</code>
   * @param value The dateNotSetError to set.
   */
  private void setDateNotSetError(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000400;
    dateNotSetError_ = value;
  }
  /**
   * <pre>
   * The error message to display if the date is not set.
   * </pre>
   *
   * <code>optional string date_not_set_error = 17;</code>
   */
  private void clearDateNotSetError() {
    bitField0_ = (bitField0_ & ~0x00000400);
    dateNotSetError_ = getDefaultInstance().getDateNotSetError();
  }
  /**
   * <pre>
   * The error message to display if the date is not set.
   * </pre>
   *
   * <code>optional string date_not_set_error = 17;</code>
   * @param value The bytes for dateNotSetError to set.
   */
  private void setDateNotSetErrorBytes(
      com.google.protobuf.ByteString value) {
    dateNotSetError_ = value.toStringUtf8();
    bitField0_ |= 0x00000400;
  }

  public static final int TIME_NOT_SET_ERROR_FIELD_NUMBER = 18;
  private java.lang.String timeNotSetError_;
  /**
   * <pre>
   * The error message to display if the time is not set.
   * </pre>
   *
   * <code>optional string time_not_set_error = 18;</code>
   * @return Whether the timeNotSetError field is set.
   */
  @java.lang.Override
  public boolean hasTimeNotSetError() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   * <pre>
   * The error message to display if the time is not set.
   * </pre>
   *
   * <code>optional string time_not_set_error = 18;</code>
   * @return The timeNotSetError.
   */
  @java.lang.Override
  public java.lang.String getTimeNotSetError() {
    return timeNotSetError_;
  }
  /**
   * <pre>
   * The error message to display if the time is not set.
   * </pre>
   *
   * <code>optional string time_not_set_error = 18;</code>
   * @return The bytes for timeNotSetError.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getTimeNotSetErrorBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(timeNotSetError_);
  }
  /**
   * <pre>
   * The error message to display if the time is not set.
   * </pre>
   *
   * <code>optional string time_not_set_error = 18;</code>
   * @param value The timeNotSetError to set.
   */
  private void setTimeNotSetError(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000800;
    timeNotSetError_ = value;
  }
  /**
   * <pre>
   * The error message to display if the time is not set.
   * </pre>
   *
   * <code>optional string time_not_set_error = 18;</code>
   */
  private void clearTimeNotSetError() {
    bitField0_ = (bitField0_ & ~0x00000800);
    timeNotSetError_ = getDefaultInstance().getTimeNotSetError();
  }
  /**
   * <pre>
   * The error message to display if the time is not set.
   * </pre>
   *
   * <code>optional string time_not_set_error = 18;</code>
   * @param value The bytes for timeNotSetError to set.
   */
  private void setTimeNotSetErrorBytes(
      com.google.protobuf.ByteString value) {
    timeNotSetError_ = value.toStringUtf8();
    bitField0_ |= 0x00000800;
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code autofill_assistant.DateTimeRangeProto}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto, Builder> implements
      // @@protoc_insertion_point(builder_implements:autofill_assistant.DateTimeRangeProto)
      org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProtoOrBuilder {
    // Construct using org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The initial start date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
     */
    @java.lang.Override
    public boolean hasStartDate() {
      return instance.hasStartDate();
    }
    /**
     * <pre>
     * The initial start date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getStartDate() {
      return instance.getStartDate();
    }
    /**
     * <pre>
     * The initial start date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
     */
    public Builder setStartDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.setStartDate(value);
      return this;
      }
    /**
     * <pre>
     * The initial start date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
     */
    public Builder setStartDate(
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.Builder builderForValue) {
      copyOnWrite();
      instance.setStartDate(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The initial start date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
     */
    public Builder mergeStartDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.mergeStartDate(value);
      return this;
    }
    /**
     * <pre>
     * The initial start date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto start_date = 15;</code>
     */
    public Builder clearStartDate() {  copyOnWrite();
      instance.clearStartDate();
      return this;
    }

    /**
     * <pre>
     * The index of the initial start time slot to select.
     * </pre>
     *
     * <code>optional int32 start_time_slot = 13;</code>
     * @return Whether the startTimeSlot field is set.
     */
    @java.lang.Override
    public boolean hasStartTimeSlot() {
      return instance.hasStartTimeSlot();
    }
    /**
     * <pre>
     * The index of the initial start time slot to select.
     * </pre>
     *
     * <code>optional int32 start_time_slot = 13;</code>
     * @return The startTimeSlot.
     */
    @java.lang.Override
    public int getStartTimeSlot() {
      return instance.getStartTimeSlot();
    }
    /**
     * <pre>
     * The index of the initial start time slot to select.
     * </pre>
     *
     * <code>optional int32 start_time_slot = 13;</code>
     * @param value The startTimeSlot to set.
     * @return This builder for chaining.
     */
    public Builder setStartTimeSlot(int value) {
      copyOnWrite();
      instance.setStartTimeSlot(value);
      return this;
    }
    /**
     * <pre>
     * The index of the initial start time slot to select.
     * </pre>
     *
     * <code>optional int32 start_time_slot = 13;</code>
     * @return This builder for chaining.
     */
    public Builder clearStartTimeSlot() {
      copyOnWrite();
      instance.clearStartTimeSlot();
      return this;
    }

    /**
     * <pre>
     * The initial end date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
     */
    @java.lang.Override
    public boolean hasEndDate() {
      return instance.hasEndDate();
    }
    /**
     * <pre>
     * The initial end date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getEndDate() {
      return instance.getEndDate();
    }
    /**
     * <pre>
     * The initial end date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
     */
    public Builder setEndDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.setEndDate(value);
      return this;
      }
    /**
     * <pre>
     * The initial end date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
     */
    public Builder setEndDate(
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.Builder builderForValue) {
      copyOnWrite();
      instance.setEndDate(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The initial end date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
     */
    public Builder mergeEndDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.mergeEndDate(value);
      return this;
    }
    /**
     * <pre>
     * The initial end date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto end_date = 16;</code>
     */
    public Builder clearEndDate() {  copyOnWrite();
      instance.clearEndDate();
      return this;
    }

    /**
     * <pre>
     * The index of the initial end time slot to select.
     * </pre>
     *
     * <code>optional int32 end_time_slot = 14;</code>
     * @return Whether the endTimeSlot field is set.
     */
    @java.lang.Override
    public boolean hasEndTimeSlot() {
      return instance.hasEndTimeSlot();
    }
    /**
     * <pre>
     * The index of the initial end time slot to select.
     * </pre>
     *
     * <code>optional int32 end_time_slot = 14;</code>
     * @return The endTimeSlot.
     */
    @java.lang.Override
    public int getEndTimeSlot() {
      return instance.getEndTimeSlot();
    }
    /**
     * <pre>
     * The index of the initial end time slot to select.
     * </pre>
     *
     * <code>optional int32 end_time_slot = 14;</code>
     * @param value The endTimeSlot to set.
     * @return This builder for chaining.
     */
    public Builder setEndTimeSlot(int value) {
      copyOnWrite();
      instance.setEndTimeSlot(value);
      return this;
    }
    /**
     * <pre>
     * The index of the initial end time slot to select.
     * </pre>
     *
     * <code>optional int32 end_time_slot = 14;</code>
     * @return This builder for chaining.
     */
    public Builder clearEndTimeSlot() {
      copyOnWrite();
      instance.clearEndTimeSlot();
      return this;
    }

    /**
     * <pre>
     * The minimum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
     */
    @java.lang.Override
    public boolean hasMinDate() {
      return instance.hasMinDate();
    }
    /**
     * <pre>
     * The minimum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getMinDate() {
      return instance.getMinDate();
    }
    /**
     * <pre>
     * The minimum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
     */
    public Builder setMinDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.setMinDate(value);
      return this;
      }
    /**
     * <pre>
     * The minimum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
     */
    public Builder setMinDate(
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.Builder builderForValue) {
      copyOnWrite();
      instance.setMinDate(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The minimum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
     */
    public Builder mergeMinDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.mergeMinDate(value);
      return this;
    }
    /**
     * <pre>
     * The minimum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto min_date = 3;</code>
     */
    public Builder clearMinDate() {  copyOnWrite();
      instance.clearMinDate();
      return this;
    }

    /**
     * <pre>
     * The maximum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
     */
    @java.lang.Override
    public boolean hasMaxDate() {
      return instance.hasMaxDate();
    }
    /**
     * <pre>
     * The maximum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.DateProto getMaxDate() {
      return instance.getMaxDate();
    }
    /**
     * <pre>
     * The maximum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
     */
    public Builder setMaxDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.setMaxDate(value);
      return this;
      }
    /**
     * <pre>
     * The maximum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
     */
    public Builder setMaxDate(
        org.chromium.chrome.browser.autofill_assistant.proto.DateProto.Builder builderForValue) {
      copyOnWrite();
      instance.setMaxDate(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The maximum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
     */
    public Builder mergeMaxDate(org.chromium.chrome.browser.autofill_assistant.proto.DateProto value) {
      copyOnWrite();
      instance.mergeMaxDate(value);
      return this;
    }
    /**
     * <pre>
     * The maximum allowed date of the date/time range.
     * </pre>
     *
     * <code>optional .autofill_assistant.DateProto max_date = 4;</code>
     */
    public Builder clearMaxDate() {  copyOnWrite();
      instance.clearMaxDate();
      return this;
    }

    /**
     * <pre>
     * The label for the start date (e.g., 'Pick up date').
     * </pre>
     *
     * <code>optional string start_date_label = 8;</code>
     * @return Whether the startDateLabel field is set.
     */
    @java.lang.Override
    public boolean hasStartDateLabel() {
      return instance.hasStartDateLabel();
    }
    /**
     * <pre>
     * The label for the start date (e.g., 'Pick up date').
     * </pre>
     *
     * <code>optional string start_date_label = 8;</code>
     * @return The startDateLabel.
     */
    @java.lang.Override
    public java.lang.String getStartDateLabel() {
      return instance.getStartDateLabel();
    }
    /**
     * <pre>
     * The label for the start date (e.g., 'Pick up date').
     * </pre>
     *
     * <code>optional string start_date_label = 8;</code>
     * @return The bytes for startDateLabel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStartDateLabelBytes() {
      return instance.getStartDateLabelBytes();
    }
    /**
     * <pre>
     * The label for the start date (e.g., 'Pick up date').
     * </pre>
     *
     * <code>optional string start_date_label = 8;</code>
     * @param value The startDateLabel to set.
     * @return This builder for chaining.
     */
    public Builder setStartDateLabel(
        java.lang.String value) {
      copyOnWrite();
      instance.setStartDateLabel(value);
      return this;
    }
    /**
     * <pre>
     * The label for the start date (e.g., 'Pick up date').
     * </pre>
     *
     * <code>optional string start_date_label = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearStartDateLabel() {
      copyOnWrite();
      instance.clearStartDateLabel();
      return this;
    }
    /**
     * <pre>
     * The label for the start date (e.g., 'Pick up date').
     * </pre>
     *
     * <code>optional string start_date_label = 8;</code>
     * @param value The bytes for startDateLabel to set.
     * @return This builder for chaining.
     */
    public Builder setStartDateLabelBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setStartDateLabelBytes(value);
      return this;
    }

    /**
     * <pre>
     * The label for the start time (e.g., 'Pick up time').
     * </pre>
     *
     * <code>optional string start_time_label = 9;</code>
     * @return Whether the startTimeLabel field is set.
     */
    @java.lang.Override
    public boolean hasStartTimeLabel() {
      return instance.hasStartTimeLabel();
    }
    /**
     * <pre>
     * The label for the start time (e.g., 'Pick up time').
     * </pre>
     *
     * <code>optional string start_time_label = 9;</code>
     * @return The startTimeLabel.
     */
    @java.lang.Override
    public java.lang.String getStartTimeLabel() {
      return instance.getStartTimeLabel();
    }
    /**
     * <pre>
     * The label for the start time (e.g., 'Pick up time').
     * </pre>
     *
     * <code>optional string start_time_label = 9;</code>
     * @return The bytes for startTimeLabel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStartTimeLabelBytes() {
      return instance.getStartTimeLabelBytes();
    }
    /**
     * <pre>
     * The label for the start time (e.g., 'Pick up time').
     * </pre>
     *
     * <code>optional string start_time_label = 9;</code>
     * @param value The startTimeLabel to set.
     * @return This builder for chaining.
     */
    public Builder setStartTimeLabel(
        java.lang.String value) {
      copyOnWrite();
      instance.setStartTimeLabel(value);
      return this;
    }
    /**
     * <pre>
     * The label for the start time (e.g., 'Pick up time').
     * </pre>
     *
     * <code>optional string start_time_label = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearStartTimeLabel() {
      copyOnWrite();
      instance.clearStartTimeLabel();
      return this;
    }
    /**
     * <pre>
     * The label for the start time (e.g., 'Pick up time').
     * </pre>
     *
     * <code>optional string start_time_label = 9;</code>
     * @param value The bytes for startTimeLabel to set.
     * @return This builder for chaining.
     */
    public Builder setStartTimeLabelBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setStartTimeLabelBytes(value);
      return this;
    }

    /**
     * <pre>
     * The label for the end date (e.g., 'Drop off date').
     * </pre>
     *
     * <code>optional string end_date_label = 10;</code>
     * @return Whether the endDateLabel field is set.
     */
    @java.lang.Override
    public boolean hasEndDateLabel() {
      return instance.hasEndDateLabel();
    }
    /**
     * <pre>
     * The label for the end date (e.g., 'Drop off date').
     * </pre>
     *
     * <code>optional string end_date_label = 10;</code>
     * @return The endDateLabel.
     */
    @java.lang.Override
    public java.lang.String getEndDateLabel() {
      return instance.getEndDateLabel();
    }
    /**
     * <pre>
     * The label for the end date (e.g., 'Drop off date').
     * </pre>
     *
     * <code>optional string end_date_label = 10;</code>
     * @return The bytes for endDateLabel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEndDateLabelBytes() {
      return instance.getEndDateLabelBytes();
    }
    /**
     * <pre>
     * The label for the end date (e.g., 'Drop off date').
     * </pre>
     *
     * <code>optional string end_date_label = 10;</code>
     * @param value The endDateLabel to set.
     * @return This builder for chaining.
     */
    public Builder setEndDateLabel(
        java.lang.String value) {
      copyOnWrite();
      instance.setEndDateLabel(value);
      return this;
    }
    /**
     * <pre>
     * The label for the end date (e.g., 'Drop off date').
     * </pre>
     *
     * <code>optional string end_date_label = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearEndDateLabel() {
      copyOnWrite();
      instance.clearEndDateLabel();
      return this;
    }
    /**
     * <pre>
     * The label for the end date (e.g., 'Drop off date').
     * </pre>
     *
     * <code>optional string end_date_label = 10;</code>
     * @param value The bytes for endDateLabel to set.
     * @return This builder for chaining.
     */
    public Builder setEndDateLabelBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEndDateLabelBytes(value);
      return this;
    }

    /**
     * <pre>
     * The label for the end time (e.g., 'Drop off time').
     * </pre>
     *
     * <code>optional string end_time_label = 11;</code>
     * @return Whether the endTimeLabel field is set.
     */
    @java.lang.Override
    public boolean hasEndTimeLabel() {
      return instance.hasEndTimeLabel();
    }
    /**
     * <pre>
     * The label for the end time (e.g., 'Drop off time').
     * </pre>
     *
     * <code>optional string end_time_label = 11;</code>
     * @return The endTimeLabel.
     */
    @java.lang.Override
    public java.lang.String getEndTimeLabel() {
      return instance.getEndTimeLabel();
    }
    /**
     * <pre>
     * The label for the end time (e.g., 'Drop off time').
     * </pre>
     *
     * <code>optional string end_time_label = 11;</code>
     * @return The bytes for endTimeLabel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEndTimeLabelBytes() {
      return instance.getEndTimeLabelBytes();
    }
    /**
     * <pre>
     * The label for the end time (e.g., 'Drop off time').
     * </pre>
     *
     * <code>optional string end_time_label = 11;</code>
     * @param value The endTimeLabel to set.
     * @return This builder for chaining.
     */
    public Builder setEndTimeLabel(
        java.lang.String value) {
      copyOnWrite();
      instance.setEndTimeLabel(value);
      return this;
    }
    /**
     * <pre>
     * The label for the end time (e.g., 'Drop off time').
     * </pre>
     *
     * <code>optional string end_time_label = 11;</code>
     * @return This builder for chaining.
     */
    public Builder clearEndTimeLabel() {
      copyOnWrite();
      instance.clearEndTimeLabel();
      return this;
    }
    /**
     * <pre>
     * The label for the end time (e.g., 'Drop off time').
     * </pre>
     *
     * <code>optional string end_time_label = 11;</code>
     * @param value The bytes for endTimeLabel to set.
     * @return This builder for chaining.
     */
    public Builder setEndTimeLabelBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEndTimeLabelBytes(value);
      return this;
    }

    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> getTimeSlotsList() {
      return java.util.Collections.unmodifiableList(
          instance.getTimeSlotsList());
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    @java.lang.Override
    public int getTimeSlotsCount() {
      return instance.getTimeSlotsCount();
    }/**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot getTimeSlots(int index) {
      return instance.getTimeSlots(index);
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder setTimeSlots(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot value) {
      copyOnWrite();
      instance.setTimeSlots(index, value);
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder setTimeSlots(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot.Builder builderForValue) {
      copyOnWrite();
      instance.setTimeSlots(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder addTimeSlots(org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot value) {
      copyOnWrite();
      instance.addTimeSlots(value);
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder addTimeSlots(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot value) {
      copyOnWrite();
      instance.addTimeSlots(index, value);
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder addTimeSlots(
        org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot.Builder builderForValue) {
      copyOnWrite();
      instance.addTimeSlots(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder addTimeSlots(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot.Builder builderForValue) {
      copyOnWrite();
      instance.addTimeSlots(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder addAllTimeSlots(
        java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot> values) {
      copyOnWrite();
      instance.addAllTimeSlots(values);
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder clearTimeSlots() {
      copyOnWrite();
      instance.clearTimeSlots();
      return this;
    }
    /**
     * <pre>
     * The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
     * </pre>
     *
     * <code>repeated .autofill_assistant.DateTimeRangeProto.TimeSlot time_slots = 12;</code>
     */
    public Builder removeTimeSlots(int index) {
      copyOnWrite();
      instance.removeTimeSlots(index);
      return this;
    }

    /**
     * <pre>
     * The error message to display if the date is not set.
     * </pre>
     *
     * <code>optional string date_not_set_error = 17;</code>
     * @return Whether the dateNotSetError field is set.
     */
    @java.lang.Override
    public boolean hasDateNotSetError() {
      return instance.hasDateNotSetError();
    }
    /**
     * <pre>
     * The error message to display if the date is not set.
     * </pre>
     *
     * <code>optional string date_not_set_error = 17;</code>
     * @return The dateNotSetError.
     */
    @java.lang.Override
    public java.lang.String getDateNotSetError() {
      return instance.getDateNotSetError();
    }
    /**
     * <pre>
     * The error message to display if the date is not set.
     * </pre>
     *
     * <code>optional string date_not_set_error = 17;</code>
     * @return The bytes for dateNotSetError.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDateNotSetErrorBytes() {
      return instance.getDateNotSetErrorBytes();
    }
    /**
     * <pre>
     * The error message to display if the date is not set.
     * </pre>
     *
     * <code>optional string date_not_set_error = 17;</code>
     * @param value The dateNotSetError to set.
     * @return This builder for chaining.
     */
    public Builder setDateNotSetError(
        java.lang.String value) {
      copyOnWrite();
      instance.setDateNotSetError(value);
      return this;
    }
    /**
     * <pre>
     * The error message to display if the date is not set.
     * </pre>
     *
     * <code>optional string date_not_set_error = 17;</code>
     * @return This builder for chaining.
     */
    public Builder clearDateNotSetError() {
      copyOnWrite();
      instance.clearDateNotSetError();
      return this;
    }
    /**
     * <pre>
     * The error message to display if the date is not set.
     * </pre>
     *
     * <code>optional string date_not_set_error = 17;</code>
     * @param value The bytes for dateNotSetError to set.
     * @return This builder for chaining.
     */
    public Builder setDateNotSetErrorBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDateNotSetErrorBytes(value);
      return this;
    }

    /**
     * <pre>
     * The error message to display if the time is not set.
     * </pre>
     *
     * <code>optional string time_not_set_error = 18;</code>
     * @return Whether the timeNotSetError field is set.
     */
    @java.lang.Override
    public boolean hasTimeNotSetError() {
      return instance.hasTimeNotSetError();
    }
    /**
     * <pre>
     * The error message to display if the time is not set.
     * </pre>
     *
     * <code>optional string time_not_set_error = 18;</code>
     * @return The timeNotSetError.
     */
    @java.lang.Override
    public java.lang.String getTimeNotSetError() {
      return instance.getTimeNotSetError();
    }
    /**
     * <pre>
     * The error message to display if the time is not set.
     * </pre>
     *
     * <code>optional string time_not_set_error = 18;</code>
     * @return The bytes for timeNotSetError.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTimeNotSetErrorBytes() {
      return instance.getTimeNotSetErrorBytes();
    }
    /**
     * <pre>
     * The error message to display if the time is not set.
     * </pre>
     *
     * <code>optional string time_not_set_error = 18;</code>
     * @param value The timeNotSetError to set.
     * @return This builder for chaining.
     */
    public Builder setTimeNotSetError(
        java.lang.String value) {
      copyOnWrite();
      instance.setTimeNotSetError(value);
      return this;
    }
    /**
     * <pre>
     * The error message to display if the time is not set.
     * </pre>
     *
     * <code>optional string time_not_set_error = 18;</code>
     * @return This builder for chaining.
     */
    public Builder clearTimeNotSetError() {
      copyOnWrite();
      instance.clearTimeNotSetError();
      return this;
    }
    /**
     * <pre>
     * The error message to display if the time is not set.
     * </pre>
     *
     * <code>optional string time_not_set_error = 18;</code>
     * @param value The bytes for timeNotSetError to set.
     * @return This builder for chaining.
     */
    public Builder setTimeNotSetErrorBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setTimeNotSetErrorBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:autofill_assistant.DateTimeRangeProto)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "minDate_",
            "maxDate_",
            "startDateLabel_",
            "startTimeLabel_",
            "endDateLabel_",
            "endTimeLabel_",
            "timeSlots_",
            org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.TimeSlot.class,
            "startTimeSlot_",
            "endTimeSlot_",
            "startDate_",
            "endDate_",
            "dateNotSetError_",
            "timeNotSetError_",
          };
          java.lang.String info =
              "\u0001\r\u0000\u0001\u0003\u0012\r\u0000\u0001\u0000\u0003\u1009\u0004\u0004\u1009" +
              "\u0005\b\u1008\u0006\t\u1008\u0007\n\u1008\b\u000b\u1008\t\f\u001b\r\u1004\u0001" +
              "\u000e\u1004\u0003\u000f\u1009\u0000\u0010\u1009\u0002\u0011\u1008\n\u0012\u1008" +
              "\u000b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:autofill_assistant.DateTimeRangeProto)
  private static final org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto DEFAULT_INSTANCE;
  static {
    DateTimeRangeProto defaultInstance = new DateTimeRangeProto();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      DateTimeRangeProto.class, defaultInstance);
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.DateTimeRangeProto getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<DateTimeRangeProto> PARSER;

  public static com.google.protobuf.Parser<DateTimeRangeProto> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

