// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

public interface ClientSettingsProtoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:autofill_assistant.ClientSettingsProto)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   * @return Whether the periodicScriptCheckIntervalMs field is set.
   */
  boolean hasPeriodicScriptCheckIntervalMs();
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   * @return The periodicScriptCheckIntervalMs.
   */
  int getPeriodicScriptCheckIntervalMs();

  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   * @return Whether the periodicElementCheckIntervalMs field is set.
   */
  boolean hasPeriodicElementCheckIntervalMs();
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   * @return The periodicElementCheckIntervalMs.
   */
  int getPeriodicElementCheckIntervalMs();

  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   * @return Whether the periodicScriptCheckCount field is set.
   */
  boolean hasPeriodicScriptCheckCount();
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   * @return The periodicScriptCheckCount.
   */
  int getPeriodicScriptCheckCount();

  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   * @return Whether the elementPositionUpdateIntervalMs field is set.
   */
  boolean hasElementPositionUpdateIntervalMs();
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   * @return The elementPositionUpdateIntervalMs.
   */
  int getElementPositionUpdateIntervalMs();

  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   * @return Whether the shortWaitForElementDeadlineMs field is set.
   */
  boolean hasShortWaitForElementDeadlineMs();
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   * @return The shortWaitForElementDeadlineMs.
   */
  int getShortWaitForElementDeadlineMs();

  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   * @return Whether the boxModelCheckIntervalMs field is set.
   */
  boolean hasBoxModelCheckIntervalMs();
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   * @return The boxModelCheckIntervalMs.
   */
  int getBoxModelCheckIntervalMs();

  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   * @return Whether the boxModelCheckCount field is set.
   */
  boolean hasBoxModelCheckCount();
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   * @return The boxModelCheckCount.
   */
  int getBoxModelCheckCount();

  /**
   * <pre>
   * Maximum time to wait until document has reached "ready" state.
   * </pre>
   *
   * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
   * @return Whether the documentReadyCheckTimeoutMs field is set.
   */
  boolean hasDocumentReadyCheckTimeoutMs();
  /**
   * <pre>
   * Maximum time to wait until document has reached "ready" state.
   * </pre>
   *
   * <code>optional int32 document_ready_check_timeout_ms = 20;</code>
   * @return The documentReadyCheckTimeoutMs.
   */
  int getDocumentReadyCheckTimeoutMs();

  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   * @return Whether the cancelDelayMs field is set.
   */
  boolean hasCancelDelayMs();
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   * @return The cancelDelayMs.
   */
  int getCancelDelayMs();

  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   * @return Whether the tapCount field is set.
   */
  boolean hasTapCount();
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   * @return The tapCount.
   */
  int getTapCount();

  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   * @return Whether the tapTrackingDurationMs field is set.
   */
  boolean hasTapTrackingDurationMs();
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   * @return The tapTrackingDurationMs.
   */
  int getTapTrackingDurationMs();

  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   * @return Whether the tapShutdownDelayMs field is set.
   */
  boolean hasTapShutdownDelayMs();
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   * @return The tapShutdownDelayMs.
   */
  int getTapShutdownDelayMs();

  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   * @return Whether the overlayImage field is set.
   */
  boolean hasOverlayImage();
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   * @return The overlayImage.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto getOverlayImage();

  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   * @return Whether the integrationTestSettings field is set.
   */
  boolean hasIntegrationTestSettings();
  /**
   * <pre>
   * Optional settings intended for integration tests.
   * </pre>
   *
   * <code>optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;</code>
   * @return The integrationTestSettings.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.IntegrationTestSettings getIntegrationTestSettings();

  /**
   * <pre>
   * Optional setting defining the size of the bottom sheet when Talkback is
   * enabled as a fraction of the available height. When set, the bottomsheet
   * will stop resizing automatically in talkback mode. It will always have the
   * specified size instead.
   * </pre>
   *
   * <code>optional float talkback_sheet_size_fraction = 18;</code>
   * @return Whether the talkbackSheetSizeFraction field is set.
   */
  boolean hasTalkbackSheetSizeFraction();
  /**
   * <pre>
   * Optional setting defining the size of the bottom sheet when Talkback is
   * enabled as a fraction of the available height. When set, the bottomsheet
   * will stop resizing automatically in talkback mode. It will always have the
   * specified size instead.
   * </pre>
   *
   * <code>optional float talkback_sheet_size_fraction = 18;</code>
   * @return The talkbackSheetSizeFraction.
   */
  float getTalkbackSheetSizeFraction();

  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   * @return Whether the backButtonSettings field is set.
   */
  boolean hasBackButtonSettings();
  /**
   * <code>optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;</code>
   * @return The backButtonSettings.
   */
  org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.BackButtonSettings getBackButtonSettings();
}
