// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

/**
 * <pre>
 * A reference to one or more elements on the page, possibly nested in frames.
 * </pre>
 *
 * Protobuf type {@code autofill_assistant.SelectorProto}
 */
public  final class SelectorProto extends
    com.google.protobuf.GeneratedMessageLite<
        SelectorProto, SelectorProto.Builder> implements
    // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto)
    SelectorProtoOrBuilder {
  private SelectorProto() {
    filters_ = emptyProtobufList();
  }
  public interface FilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.Filter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     * @return Whether the enterFrame field is set.
     */
    boolean hasEnterFrame();
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     * @return The enterFrame.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getEnterFrame();

    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return Whether the cssSelector field is set.
     */
    boolean hasCssSelector();
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The cssSelector.
     */
    java.lang.String getCssSelector();
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The bytes for cssSelector.
     */
    com.google.protobuf.ByteString
        getCssSelectorBytes();

    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     * @return Whether the innerText field is set.
     */
    boolean hasInnerText();
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     * @return The innerText.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getInnerText();

    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     * @return The value.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getValue();

    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return Whether the pseudoType field is set.
     */
    boolean hasPseudoType();
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return The pseudoType.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType();

    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     * @return Whether the boundingBox field is set.
     */
    boolean hasBoundingBox();
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     * @return The boundingBox.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getBoundingBox();

    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     * @return Whether the nthMatch field is set.
     */
    boolean hasNthMatch();
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     * @return The nthMatch.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getNthMatch();

    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     * @return Whether the pseudoElementContent field is set.
     */
    boolean hasPseudoElementContent();
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     * @return The pseudoElementContent.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getPseudoElementContent();

    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     * @return Whether the labelled field is set.
     */
    boolean hasLabelled();
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     * @return The labelled.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getLabelled();

    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     * @return Whether the closest field is set.
     */
    boolean hasClosest();
    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     * @return The closest.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter getClosest();

    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return Whether the matchCssSelector field is set.
     */
    boolean hasMatchCssSelector();
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The matchCssSelector.
     */
    java.lang.String getMatchCssSelector();
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The bytes for matchCssSelector.
     */
    com.google.protobuf.ByteString
        getMatchCssSelectorBytes();

    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     * @return Whether the cssStyle field is set.
     */
    boolean hasCssStyle();
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     * @return The cssStyle.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getCssStyle();

    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     * @return Whether the onTop field is set.
     */
    boolean hasOnTop();
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     * @return The onTop.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getOnTop();

    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.FilterCase getFilterCase();
  }
  /**
   * <pre>
   * A filter that starts with one or more elements and returns one on more
   * elements. Filters are meant to be applied sequentially.
   * The returned elements will be sorted by their order in the document.
   * Elements that were matched via the labelled filter will have the same order
   * as their label.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.Filter}
   */
  public  static final class Filter extends
      com.google.protobuf.GeneratedMessageLite<
          Filter, Filter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.Filter)
      FilterOrBuilder {
    private Filter() {
    }
    private int bitField0_;
    private int filterCase_ = 0;
    private java.lang.Object filter_;
    public enum FilterCase {
      ENTER_FRAME(1),
      CSS_SELECTOR(2),
      INNER_TEXT(3),
      VALUE(4),
      PSEUDO_TYPE(5),
      BOUNDING_BOX(6),
      NTH_MATCH(7),
      PSEUDO_ELEMENT_CONTENT(8),
      LABELLED(9),
      CLOSEST(10),
      MATCH_CSS_SELECTOR(11),
      CSS_STYLE(12),
      ON_TOP(13),
      FILTER_NOT_SET(0);
      private final int value;
      private FilterCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FilterCase valueOf(int value) {
        return forNumber(value);
      }

      public static FilterCase forNumber(int value) {
        switch (value) {
          case 1: return ENTER_FRAME;
          case 2: return CSS_SELECTOR;
          case 3: return INNER_TEXT;
          case 4: return VALUE;
          case 5: return PSEUDO_TYPE;
          case 6: return BOUNDING_BOX;
          case 7: return NTH_MATCH;
          case 8: return PSEUDO_ELEMENT_CONTENT;
          case 9: return LABELLED;
          case 10: return CLOSEST;
          case 11: return MATCH_CSS_SELECTOR;
          case 12: return CSS_STYLE;
          case 13: return ON_TOP;
          case 0: return FILTER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public FilterCase
    getFilterCase() {
      return FilterCase.forNumber(
          filterCase_);
    }

    private void clearFilter() {
      filterCase_ = 0;
      filter_ = null;
    }

    public static final int ENTER_FRAME_FIELD_NUMBER = 1;
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    @java.lang.Override
    public boolean hasEnterFrame() {
      return filterCase_ == 1;
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getEnterFrame() {
      if (filterCase_ == 1) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    private void setEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 1;
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    private void mergeEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  if (filterCase_ == 1 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 1;
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    private void clearEnterFrame() {
      if (filterCase_ == 1) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int CSS_SELECTOR_FIELD_NUMBER = 2;
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return Whether the cssSelector field is set.
     */
    @java.lang.Override
    public boolean hasCssSelector() {
      return filterCase_ == 2;
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The cssSelector.
     */
    @java.lang.Override
    public java.lang.String getCssSelector() {
      java.lang.String ref = "";
      if (filterCase_ == 2) {
        ref = (java.lang.String) filter_;
      }
      return ref;
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The bytes for cssSelector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCssSelectorBytes() {
      java.lang.String ref = "";
      if (filterCase_ == 2) {
        ref = (java.lang.String) filter_;
      }
      return com.google.protobuf.ByteString.copyFromUtf8(ref);
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @param value The cssSelector to set.
     */
    private void setCssSelector(
        java.lang.String value) {
      value.getClass();
  filterCase_ = 2;
      filter_ = value;
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     */
    private void clearCssSelector() {
      if (filterCase_ == 2) {
        filterCase_ = 0;
        filter_ = null;
      }
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @param value The bytes for cssSelector to set.
     */
    private void setCssSelectorBytes(
        com.google.protobuf.ByteString value) {
      filter_ = value.toStringUtf8();
      filterCase_ = 2;
    }

    public static final int INNER_TEXT_FIELD_NUMBER = 3;
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     */
    @java.lang.Override
    public boolean hasInnerText() {
      return filterCase_ == 3;
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getInnerText() {
      if (filterCase_ == 3) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     */
    private void setInnerText(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 3;
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     */
    private void mergeInnerText(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  if (filterCase_ == 3 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 3;
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
     */
    private void clearInnerText() {
      if (filterCase_ == 3) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 4;
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     */
    @java.lang.Override
    public boolean hasValue() {
      return filterCase_ == 4;
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getValue() {
      if (filterCase_ == 4) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     */
    private void setValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 4;
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     */
    private void mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  if (filterCase_ == 4 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 4;
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
     */
    private void clearValue() {
      if (filterCase_ == 4) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int PSEUDO_TYPE_FIELD_NUMBER = 5;
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return Whether the pseudoType field is set.
     */
    @java.lang.Override
    public boolean hasPseudoType() {
      return filterCase_ == 5;
    }
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return The pseudoType.
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
      if (filterCase_ == 5) {
        org.chromium.chrome.browser.autofill_assistant.proto.PseudoType result = org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.forNumber((java.lang.Integer) filter_);
        return result == null ? org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.UNDEFINED : result;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.UNDEFINED;
    }
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @param value The pseudoType to set.
     */
    private void setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
      filter_ = value.getNumber();
      filterCase_ = 5;
    }
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     */
    private void clearPseudoType() {
      if (filterCase_ == 5) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int BOUNDING_BOX_FIELD_NUMBER = 6;
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    @java.lang.Override
    public boolean hasBoundingBox() {
      return filterCase_ == 6;
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getBoundingBox() {
      if (filterCase_ == 6) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    private void setBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 6;
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    private void mergeBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
      value.getClass();
  if (filterCase_ == 6 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 6;
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    private void clearBoundingBox() {
      if (filterCase_ == 6) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int NTH_MATCH_FIELD_NUMBER = 7;
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    @java.lang.Override
    public boolean hasNthMatch() {
      return filterCase_ == 7;
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getNthMatch() {
      if (filterCase_ == 7) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    private void setNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 7;
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    private void mergeNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
      value.getClass();
  if (filterCase_ == 7 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 7;
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    private void clearNthMatch() {
      if (filterCase_ == 7) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int PSEUDO_ELEMENT_CONTENT_FIELD_NUMBER = 8;
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    @java.lang.Override
    public boolean hasPseudoElementContent() {
      return filterCase_ == 8;
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getPseudoElementContent() {
      if (filterCase_ == 8) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.getDefaultInstance();
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    private void setPseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 8;
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    private void mergePseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
      value.getClass();
  if (filterCase_ == 8 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 8;
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    private void clearPseudoElementContent() {
      if (filterCase_ == 8) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int LABELLED_FIELD_NUMBER = 9;
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    @java.lang.Override
    public boolean hasLabelled() {
      return filterCase_ == 9;
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getLabelled() {
      if (filterCase_ == 9) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    private void setLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 9;
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    private void mergeLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  if (filterCase_ == 9 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 9;
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    private void clearLabelled() {
      if (filterCase_ == 9) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int CLOSEST_FIELD_NUMBER = 10;
    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     */
    @java.lang.Override
    public boolean hasClosest() {
      return filterCase_ == 10;
    }
    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter getClosest() {
      if (filterCase_ == 10) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     */
    private void setClosest(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 10;
    }
    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     */
    private void mergeClosest(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter value) {
      value.getClass();
  if (filterCase_ == 10 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 10;
    }
    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given
     * target element.
     * The distance between two elements is the shortest euclidean distance
     * between their borders. The distance between two overlapping elements is
     * always 0. If there are multiple elements at exactly the same distance,
     * an arbitrary one is returned.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
     */
    private void clearClosest() {
      if (filterCase_ == 10) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int MATCH_CSS_SELECTOR_FIELD_NUMBER = 11;
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return Whether the matchCssSelector field is set.
     */
    @java.lang.Override
    public boolean hasMatchCssSelector() {
      return filterCase_ == 11;
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The matchCssSelector.
     */
    @java.lang.Override
    public java.lang.String getMatchCssSelector() {
      java.lang.String ref = "";
      if (filterCase_ == 11) {
        ref = (java.lang.String) filter_;
      }
      return ref;
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The bytes for matchCssSelector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMatchCssSelectorBytes() {
      java.lang.String ref = "";
      if (filterCase_ == 11) {
        ref = (java.lang.String) filter_;
      }
      return com.google.protobuf.ByteString.copyFromUtf8(ref);
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @param value The matchCssSelector to set.
     */
    private void setMatchCssSelector(
        java.lang.String value) {
      value.getClass();
  filterCase_ = 11;
      filter_ = value;
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     */
    private void clearMatchCssSelector() {
      if (filterCase_ == 11) {
        filterCase_ = 0;
        filter_ = null;
      }
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @param value The bytes for matchCssSelector to set.
     */
    private void setMatchCssSelectorBytes(
        com.google.protobuf.ByteString value) {
      filter_ = value.toStringUtf8();
      filterCase_ = 11;
    }

    public static final int CSS_STYLE_FIELD_NUMBER = 12;
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    @java.lang.Override
    public boolean hasCssStyle() {
      return filterCase_ == 12;
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getCssStyle() {
      if (filterCase_ == 12) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    private void setCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 12;
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    private void mergeCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
      value.getClass();
  if (filterCase_ == 12 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 12;
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    private void clearCssStyle() {
      if (filterCase_ == 12) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int ON_TOP_FIELD_NUMBER = 13;
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    @java.lang.Override
    public boolean hasOnTop() {
      return filterCase_ == 13;
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getOnTop() {
      if (filterCase_ == 13) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    private void setOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 13;
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    private void mergeOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
      value.getClass();
  if (filterCase_ == 13 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 13;
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    private void clearOnTop() {
      if (filterCase_ == 13) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A filter that starts with one or more elements and returns one on more
     * elements. Filters are meant to be applied sequentially.
     * The returned elements will be sorted by their order in the document.
     * Elements that were matched via the labelled filter will have the same order
     * as their label.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.Filter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.Filter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public FilterCase
          getFilterCase() {
        return instance.getFilterCase();
      }

      public Builder clearFilter() {
        copyOnWrite();
        instance.clearFilter();
        return this;
      }


      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      @java.lang.Override
      public boolean hasEnterFrame() {
        return instance.hasEnterFrame();
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getEnterFrame() {
        return instance.getEnterFrame();
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder setEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.setEnterFrame(value);
        return this;
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder setEnterFrame(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setEnterFrame(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder mergeEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.mergeEnterFrame(value);
        return this;
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder clearEnterFrame() {
        copyOnWrite();
        instance.clearEnterFrame();
        return this;
      }

      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return Whether the cssSelector field is set.
       */
      @java.lang.Override
      public boolean hasCssSelector() {
        return instance.hasCssSelector();
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return The cssSelector.
       */
      @java.lang.Override
      public java.lang.String getCssSelector() {
        return instance.getCssSelector();
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return The bytes for cssSelector.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCssSelectorBytes() {
        return instance.getCssSelectorBytes();
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @param value The cssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setCssSelector(
          java.lang.String value) {
        copyOnWrite();
        instance.setCssSelector(value);
        return this;
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCssSelector() {
        copyOnWrite();
        instance.clearCssSelector();
        return this;
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @param value The bytes for cssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setCssSelectorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCssSelectorBytes(value);
        return this;
      }

      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
       */
      @java.lang.Override
      public boolean hasInnerText() {
        return instance.hasInnerText();
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getInnerText() {
        return instance.getInnerText();
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
       */
      public Builder setInnerText(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.setInnerText(value);
        return this;
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
       */
      public Builder setInnerText(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setInnerText(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
       */
      public Builder mergeInnerText(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.mergeInnerText(value);
        return this;
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter inner_text = 3;</code>
       */
      public Builder clearInnerText() {
        copyOnWrite();
        instance.clearInnerText();
        return this;
      }

      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
       */
      public Builder setValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
       */
      public Builder setValue(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setValue(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
       */
      public Builder mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.mergeValue(value);
        return this;
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.TextFilter value = 4;</code>
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @return Whether the pseudoType field is set.
       */
      @java.lang.Override
      public boolean hasPseudoType() {
        return instance.hasPseudoType();
      }
      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @return The pseudoType.
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
        return instance.getPseudoType();
      }
      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @param value The pseudoType to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
        copyOnWrite();
        instance.setPseudoType(value);
        return this;
      }
      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPseudoType() {
        copyOnWrite();
        instance.clearPseudoType();
        return this;
      }

      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      @java.lang.Override
      public boolean hasBoundingBox() {
        return instance.hasBoundingBox();
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getBoundingBox() {
        return instance.getBoundingBox();
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder setBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
        copyOnWrite();
        instance.setBoundingBox(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder setBoundingBox(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setBoundingBox(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder mergeBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
        copyOnWrite();
        instance.mergeBoundingBox(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder clearBoundingBox() {
        copyOnWrite();
        instance.clearBoundingBox();
        return this;
      }

      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      @java.lang.Override
      public boolean hasNthMatch() {
        return instance.hasNthMatch();
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getNthMatch() {
        return instance.getNthMatch();
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder setNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
        copyOnWrite();
        instance.setNthMatch(value);
        return this;
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder setNthMatch(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setNthMatch(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder mergeNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
        copyOnWrite();
        instance.mergeNthMatch(value);
        return this;
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder clearNthMatch() {
        copyOnWrite();
        instance.clearNthMatch();
        return this;
      }

      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      @java.lang.Override
      public boolean hasPseudoElementContent() {
        return instance.hasPseudoElementContent();
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getPseudoElementContent() {
        return instance.getPseudoElementContent();
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder setPseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
        copyOnWrite();
        instance.setPseudoElementContent(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder setPseudoElementContent(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.Builder builderForValue) {
        copyOnWrite();
        instance.setPseudoElementContent(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder mergePseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
        copyOnWrite();
        instance.mergePseudoElementContent(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder clearPseudoElementContent() {
        copyOnWrite();
        instance.clearPseudoElementContent();
        return this;
      }

      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      @java.lang.Override
      public boolean hasLabelled() {
        return instance.hasLabelled();
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getLabelled() {
        return instance.getLabelled();
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder setLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.setLabelled(value);
        return this;
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder setLabelled(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setLabelled(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder mergeLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.mergeLabelled(value);
        return this;
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder clearLabelled() {
        copyOnWrite();
        instance.clearLabelled();
        return this;
      }

      /**
       * <pre>
       * Filter elements by their position on the page, relative to a given
       * target element.
       * The distance between two elements is the shortest euclidean distance
       * between their borders. The distance between two overlapping elements is
       * always 0. If there are multiple elements at exactly the same distance,
       * an arbitrary one is returned.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
       */
      @java.lang.Override
      public boolean hasClosest() {
        return instance.hasClosest();
      }
      /**
       * <pre>
       * Filter elements by their position on the page, relative to a given
       * target element.
       * The distance between two elements is the shortest euclidean distance
       * between their borders. The distance between two overlapping elements is
       * always 0. If there are multiple elements at exactly the same distance,
       * an arbitrary one is returned.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter getClosest() {
        return instance.getClosest();
      }
      /**
       * <pre>
       * Filter elements by their position on the page, relative to a given
       * target element.
       * The distance between two elements is the shortest euclidean distance
       * between their borders. The distance between two overlapping elements is
       * always 0. If there are multiple elements at exactly the same distance,
       * an arbitrary one is returned.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
       */
      public Builder setClosest(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter value) {
        copyOnWrite();
        instance.setClosest(value);
        return this;
      }
      /**
       * <pre>
       * Filter elements by their position on the page, relative to a given
       * target element.
       * The distance between two elements is the shortest euclidean distance
       * between their borders. The distance between two overlapping elements is
       * always 0. If there are multiple elements at exactly the same distance,
       * an arbitrary one is returned.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
       */
      public Builder setClosest(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setClosest(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Filter elements by their position on the page, relative to a given
       * target element.
       * The distance between two elements is the shortest euclidean distance
       * between their borders. The distance between two overlapping elements is
       * always 0. If there are multiple elements at exactly the same distance,
       * an arbitrary one is returned.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
       */
      public Builder mergeClosest(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter value) {
        copyOnWrite();
        instance.mergeClosest(value);
        return this;
      }
      /**
       * <pre>
       * Filter elements by their position on the page, relative to a given
       * target element.
       * The distance between two elements is the shortest euclidean distance
       * between their borders. The distance between two overlapping elements is
       * always 0. If there are multiple elements at exactly the same distance,
       * an arbitrary one is returned.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.ProximityFilter closest = 10;</code>
       */
      public Builder clearClosest() {
        copyOnWrite();
        instance.clearClosest();
        return this;
      }

      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return Whether the matchCssSelector field is set.
       */
      @java.lang.Override
      public boolean hasMatchCssSelector() {
        return instance.hasMatchCssSelector();
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return The matchCssSelector.
       */
      @java.lang.Override
      public java.lang.String getMatchCssSelector() {
        return instance.getMatchCssSelector();
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return The bytes for matchCssSelector.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMatchCssSelectorBytes() {
        return instance.getMatchCssSelectorBytes();
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @param value The matchCssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setMatchCssSelector(
          java.lang.String value) {
        copyOnWrite();
        instance.setMatchCssSelector(value);
        return this;
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearMatchCssSelector() {
        copyOnWrite();
        instance.clearMatchCssSelector();
        return this;
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @param value The bytes for matchCssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setMatchCssSelectorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMatchCssSelectorBytes(value);
        return this;
      }

      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      @java.lang.Override
      public boolean hasCssStyle() {
        return instance.hasCssStyle();
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getCssStyle() {
        return instance.getCssStyle();
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder setCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
        copyOnWrite();
        instance.setCssStyle(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder setCssStyle(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setCssStyle(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder mergeCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
        copyOnWrite();
        instance.mergeCssStyle(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder clearCssStyle() {
        copyOnWrite();
        instance.clearCssStyle();
        return this;
      }

      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      @java.lang.Override
      public boolean hasOnTop() {
        return instance.hasOnTop();
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getOnTop() {
        return instance.getOnTop();
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder setOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
        copyOnWrite();
        instance.setOnTop(value);
        return this;
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder setOnTop(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setOnTop(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder mergeOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
        copyOnWrite();
        instance.mergeOnTop(value);
        return this;
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder clearOnTop() {
        copyOnWrite();
        instance.clearOnTop();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.Filter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "filter_",
              "filterCase_",
              "bitField0_",
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.internalGetVerifier(),
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.class,
            };
            java.lang.String info =
                "\u0001\r\u0001\u0001\u0001\r\r\u0000\u0000\u0000\u0001\u103c\u0000\u0002\u103b\u0000" +
                "\u0003\u103c\u0000\u0004\u103c\u0000\u0005\u103f\u0000\u0006\u103c\u0000\u0007\u103c" +
                "\u0000\b\u103c\u0000\t\u103c\u0000\n\u103c\u0000\u000b\u103b\u0000\f\u103c\u0000" +
                "\r\u103c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.Filter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter DEFAULT_INSTANCE;
    static {
      Filter defaultInstance = new Filter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Filter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Filter> PARSER;

    public static com.google.protobuf.Parser<Filter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TextFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.TextFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @return Whether the re2 field is set.
     */
    boolean hasRe2();
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @return The re2.
     */
    java.lang.String getRe2();
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @return The bytes for re2.
     */
    com.google.protobuf.ByteString
        getRe2Bytes();

    /**
     * <pre>
     * If true, the regular expression is case-sensitive.
     * </pre>
     *
     * <code>optional bool case_sensitive = 2;</code>
     * @return Whether the caseSensitive field is set.
     */
    boolean hasCaseSensitive();
    /**
     * <pre>
     * If true, the regular expression is case-sensitive.
     * </pre>
     *
     * <code>optional bool case_sensitive = 2;</code>
     * @return The caseSensitive.
     */
    boolean getCaseSensitive();
  }
  /**
   * <pre>
   * A way of filtering elements by their text.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.TextFilter}
   */
  public  static final class TextFilter extends
      com.google.protobuf.GeneratedMessageLite<
          TextFilter, TextFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.TextFilter)
      TextFilterOrBuilder {
    private TextFilter() {
      re2_ = "";
    }
    private int bitField0_;
    public static final int RE2_FIELD_NUMBER = 1;
    private java.lang.String re2_;
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @return Whether the re2 field is set.
     */
    @java.lang.Override
    public boolean hasRe2() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @return The re2.
     */
    @java.lang.Override
    public java.lang.String getRe2() {
      return re2_;
    }
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @return The bytes for re2.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRe2Bytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(re2_);
    }
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @param value The re2 to set.
     */
    private void setRe2(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      re2_ = value;
    }
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     */
    private void clearRe2() {
      bitField0_ = (bitField0_ & ~0x00000001);
      re2_ = getDefaultInstance().getRe2();
    }
    /**
     * <pre>
     * Javascript RE2 regular expression to apply to the text. This is evaluated
     * with Regexp.test, so it's a "find" and will be satisfied whenever the
     * text contains at least one substring that matches the given regular
     * expression.
     * </pre>
     *
     * <code>optional string re2 = 1;</code>
     * @param value The bytes for re2 to set.
     */
    private void setRe2Bytes(
        com.google.protobuf.ByteString value) {
      re2_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int CASE_SENSITIVE_FIELD_NUMBER = 2;
    private boolean caseSensitive_;
    /**
     * <pre>
     * If true, the regular expression is case-sensitive.
     * </pre>
     *
     * <code>optional bool case_sensitive = 2;</code>
     * @return Whether the caseSensitive field is set.
     */
    @java.lang.Override
    public boolean hasCaseSensitive() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If true, the regular expression is case-sensitive.
     * </pre>
     *
     * <code>optional bool case_sensitive = 2;</code>
     * @return The caseSensitive.
     */
    @java.lang.Override
    public boolean getCaseSensitive() {
      return caseSensitive_;
    }
    /**
     * <pre>
     * If true, the regular expression is case-sensitive.
     * </pre>
     *
     * <code>optional bool case_sensitive = 2;</code>
     * @param value The caseSensitive to set.
     */
    private void setCaseSensitive(boolean value) {
      bitField0_ |= 0x00000002;
      caseSensitive_ = value;
    }
    /**
     * <pre>
     * If true, the regular expression is case-sensitive.
     * </pre>
     *
     * <code>optional bool case_sensitive = 2;</code>
     */
    private void clearCaseSensitive() {
      bitField0_ = (bitField0_ & ~0x00000002);
      caseSensitive_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A way of filtering elements by their text.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.TextFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.TextFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Javascript RE2 regular expression to apply to the text. This is evaluated
       * with Regexp.test, so it's a "find" and will be satisfied whenever the
       * text contains at least one substring that matches the given regular
       * expression.
       * </pre>
       *
       * <code>optional string re2 = 1;</code>
       * @return Whether the re2 field is set.
       */
      @java.lang.Override
      public boolean hasRe2() {
        return instance.hasRe2();
      }
      /**
       * <pre>
       * Javascript RE2 regular expression to apply to the text. This is evaluated
       * with Regexp.test, so it's a "find" and will be satisfied whenever the
       * text contains at least one substring that matches the given regular
       * expression.
       * </pre>
       *
       * <code>optional string re2 = 1;</code>
       * @return The re2.
       */
      @java.lang.Override
      public java.lang.String getRe2() {
        return instance.getRe2();
      }
      /**
       * <pre>
       * Javascript RE2 regular expression to apply to the text. This is evaluated
       * with Regexp.test, so it's a "find" and will be satisfied whenever the
       * text contains at least one substring that matches the given regular
       * expression.
       * </pre>
       *
       * <code>optional string re2 = 1;</code>
       * @return The bytes for re2.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRe2Bytes() {
        return instance.getRe2Bytes();
      }
      /**
       * <pre>
       * Javascript RE2 regular expression to apply to the text. This is evaluated
       * with Regexp.test, so it's a "find" and will be satisfied whenever the
       * text contains at least one substring that matches the given regular
       * expression.
       * </pre>
       *
       * <code>optional string re2 = 1;</code>
       * @param value The re2 to set.
       * @return This builder for chaining.
       */
      public Builder setRe2(
          java.lang.String value) {
        copyOnWrite();
        instance.setRe2(value);
        return this;
      }
      /**
       * <pre>
       * Javascript RE2 regular expression to apply to the text. This is evaluated
       * with Regexp.test, so it's a "find" and will be satisfied whenever the
       * text contains at least one substring that matches the given regular
       * expression.
       * </pre>
       *
       * <code>optional string re2 = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRe2() {
        copyOnWrite();
        instance.clearRe2();
        return this;
      }
      /**
       * <pre>
       * Javascript RE2 regular expression to apply to the text. This is evaluated
       * with Regexp.test, so it's a "find" and will be satisfied whenever the
       * text contains at least one substring that matches the given regular
       * expression.
       * </pre>
       *
       * <code>optional string re2 = 1;</code>
       * @param value The bytes for re2 to set.
       * @return This builder for chaining.
       */
      public Builder setRe2Bytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRe2Bytes(value);
        return this;
      }

      /**
       * <pre>
       * If true, the regular expression is case-sensitive.
       * </pre>
       *
       * <code>optional bool case_sensitive = 2;</code>
       * @return Whether the caseSensitive field is set.
       */
      @java.lang.Override
      public boolean hasCaseSensitive() {
        return instance.hasCaseSensitive();
      }
      /**
       * <pre>
       * If true, the regular expression is case-sensitive.
       * </pre>
       *
       * <code>optional bool case_sensitive = 2;</code>
       * @return The caseSensitive.
       */
      @java.lang.Override
      public boolean getCaseSensitive() {
        return instance.getCaseSensitive();
      }
      /**
       * <pre>
       * If true, the regular expression is case-sensitive.
       * </pre>
       *
       * <code>optional bool case_sensitive = 2;</code>
       * @param value The caseSensitive to set.
       * @return This builder for chaining.
       */
      public Builder setCaseSensitive(boolean value) {
        copyOnWrite();
        instance.setCaseSensitive(value);
        return this;
      }
      /**
       * <pre>
       * If true, the regular expression is case-sensitive.
       * </pre>
       *
       * <code>optional bool case_sensitive = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCaseSensitive() {
        copyOnWrite();
        instance.clearCaseSensitive();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.TextFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "re2_",
              "caseSensitive_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u1007\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.TextFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter DEFAULT_INSTANCE;
    static {
      TextFilter defaultInstance = new TextFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TextFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TextFilter> PARSER;

    public static com.google.protobuf.Parser<TextFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PseudoElementContentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.PseudoElementContent)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return Whether the pseudoType field is set.
     */
    boolean hasPseudoType();
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return The pseudoType.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType();

    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     * @return Whether the content field is set.
     */
    boolean hasContent();
    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     * @return The content.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getContent();
  }
  /**
   * <pre>
   * A way of filtering elements by their pseudo-element content.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.PseudoElementContent}
   */
  public  static final class PseudoElementContent extends
      com.google.protobuf.GeneratedMessageLite<
          PseudoElementContent, PseudoElementContent.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.PseudoElementContent)
      PseudoElementContentOrBuilder {
    private PseudoElementContent() {
    }
    private int bitField0_;
    public static final int PSEUDO_TYPE_FIELD_NUMBER = 1;
    private int pseudoType_;
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return Whether the pseudoType field is set.
     */
    @java.lang.Override
    public boolean hasPseudoType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return The pseudoType.
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
      org.chromium.chrome.browser.autofill_assistant.proto.PseudoType result = org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.forNumber(pseudoType_);
      return result == null ? org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.UNDEFINED : result;
    }
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @param value The pseudoType to set.
     */
    private void setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
      pseudoType_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     */
    private void clearPseudoType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      pseudoType_ = 0;
    }

    public static final int CONTENT_FIELD_NUMBER = 2;
    private org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter content_;
    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     */
    @java.lang.Override
    public boolean hasContent() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getContent() {
      return content_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance() : content_;
    }
    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     */
    private void setContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  content_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  if (content_ != null &&
          content_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance()) {
        content_ =
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.newBuilder(content_).mergeFrom(value).buildPartial();
      } else {
        content_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
     */
    private void clearContent() {  content_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A way of filtering elements by their pseudo-element content.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.PseudoElementContent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.PseudoElementContent)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContentOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @return Whether the pseudoType field is set.
       */
      @java.lang.Override
      public boolean hasPseudoType() {
        return instance.hasPseudoType();
      }
      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @return The pseudoType.
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
        return instance.getPseudoType();
      }
      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @param value The enum numeric value on the wire for pseudoType to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
        copyOnWrite();
        instance.setPseudoType(value);
        return this;
      }
      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPseudoType() {
        copyOnWrite();
        instance.clearPseudoType();
        return this;
      }

      /**
       * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
       */
      @java.lang.Override
      public boolean hasContent() {
        return instance.hasContent();
      }
      /**
       * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getContent() {
        return instance.getContent();
      }
      /**
       * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
       */
      public Builder setContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.setContent(value);
        return this;
        }
      /**
       * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
       */
      public Builder setContent(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setContent(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
       */
      public Builder mergeContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.mergeContent(value);
        return this;
      }
      /**
       * <code>optional .autofill_assistant.SelectorProto.TextFilter content = 2;</code>
       */
      public Builder clearContent() {  copyOnWrite();
        instance.clearContent();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.PseudoElementContent)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "pseudoType_",
              org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.internalGetVerifier(),
              "content_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u100c\u0000\u0002" +
                "\u1009\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.PseudoElementContent)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent DEFAULT_INSTANCE;
    static {
      PseudoElementContent defaultInstance = new PseudoElementContent();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PseudoElementContent.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PseudoElementContent> PARSER;

    public static com.google.protobuf.Parser<PseudoElementContent> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CssStyleFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.CssStyleFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return Whether the property field is set.
     */
    boolean hasProperty();
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The property.
     */
    java.lang.String getProperty();
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The bytes for property.
     */
    com.google.protobuf.ByteString
        getPropertyBytes();

    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return Whether the pseudoElement field is set.
     */
    boolean hasPseudoElement();
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The pseudoElement.
     */
    java.lang.String getPseudoElement();
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The bytes for pseudoElement.
     */
    com.google.protobuf.ByteString
        getPseudoElementBytes();

    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return Whether the shouldMatch field is set.
     */
    boolean hasShouldMatch();
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return The shouldMatch.
     */
    boolean getShouldMatch();

    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     * @return The value.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getValue();
  }
  /**
   * <pre>
   * Only keep elements whose computed style match the given filter. This is
   * based on Window.computedStyle()
   * See
   * https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.CssStyleFilter}
   */
  public  static final class CssStyleFilter extends
      com.google.protobuf.GeneratedMessageLite<
          CssStyleFilter, CssStyleFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.CssStyleFilter)
      CssStyleFilterOrBuilder {
    private CssStyleFilter() {
      property_ = "";
      pseudoElement_ = "";
      shouldMatch_ = true;
    }
    private int bitField0_;
    public static final int PROPERTY_FIELD_NUMBER = 3;
    private java.lang.String property_;
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return Whether the property field is set.
     */
    @java.lang.Override
    public boolean hasProperty() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The property.
     */
    @java.lang.Override
    public java.lang.String getProperty() {
      return property_;
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The bytes for property.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPropertyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(property_);
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @param value The property to set.
     */
    private void setProperty(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      property_ = value;
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     */
    private void clearProperty() {
      bitField0_ = (bitField0_ & ~0x00000001);
      property_ = getDefaultInstance().getProperty();
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @param value The bytes for property to set.
     */
    private void setPropertyBytes(
        com.google.protobuf.ByteString value) {
      property_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int PSEUDO_ELEMENT_FIELD_NUMBER = 4;
    private java.lang.String pseudoElement_;
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return Whether the pseudoElement field is set.
     */
    @java.lang.Override
    public boolean hasPseudoElement() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The pseudoElement.
     */
    @java.lang.Override
    public java.lang.String getPseudoElement() {
      return pseudoElement_;
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The bytes for pseudoElement.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPseudoElementBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pseudoElement_);
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @param value The pseudoElement to set.
     */
    private void setPseudoElement(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000002;
      pseudoElement_ = value;
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     */
    private void clearPseudoElement() {
      bitField0_ = (bitField0_ & ~0x00000002);
      pseudoElement_ = getDefaultInstance().getPseudoElement();
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @param value The bytes for pseudoElement to set.
     */
    private void setPseudoElementBytes(
        com.google.protobuf.ByteString value) {
      pseudoElement_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int SHOULD_MATCH_FIELD_NUMBER = 5;
    private boolean shouldMatch_;
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return Whether the shouldMatch field is set.
     */
    @java.lang.Override
    public boolean hasShouldMatch() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return The shouldMatch.
     */
    @java.lang.Override
    public boolean getShouldMatch() {
      return shouldMatch_;
    }
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @param value The shouldMatch to set.
     */
    private void setShouldMatch(boolean value) {
      bitField0_ |= 0x00000004;
      shouldMatch_ = value;
    }
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     */
    private void clearShouldMatch() {
      bitField0_ = (bitField0_ & ~0x00000004);
      shouldMatch_ = true;
    }

    public static final int VALUE_FIELD_NUMBER = 6;
    private org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value_;
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getValue() {
      return value_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance() : value_;
    }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     */
    private void setValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  value_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
      value.getClass();
  if (value_ != null &&
          value_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.getDefaultInstance()) {
        value_ =
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.newBuilder(value_).mergeFrom(value).buildPartial();
      } else {
        value_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
     */
    private void clearValue() {  value_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * See
     * https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.CssStyleFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.CssStyleFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return Whether the property field is set.
       */
      @java.lang.Override
      public boolean hasProperty() {
        return instance.hasProperty();
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return The property.
       */
      @java.lang.Override
      public java.lang.String getProperty() {
        return instance.getProperty();
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return The bytes for property.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPropertyBytes() {
        return instance.getPropertyBytes();
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @param value The property to set.
       * @return This builder for chaining.
       */
      public Builder setProperty(
          java.lang.String value) {
        copyOnWrite();
        instance.setProperty(value);
        return this;
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearProperty() {
        copyOnWrite();
        instance.clearProperty();
        return this;
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @param value The bytes for property to set.
       * @return This builder for chaining.
       */
      public Builder setPropertyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPropertyBytes(value);
        return this;
      }

      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return Whether the pseudoElement field is set.
       */
      @java.lang.Override
      public boolean hasPseudoElement() {
        return instance.hasPseudoElement();
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return The pseudoElement.
       */
      @java.lang.Override
      public java.lang.String getPseudoElement() {
        return instance.getPseudoElement();
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return The bytes for pseudoElement.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPseudoElementBytes() {
        return instance.getPseudoElementBytes();
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @param value The pseudoElement to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoElement(
          java.lang.String value) {
        copyOnWrite();
        instance.setPseudoElement(value);
        return this;
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPseudoElement() {
        copyOnWrite();
        instance.clearPseudoElement();
        return this;
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @param value The bytes for pseudoElement to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoElementBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPseudoElementBytes(value);
        return this;
      }

      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @return Whether the shouldMatch field is set.
       */
      @java.lang.Override
      public boolean hasShouldMatch() {
        return instance.hasShouldMatch();
      }
      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @return The shouldMatch.
       */
      @java.lang.Override
      public boolean getShouldMatch() {
        return instance.getShouldMatch();
      }
      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @param value The shouldMatch to set.
       * @return This builder for chaining.
       */
      public Builder setShouldMatch(boolean value) {
        copyOnWrite();
        instance.setShouldMatch(value);
        return this;
      }
      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearShouldMatch() {
        copyOnWrite();
        instance.clearShouldMatch();
        return this;
      }

      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
       */
      public Builder setValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
        }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
       */
      public Builder setValue(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setValue(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
       */
      public Builder mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.TextFilter value) {
        copyOnWrite();
        instance.mergeValue(value);
        return this;
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.TextFilter value = 6;</code>
       */
      public Builder clearValue() {  copyOnWrite();
        instance.clearValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.CssStyleFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "property_",
              "pseudoElement_",
              "shouldMatch_",
              "value_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0003\u0006\u0004\u0000\u0000\u0000\u0003\u1008\u0000\u0004" +
                "\u1008\u0001\u0005\u1007\u0002\u0006\u1009\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.CssStyleFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter DEFAULT_INSTANCE;
    static {
      CssStyleFilter defaultInstance = new CssStyleFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CssStyleFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CssStyleFilter> PARSER;

    public static com.google.protobuf.Parser<CssStyleFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ProximityFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.ProximityFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> 
        getTargetList();
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getTarget(int index);
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    int getTargetCount();

    /**
     * <pre>
     * If true, the element and targets must be aligned either
     * horizontally or vertically.
     * This is usually what we want, as elements close, but in diagonal position
     * relative to each other are usually not considered part of the same group.
     * </pre>
     *
     * <code>optional bool in_alignment = 3;</code>
     * @return Whether the inAlignment field is set.
     */
    boolean hasInAlignment();
    /**
     * <pre>
     * If true, the element and targets must be aligned either
     * horizontally or vertically.
     * This is usually what we want, as elements close, but in diagonal position
     * relative to each other are usually not considered part of the same group.
     * </pre>
     *
     * <code>optional bool in_alignment = 3;</code>
     * @return The inAlignment.
     */
    boolean getInAlignment();

    /**
     * <pre>
     * Require the target and element to have a specific relative position.
     * If unspecified, the target and element be in any position relative to
     * each other.
     * If necessary, this can be combined with in_alignment, so in_aligment=true
     * relative_position=LEFT requires the element to be strictly to the left or
     * target.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
     * @return Whether the relativePosition field is set.
     */
    boolean hasRelativePosition();
    /**
     * <pre>
     * Require the target and element to have a specific relative position.
     * If unspecified, the target and element be in any position relative to
     * each other.
     * If necessary, this can be combined with in_alignment, so in_aligment=true
     * relative_position=LEFT requires the element to be strictly to the left or
     * target.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
     * @return The relativePosition.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition getRelativePosition();

    /**
     * <pre>
     * Maximum number of pairs the client is allowed to compare.
     * If there are too many pairs to compare, the client bails out and returns
     * the status TOO_MANY_CANDIDATES to the server.
     * The maximum number of pairs is limited, to avoid clients being slowed
     * down by overly expensive selectors, as the current algorithm is not
     * optimized for large number of pairs. Authors of selectors must take care
     * to keep the number of pairs reasonable.
     * For example, avoid looking for "a div near label X". This will be too
     * slow to process. Look instead for "a button near label X" or "a clickable
     * div near label X".
     * This setting must not be exposed to scripts. It must not be increased
     * just to allow that one slow selector. This is a value that must be
     * maintained by the team responsible for keeping clients running properly.
     * </pre>
     *
     * <code>optional int32 max_pairs = 5 [default = 50];</code>
     * @return Whether the maxPairs field is set.
     */
    boolean hasMaxPairs();
    /**
     * <pre>
     * Maximum number of pairs the client is allowed to compare.
     * If there are too many pairs to compare, the client bails out and returns
     * the status TOO_MANY_CANDIDATES to the server.
     * The maximum number of pairs is limited, to avoid clients being slowed
     * down by overly expensive selectors, as the current algorithm is not
     * optimized for large number of pairs. Authors of selectors must take care
     * to keep the number of pairs reasonable.
     * For example, avoid looking for "a div near label X". This will be too
     * slow to process. Look instead for "a button near label X" or "a clickable
     * div near label X".
     * This setting must not be exposed to scripts. It must not be increased
     * just to allow that one slow selector. This is a value that must be
     * maintained by the team responsible for keeping clients running properly.
     * </pre>
     *
     * <code>optional int32 max_pairs = 5 [default = 50];</code>
     * @return The maxPairs.
     */
    int getMaxPairs();
  }
  /**
   * <pre>
   * Filter elements by their position on the page, relative to a given target
   * element.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.ProximityFilter}
   */
  public  static final class ProximityFilter extends
      com.google.protobuf.GeneratedMessageLite<
          ProximityFilter, ProximityFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.ProximityFilter)
      ProximityFilterOrBuilder {
    private ProximityFilter() {
      target_ = emptyProtobufList();
      maxPairs_ = 50;
    }
    /**
     * Protobuf enum {@code autofill_assistant.SelectorProto.ProximityFilter.RelativePosition}
     */
    public enum RelativePosition
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Unspecified relative position.
       * </pre>
       *
       * <code>UNSPECIFIED_POSITION = 0;</code>
       */
      UNSPECIFIED_POSITION(0),
      /**
       * <pre>
       * Element is above target.
       * </pre>
       *
       * <code>ABOVE = 1;</code>
       */
      ABOVE(1),
      /**
       * <pre>
       * Element is below target.
       * </pre>
       *
       * <code>BELOW = 2;</code>
       */
      BELOW(2),
      /**
       * <pre>
       * Element is left of target.
       * </pre>
       *
       * <code>LEFT = 3;</code>
       */
      LEFT(3),
      /**
       * <pre>
       * Element is right of target.
       * </pre>
       *
       * <code>RIGHT = 4;</code>
       */
      RIGHT(4),
      ;

      /**
       * <pre>
       * Unspecified relative position.
       * </pre>
       *
       * <code>UNSPECIFIED_POSITION = 0;</code>
       */
      public static final int UNSPECIFIED_POSITION_VALUE = 0;
      /**
       * <pre>
       * Element is above target.
       * </pre>
       *
       * <code>ABOVE = 1;</code>
       */
      public static final int ABOVE_VALUE = 1;
      /**
       * <pre>
       * Element is below target.
       * </pre>
       *
       * <code>BELOW = 2;</code>
       */
      public static final int BELOW_VALUE = 2;
      /**
       * <pre>
       * Element is left of target.
       * </pre>
       *
       * <code>LEFT = 3;</code>
       */
      public static final int LEFT_VALUE = 3;
      /**
       * <pre>
       * Element is right of target.
       * </pre>
       *
       * <code>RIGHT = 4;</code>
       */
      public static final int RIGHT_VALUE = 4;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static RelativePosition valueOf(int value) {
        return forNumber(value);
      }

      public static RelativePosition forNumber(int value) {
        switch (value) {
          case 0: return UNSPECIFIED_POSITION;
          case 1: return ABOVE;
          case 2: return BELOW;
          case 3: return LEFT;
          case 4: return RIGHT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<RelativePosition>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          RelativePosition> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<RelativePosition>() {
              @java.lang.Override
              public RelativePosition findValueByNumber(int number) {
                return RelativePosition.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return RelativePositionVerifier.INSTANCE;
      }

      private static final class RelativePositionVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new RelativePositionVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return RelativePosition.forNumber(number) != null;
              }
            };

      private final int value;

      private RelativePosition(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:autofill_assistant.SelectorProto.ProximityFilter.RelativePosition)
    }

    private int bitField0_;
    public static final int TARGET_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> target_;
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> getTargetList() {
      return target_;
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    public java.util.List<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder> 
        getTargetOrBuilderList() {
      return target_;
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    @java.lang.Override
    public int getTargetCount() {
      return target_.size();
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getTarget(int index) {
      return target_.get(index);
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder getTargetOrBuilder(
        int index) {
      return target_.get(index);
    }
    private void ensureTargetIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> tmp = target_;
      if (!tmp.isModifiable()) {
        target_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    private void setTarget(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      value.getClass();
  ensureTargetIsMutable();
      target_.set(index, value);
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    private void addTarget(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      value.getClass();
  ensureTargetIsMutable();
      target_.add(value);
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    private void addTarget(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      value.getClass();
  ensureTargetIsMutable();
      target_.add(index, value);
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    private void addAllTarget(
        java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> values) {
      ensureTargetIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, target_);
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    private void clearTarget() {
      target_ = emptyProtobufList();
    }
    /**
     * <pre>
     * From the set of potential matches, choose the one closest to the given
     * target. The target filters are evaluated relative to the current frame
     * and must select an element in the current frame.
     * If there is no target the whole selector matches nothing.
     * This element cannot include enter_frame filters.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
     */
    private void removeTarget(int index) {
      ensureTargetIsMutable();
      target_.remove(index);
    }

    public static final int IN_ALIGNMENT_FIELD_NUMBER = 3;
    private boolean inAlignment_;
    /**
     * <pre>
     * If true, the element and targets must be aligned either
     * horizontally or vertically.
     * This is usually what we want, as elements close, but in diagonal position
     * relative to each other are usually not considered part of the same group.
     * </pre>
     *
     * <code>optional bool in_alignment = 3;</code>
     * @return Whether the inAlignment field is set.
     */
    @java.lang.Override
    public boolean hasInAlignment() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If true, the element and targets must be aligned either
     * horizontally or vertically.
     * This is usually what we want, as elements close, but in diagonal position
     * relative to each other are usually not considered part of the same group.
     * </pre>
     *
     * <code>optional bool in_alignment = 3;</code>
     * @return The inAlignment.
     */
    @java.lang.Override
    public boolean getInAlignment() {
      return inAlignment_;
    }
    /**
     * <pre>
     * If true, the element and targets must be aligned either
     * horizontally or vertically.
     * This is usually what we want, as elements close, but in diagonal position
     * relative to each other are usually not considered part of the same group.
     * </pre>
     *
     * <code>optional bool in_alignment = 3;</code>
     * @param value The inAlignment to set.
     */
    private void setInAlignment(boolean value) {
      bitField0_ |= 0x00000001;
      inAlignment_ = value;
    }
    /**
     * <pre>
     * If true, the element and targets must be aligned either
     * horizontally or vertically.
     * This is usually what we want, as elements close, but in diagonal position
     * relative to each other are usually not considered part of the same group.
     * </pre>
     *
     * <code>optional bool in_alignment = 3;</code>
     */
    private void clearInAlignment() {
      bitField0_ = (bitField0_ & ~0x00000001);
      inAlignment_ = false;
    }

    public static final int RELATIVE_POSITION_FIELD_NUMBER = 4;
    private int relativePosition_;
    /**
     * <pre>
     * Require the target and element to have a specific relative position.
     * If unspecified, the target and element be in any position relative to
     * each other.
     * If necessary, this can be combined with in_alignment, so in_aligment=true
     * relative_position=LEFT requires the element to be strictly to the left or
     * target.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
     * @return Whether the relativePosition field is set.
     */
    @java.lang.Override
    public boolean hasRelativePosition() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Require the target and element to have a specific relative position.
     * If unspecified, the target and element be in any position relative to
     * each other.
     * If necessary, this can be combined with in_alignment, so in_aligment=true
     * relative_position=LEFT requires the element to be strictly to the left or
     * target.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
     * @return The relativePosition.
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition getRelativePosition() {
      org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition result = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition.forNumber(relativePosition_);
      return result == null ? org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition.UNSPECIFIED_POSITION : result;
    }
    /**
     * <pre>
     * Require the target and element to have a specific relative position.
     * If unspecified, the target and element be in any position relative to
     * each other.
     * If necessary, this can be combined with in_alignment, so in_aligment=true
     * relative_position=LEFT requires the element to be strictly to the left or
     * target.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
     * @param value The relativePosition to set.
     */
    private void setRelativePosition(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition value) {
      relativePosition_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Require the target and element to have a specific relative position.
     * If unspecified, the target and element be in any position relative to
     * each other.
     * If necessary, this can be combined with in_alignment, so in_aligment=true
     * relative_position=LEFT requires the element to be strictly to the left or
     * target.
     * </pre>
     *
     * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
     */
    private void clearRelativePosition() {
      bitField0_ = (bitField0_ & ~0x00000002);
      relativePosition_ = 0;
    }

    public static final int MAX_PAIRS_FIELD_NUMBER = 5;
    private int maxPairs_;
    /**
     * <pre>
     * Maximum number of pairs the client is allowed to compare.
     * If there are too many pairs to compare, the client bails out and returns
     * the status TOO_MANY_CANDIDATES to the server.
     * The maximum number of pairs is limited, to avoid clients being slowed
     * down by overly expensive selectors, as the current algorithm is not
     * optimized for large number of pairs. Authors of selectors must take care
     * to keep the number of pairs reasonable.
     * For example, avoid looking for "a div near label X". This will be too
     * slow to process. Look instead for "a button near label X" or "a clickable
     * div near label X".
     * This setting must not be exposed to scripts. It must not be increased
     * just to allow that one slow selector. This is a value that must be
     * maintained by the team responsible for keeping clients running properly.
     * </pre>
     *
     * <code>optional int32 max_pairs = 5 [default = 50];</code>
     * @return Whether the maxPairs field is set.
     */
    @java.lang.Override
    public boolean hasMaxPairs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Maximum number of pairs the client is allowed to compare.
     * If there are too many pairs to compare, the client bails out and returns
     * the status TOO_MANY_CANDIDATES to the server.
     * The maximum number of pairs is limited, to avoid clients being slowed
     * down by overly expensive selectors, as the current algorithm is not
     * optimized for large number of pairs. Authors of selectors must take care
     * to keep the number of pairs reasonable.
     * For example, avoid looking for "a div near label X". This will be too
     * slow to process. Look instead for "a button near label X" or "a clickable
     * div near label X".
     * This setting must not be exposed to scripts. It must not be increased
     * just to allow that one slow selector. This is a value that must be
     * maintained by the team responsible for keeping clients running properly.
     * </pre>
     *
     * <code>optional int32 max_pairs = 5 [default = 50];</code>
     * @return The maxPairs.
     */
    @java.lang.Override
    public int getMaxPairs() {
      return maxPairs_;
    }
    /**
     * <pre>
     * Maximum number of pairs the client is allowed to compare.
     * If there are too many pairs to compare, the client bails out and returns
     * the status TOO_MANY_CANDIDATES to the server.
     * The maximum number of pairs is limited, to avoid clients being slowed
     * down by overly expensive selectors, as the current algorithm is not
     * optimized for large number of pairs. Authors of selectors must take care
     * to keep the number of pairs reasonable.
     * For example, avoid looking for "a div near label X". This will be too
     * slow to process. Look instead for "a button near label X" or "a clickable
     * div near label X".
     * This setting must not be exposed to scripts. It must not be increased
     * just to allow that one slow selector. This is a value that must be
     * maintained by the team responsible for keeping clients running properly.
     * </pre>
     *
     * <code>optional int32 max_pairs = 5 [default = 50];</code>
     * @param value The maxPairs to set.
     */
    private void setMaxPairs(int value) {
      bitField0_ |= 0x00000004;
      maxPairs_ = value;
    }
    /**
     * <pre>
     * Maximum number of pairs the client is allowed to compare.
     * If there are too many pairs to compare, the client bails out and returns
     * the status TOO_MANY_CANDIDATES to the server.
     * The maximum number of pairs is limited, to avoid clients being slowed
     * down by overly expensive selectors, as the current algorithm is not
     * optimized for large number of pairs. Authors of selectors must take care
     * to keep the number of pairs reasonable.
     * For example, avoid looking for "a div near label X". This will be too
     * slow to process. Look instead for "a button near label X" or "a clickable
     * div near label X".
     * This setting must not be exposed to scripts. It must not be increased
     * just to allow that one slow selector. This is a value that must be
     * maintained by the team responsible for keeping clients running properly.
     * </pre>
     *
     * <code>optional int32 max_pairs = 5 [default = 50];</code>
     */
    private void clearMaxPairs() {
      bitField0_ = (bitField0_ & ~0x00000004);
      maxPairs_ = 50;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Filter elements by their position on the page, relative to a given target
     * element.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.ProximityFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.ProximityFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> getTargetList() {
        return java.util.Collections.unmodifiableList(
            instance.getTargetList());
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      @java.lang.Override
      public int getTargetCount() {
        return instance.getTargetCount();
      }/**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getTarget(int index) {
        return instance.getTarget(index);
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder setTarget(
          int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
        copyOnWrite();
        instance.setTarget(index, value);
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder setTarget(
          int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
        copyOnWrite();
        instance.setTarget(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder addTarget(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
        copyOnWrite();
        instance.addTarget(value);
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder addTarget(
          int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
        copyOnWrite();
        instance.addTarget(index, value);
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder addTarget(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
        copyOnWrite();
        instance.addTarget(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder addTarget(
          int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
        copyOnWrite();
        instance.addTarget(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder addAllTarget(
          java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> values) {
        copyOnWrite();
        instance.addAllTarget(values);
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder clearTarget() {
        copyOnWrite();
        instance.clearTarget();
        return this;
      }
      /**
       * <pre>
       * From the set of potential matches, choose the one closest to the given
       * target. The target filters are evaluated relative to the current frame
       * and must select an element in the current frame.
       * If there is no target the whole selector matches nothing.
       * This element cannot include enter_frame filters.
       * </pre>
       *
       * <code>repeated .autofill_assistant.SelectorProto.Filter target = 1;</code>
       */
      public Builder removeTarget(int index) {
        copyOnWrite();
        instance.removeTarget(index);
        return this;
      }

      /**
       * <pre>
       * If true, the element and targets must be aligned either
       * horizontally or vertically.
       * This is usually what we want, as elements close, but in diagonal position
       * relative to each other are usually not considered part of the same group.
       * </pre>
       *
       * <code>optional bool in_alignment = 3;</code>
       * @return Whether the inAlignment field is set.
       */
      @java.lang.Override
      public boolean hasInAlignment() {
        return instance.hasInAlignment();
      }
      /**
       * <pre>
       * If true, the element and targets must be aligned either
       * horizontally or vertically.
       * This is usually what we want, as elements close, but in diagonal position
       * relative to each other are usually not considered part of the same group.
       * </pre>
       *
       * <code>optional bool in_alignment = 3;</code>
       * @return The inAlignment.
       */
      @java.lang.Override
      public boolean getInAlignment() {
        return instance.getInAlignment();
      }
      /**
       * <pre>
       * If true, the element and targets must be aligned either
       * horizontally or vertically.
       * This is usually what we want, as elements close, but in diagonal position
       * relative to each other are usually not considered part of the same group.
       * </pre>
       *
       * <code>optional bool in_alignment = 3;</code>
       * @param value The inAlignment to set.
       * @return This builder for chaining.
       */
      public Builder setInAlignment(boolean value) {
        copyOnWrite();
        instance.setInAlignment(value);
        return this;
      }
      /**
       * <pre>
       * If true, the element and targets must be aligned either
       * horizontally or vertically.
       * This is usually what we want, as elements close, but in diagonal position
       * relative to each other are usually not considered part of the same group.
       * </pre>
       *
       * <code>optional bool in_alignment = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearInAlignment() {
        copyOnWrite();
        instance.clearInAlignment();
        return this;
      }

      /**
       * <pre>
       * Require the target and element to have a specific relative position.
       * If unspecified, the target and element be in any position relative to
       * each other.
       * If necessary, this can be combined with in_alignment, so in_aligment=true
       * relative_position=LEFT requires the element to be strictly to the left or
       * target.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
       * @return Whether the relativePosition field is set.
       */
      @java.lang.Override
      public boolean hasRelativePosition() {
        return instance.hasRelativePosition();
      }
      /**
       * <pre>
       * Require the target and element to have a specific relative position.
       * If unspecified, the target and element be in any position relative to
       * each other.
       * If necessary, this can be combined with in_alignment, so in_aligment=true
       * relative_position=LEFT requires the element to be strictly to the left or
       * target.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
       * @return The relativePosition.
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition getRelativePosition() {
        return instance.getRelativePosition();
      }
      /**
       * <pre>
       * Require the target and element to have a specific relative position.
       * If unspecified, the target and element be in any position relative to
       * each other.
       * If necessary, this can be combined with in_alignment, so in_aligment=true
       * relative_position=LEFT requires the element to be strictly to the left or
       * target.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
       * @param value The enum numeric value on the wire for relativePosition to set.
       * @return This builder for chaining.
       */
      public Builder setRelativePosition(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition value) {
        copyOnWrite();
        instance.setRelativePosition(value);
        return this;
      }
      /**
       * <pre>
       * Require the target and element to have a specific relative position.
       * If unspecified, the target and element be in any position relative to
       * each other.
       * If necessary, this can be combined with in_alignment, so in_aligment=true
       * relative_position=LEFT requires the element to be strictly to the left or
       * target.
       * </pre>
       *
       * <code>optional .autofill_assistant.SelectorProto.ProximityFilter.RelativePosition relative_position = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRelativePosition() {
        copyOnWrite();
        instance.clearRelativePosition();
        return this;
      }

      /**
       * <pre>
       * Maximum number of pairs the client is allowed to compare.
       * If there are too many pairs to compare, the client bails out and returns
       * the status TOO_MANY_CANDIDATES to the server.
       * The maximum number of pairs is limited, to avoid clients being slowed
       * down by overly expensive selectors, as the current algorithm is not
       * optimized for large number of pairs. Authors of selectors must take care
       * to keep the number of pairs reasonable.
       * For example, avoid looking for "a div near label X". This will be too
       * slow to process. Look instead for "a button near label X" or "a clickable
       * div near label X".
       * This setting must not be exposed to scripts. It must not be increased
       * just to allow that one slow selector. This is a value that must be
       * maintained by the team responsible for keeping clients running properly.
       * </pre>
       *
       * <code>optional int32 max_pairs = 5 [default = 50];</code>
       * @return Whether the maxPairs field is set.
       */
      @java.lang.Override
      public boolean hasMaxPairs() {
        return instance.hasMaxPairs();
      }
      /**
       * <pre>
       * Maximum number of pairs the client is allowed to compare.
       * If there are too many pairs to compare, the client bails out and returns
       * the status TOO_MANY_CANDIDATES to the server.
       * The maximum number of pairs is limited, to avoid clients being slowed
       * down by overly expensive selectors, as the current algorithm is not
       * optimized for large number of pairs. Authors of selectors must take care
       * to keep the number of pairs reasonable.
       * For example, avoid looking for "a div near label X". This will be too
       * slow to process. Look instead for "a button near label X" or "a clickable
       * div near label X".
       * This setting must not be exposed to scripts. It must not be increased
       * just to allow that one slow selector. This is a value that must be
       * maintained by the team responsible for keeping clients running properly.
       * </pre>
       *
       * <code>optional int32 max_pairs = 5 [default = 50];</code>
       * @return The maxPairs.
       */
      @java.lang.Override
      public int getMaxPairs() {
        return instance.getMaxPairs();
      }
      /**
       * <pre>
       * Maximum number of pairs the client is allowed to compare.
       * If there are too many pairs to compare, the client bails out and returns
       * the status TOO_MANY_CANDIDATES to the server.
       * The maximum number of pairs is limited, to avoid clients being slowed
       * down by overly expensive selectors, as the current algorithm is not
       * optimized for large number of pairs. Authors of selectors must take care
       * to keep the number of pairs reasonable.
       * For example, avoid looking for "a div near label X". This will be too
       * slow to process. Look instead for "a button near label X" or "a clickable
       * div near label X".
       * This setting must not be exposed to scripts. It must not be increased
       * just to allow that one slow selector. This is a value that must be
       * maintained by the team responsible for keeping clients running properly.
       * </pre>
       *
       * <code>optional int32 max_pairs = 5 [default = 50];</code>
       * @param value The maxPairs to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPairs(int value) {
        copyOnWrite();
        instance.setMaxPairs(value);
        return this;
      }
      /**
       * <pre>
       * Maximum number of pairs the client is allowed to compare.
       * If there are too many pairs to compare, the client bails out and returns
       * the status TOO_MANY_CANDIDATES to the server.
       * The maximum number of pairs is limited, to avoid clients being slowed
       * down by overly expensive selectors, as the current algorithm is not
       * optimized for large number of pairs. Authors of selectors must take care
       * to keep the number of pairs reasonable.
       * For example, avoid looking for "a div near label X". This will be too
       * slow to process. Look instead for "a button near label X" or "a clickable
       * div near label X".
       * This setting must not be exposed to scripts. It must not be increased
       * just to allow that one slow selector. This is a value that must be
       * maintained by the team responsible for keeping clients running properly.
       * </pre>
       *
       * <code>optional int32 max_pairs = 5 [default = 50];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPairs() {
        copyOnWrite();
        instance.clearMaxPairs();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.ProximityFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "target_",
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.class,
              "inAlignment_",
              "relativePosition_",
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.RelativePosition.internalGetVerifier(),
              "maxPairs_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0005\u0004\u0000\u0001\u0000\u0001\u001b\u0003\u1007" +
                "\u0000\u0004\u100c\u0001\u0005\u1004\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.ProximityFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter DEFAULT_INSTANCE;
    static {
      ProximityFilter defaultInstance = new ProximityFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ProximityFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.ProximityFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ProximityFilter> PARSER;

    public static com.google.protobuf.Parser<ProximityFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BoundingBoxFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.BoundingBoxFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return Whether the requireNonempty field is set.
     */
    boolean hasRequireNonempty();
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return The requireNonempty.
     */
    boolean getRequireNonempty();
  }
  /**
   * <pre>
   * Only keep elements that have a bounding box.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.BoundingBoxFilter}
   */
  public  static final class BoundingBoxFilter extends
      com.google.protobuf.GeneratedMessageLite<
          BoundingBoxFilter, BoundingBoxFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.BoundingBoxFilter)
      BoundingBoxFilterOrBuilder {
    private BoundingBoxFilter() {
    }
    private int bitField0_;
    public static final int REQUIRE_NONEMPTY_FIELD_NUMBER = 1;
    private boolean requireNonempty_;
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return Whether the requireNonempty field is set.
     */
    @java.lang.Override
    public boolean hasRequireNonempty() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return The requireNonempty.
     */
    @java.lang.Override
    public boolean getRequireNonempty() {
      return requireNonempty_;
    }
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @param value The requireNonempty to set.
     */
    private void setRequireNonempty(boolean value) {
      bitField0_ |= 0x00000001;
      requireNonempty_ = value;
    }
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     */
    private void clearRequireNonempty() {
      bitField0_ = (bitField0_ & ~0x00000001);
      requireNonempty_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Only keep elements that have a bounding box.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.BoundingBoxFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.BoundingBoxFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @return Whether the requireNonempty field is set.
       */
      @java.lang.Override
      public boolean hasRequireNonempty() {
        return instance.hasRequireNonempty();
      }
      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @return The requireNonempty.
       */
      @java.lang.Override
      public boolean getRequireNonempty() {
        return instance.getRequireNonempty();
      }
      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @param value The requireNonempty to set.
       * @return This builder for chaining.
       */
      public Builder setRequireNonempty(boolean value) {
        copyOnWrite();
        instance.setRequireNonempty(value);
        return this;
      }
      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRequireNonempty() {
        copyOnWrite();
        instance.clearRequireNonempty();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.BoundingBoxFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "requireNonempty_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u1007\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.BoundingBoxFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter DEFAULT_INSTANCE;
    static {
      BoundingBoxFilter defaultInstance = new BoundingBoxFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BoundingBoxFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BoundingBoxFilter> PARSER;

    public static com.google.protobuf.Parser<BoundingBoxFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OnTopFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.OnTopFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return Whether the scrollIntoViewIfNeeded field is set.
     */
    boolean hasScrollIntoViewIfNeeded();
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return The scrollIntoViewIfNeeded.
     */
    boolean getScrollIntoViewIfNeeded();

    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return Whether the acceptElementIfNotInView field is set.
     */
    boolean hasAcceptElementIfNotInView();
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return The acceptElementIfNotInView.
     */
    boolean getAcceptElementIfNotInView();
  }
  /**
   * <pre>
   * Filter out elements covered by other elements, such as overlays.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.OnTopFilter}
   */
  public  static final class OnTopFilter extends
      com.google.protobuf.GeneratedMessageLite<
          OnTopFilter, OnTopFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.OnTopFilter)
      OnTopFilterOrBuilder {
    private OnTopFilter() {
      scrollIntoViewIfNeeded_ = true;
    }
    private int bitField0_;
    public static final int SCROLL_INTO_VIEW_IF_NEEDED_FIELD_NUMBER = 1;
    private boolean scrollIntoViewIfNeeded_;
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return Whether the scrollIntoViewIfNeeded field is set.
     */
    @java.lang.Override
    public boolean hasScrollIntoViewIfNeeded() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return The scrollIntoViewIfNeeded.
     */
    @java.lang.Override
    public boolean getScrollIntoViewIfNeeded() {
      return scrollIntoViewIfNeeded_;
    }
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @param value The scrollIntoViewIfNeeded to set.
     */
    private void setScrollIntoViewIfNeeded(boolean value) {
      bitField0_ |= 0x00000001;
      scrollIntoViewIfNeeded_ = value;
    }
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     */
    private void clearScrollIntoViewIfNeeded() {
      bitField0_ = (bitField0_ & ~0x00000001);
      scrollIntoViewIfNeeded_ = true;
    }

    public static final int ACCEPT_ELEMENT_IF_NOT_IN_VIEW_FIELD_NUMBER = 2;
    private boolean acceptElementIfNotInView_;
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return Whether the acceptElementIfNotInView field is set.
     */
    @java.lang.Override
    public boolean hasAcceptElementIfNotInView() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return The acceptElementIfNotInView.
     */
    @java.lang.Override
    public boolean getAcceptElementIfNotInView() {
      return acceptElementIfNotInView_;
    }
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @param value The acceptElementIfNotInView to set.
     */
    private void setAcceptElementIfNotInView(boolean value) {
      bitField0_ |= 0x00000002;
      acceptElementIfNotInView_ = value;
    }
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     */
    private void clearAcceptElementIfNotInView() {
      bitField0_ = (bitField0_ & ~0x00000002);
      acceptElementIfNotInView_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Filter out elements covered by other elements, such as overlays.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.OnTopFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.OnTopFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @return Whether the scrollIntoViewIfNeeded field is set.
       */
      @java.lang.Override
      public boolean hasScrollIntoViewIfNeeded() {
        return instance.hasScrollIntoViewIfNeeded();
      }
      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @return The scrollIntoViewIfNeeded.
       */
      @java.lang.Override
      public boolean getScrollIntoViewIfNeeded() {
        return instance.getScrollIntoViewIfNeeded();
      }
      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @param value The scrollIntoViewIfNeeded to set.
       * @return This builder for chaining.
       */
      public Builder setScrollIntoViewIfNeeded(boolean value) {
        copyOnWrite();
        instance.setScrollIntoViewIfNeeded(value);
        return this;
      }
      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearScrollIntoViewIfNeeded() {
        copyOnWrite();
        instance.clearScrollIntoViewIfNeeded();
        return this;
      }

      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @return Whether the acceptElementIfNotInView field is set.
       */
      @java.lang.Override
      public boolean hasAcceptElementIfNotInView() {
        return instance.hasAcceptElementIfNotInView();
      }
      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @return The acceptElementIfNotInView.
       */
      @java.lang.Override
      public boolean getAcceptElementIfNotInView() {
        return instance.getAcceptElementIfNotInView();
      }
      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @param value The acceptElementIfNotInView to set.
       * @return This builder for chaining.
       */
      public Builder setAcceptElementIfNotInView(boolean value) {
        copyOnWrite();
        instance.setAcceptElementIfNotInView(value);
        return this;
      }
      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAcceptElementIfNotInView() {
        copyOnWrite();
        instance.clearAcceptElementIfNotInView();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.OnTopFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "scrollIntoViewIfNeeded_",
              "acceptElementIfNotInView_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1007\u0000\u0002" +
                "\u1007\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.OnTopFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter DEFAULT_INSTANCE;
    static {
      OnTopFilter defaultInstance = new OnTopFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OnTopFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OnTopFilter> PARSER;

    public static com.google.protobuf.Parser<OnTopFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EmptyFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.EmptyFilter)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code autofill_assistant.SelectorProto.EmptyFilter}
   */
  public  static final class EmptyFilter extends
      com.google.protobuf.GeneratedMessageLite<
          EmptyFilter, EmptyFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.EmptyFilter)
      EmptyFilterOrBuilder {
    private EmptyFilter() {
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.SelectorProto.EmptyFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.EmptyFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.EmptyFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0001\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.EmptyFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter DEFAULT_INSTANCE;
    static {
      EmptyFilter defaultInstance = new EmptyFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EmptyFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EmptyFilter> PARSER;

    public static com.google.protobuf.Parser<EmptyFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NthMatchFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.NthMatchFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return Whether the index field is set.
     */
    boolean hasIndex();
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return The index.
     */
    int getIndex();
  }
  /**
   * Protobuf type {@code autofill_assistant.SelectorProto.NthMatchFilter}
   */
  public  static final class NthMatchFilter extends
      com.google.protobuf.GeneratedMessageLite<
          NthMatchFilter, NthMatchFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.NthMatchFilter)
      NthMatchFilterOrBuilder {
    private NthMatchFilter() {
    }
    private int bitField0_;
    public static final int INDEX_FIELD_NUMBER = 1;
    private int index_;
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return Whether the index field is set.
     */
    @java.lang.Override
    public boolean hasIndex() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return The index.
     */
    @java.lang.Override
    public int getIndex() {
      return index_;
    }
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @param value The index to set.
     */
    private void setIndex(int value) {
      bitField0_ |= 0x00000001;
      index_ = value;
    }
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     */
    private void clearIndex() {
      bitField0_ = (bitField0_ & ~0x00000001);
      index_ = 0;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.SelectorProto.NthMatchFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.NthMatchFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @return Whether the index field is set.
       */
      @java.lang.Override
      public boolean hasIndex() {
        return instance.hasIndex();
      }
      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @return The index.
       */
      @java.lang.Override
      public int getIndex() {
        return instance.getIndex();
      }
      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @param value The index to set.
       * @return This builder for chaining.
       */
      public Builder setIndex(int value) {
        copyOnWrite();
        instance.setIndex(value);
        return this;
      }
      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIndex() {
        copyOnWrite();
        instance.clearIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.NthMatchFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "index_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u1004\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.NthMatchFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter DEFAULT_INSTANCE;
    static {
      NthMatchFilter defaultInstance = new NthMatchFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NthMatchFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NthMatchFilter> PARSER;

    public static com.google.protobuf.Parser<NthMatchFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public static final int FILTERS_FIELD_NUMBER = 9;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> filters_;
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> getFiltersList() {
    return filters_;
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  public java.util.List<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder> 
      getFiltersOrBuilderList() {
    return filters_;
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  @java.lang.Override
  public int getFiltersCount() {
    return filters_.size();
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getFilters(int index) {
    return filters_.get(index);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder getFiltersOrBuilder(
      int index) {
    return filters_.get(index);
  }
  private void ensureFiltersIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> tmp = filters_;
    if (!tmp.isModifiable()) {
      filters_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void setFilters(
      int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
    value.getClass();
  ensureFiltersIsMutable();
    filters_.set(index, value);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void addFilters(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
    value.getClass();
  ensureFiltersIsMutable();
    filters_.add(value);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void addFilters(
      int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
    value.getClass();
  ensureFiltersIsMutable();
    filters_.add(index, value);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void addAllFilters(
      java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> values) {
    ensureFiltersIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, filters_);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void clearFilters() {
    filters_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void removeFilters(int index) {
    ensureFiltersIsMutable();
    filters_.remove(index);
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * A reference to one or more elements on the page, possibly nested in frames.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto, Builder> implements
      // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto)
      org.chromium.chrome.browser.autofill_assistant.proto.SelectorProtoOrBuilder {
    // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> getFiltersList() {
      return java.util.Collections.unmodifiableList(
          instance.getFiltersList());
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    @java.lang.Override
    public int getFiltersCount() {
      return instance.getFiltersCount();
    }/**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getFilters(int index) {
      return instance.getFilters(index);
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder setFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      copyOnWrite();
      instance.setFilters(index, value);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder setFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
      copyOnWrite();
      instance.setFilters(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      copyOnWrite();
      instance.addFilters(value);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      copyOnWrite();
      instance.addFilters(index, value);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
      copyOnWrite();
      instance.addFilters(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
      copyOnWrite();
      instance.addFilters(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addAllFilters(
        java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> values) {
      copyOnWrite();
      instance.addAllFilters(values);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder clearFilters() {
      copyOnWrite();
      instance.clearFilters();
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder removeFilters(int index) {
      copyOnWrite();
      instance.removeFilters(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "filters_",
            org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.class,
          };
          java.lang.String info =
              "\u0001\u0001\u0000\u0000\t\t\u0001\u0000\u0001\u0000\t\u001b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto)
  private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto DEFAULT_INSTANCE;
  static {
    SelectorProto defaultInstance = new SelectorProto();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      SelectorProto.class, defaultInstance);
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<SelectorProto> PARSER;

  public static com.google.protobuf.Parser<SelectorProto> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

