
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by
//     java_cpp_enum.py
// From
//     ../../components/password_manager/core/browser/bulk_leak_check_service_interface.h

package org.chromium.chrome.browser.password_check;

import androidx.annotation.IntDef;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@IntDef({
    BulkLeakCheckServiceState.IDLE, BulkLeakCheckServiceState.RUNNING,
    BulkLeakCheckServiceState.CANCELED, BulkLeakCheckServiceState.SIGNED_OUT,
    BulkLeakCheckServiceState.TOKEN_REQUEST_FAILURE, BulkLeakCheckServiceState.HASHING_FAILURE,
    BulkLeakCheckServiceState.NETWORK_ERROR, BulkLeakCheckServiceState.SERVICE_ERROR,
    BulkLeakCheckServiceState.QUOTA_LIMIT
})
@Retention(RetentionPolicy.SOURCE)
public @interface BulkLeakCheckServiceState {
  /**
   * The service is idle and there was no previous error.
   */
  int IDLE = 0;
  /**
   * The service is checking some credentials.
   */
  int RUNNING = 1;
  /**
   * Those below are error states. On any error the current job is aborted. The error is sticky
   * until next CheckUsernamePasswordPairs() call. Cancel() aborted the running check.
   */
  int CANCELED = 2;
  /**
   * The user isn't signed-in to Chrome.
   */
  int SIGNED_OUT = 3;
  /**
   * Error obtaining an access token.
   */
  int TOKEN_REQUEST_FAILURE = 4;
  /**
   * Error in hashing/encrypting for the request.
   */
  int HASHING_FAILURE = 5;
  /**
   * Error related to network.
   */
  int NETWORK_ERROR = 6;
  /**
   * Error related to the password leak Google service.
   */
  int SERVICE_ERROR = 7;
  /**
   * Error related to the quota limit of the password leak Google service.
   */
  int QUOTA_LIMIT = 8;
}
