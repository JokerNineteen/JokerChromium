// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: extension_install.proto

package org.chromium.components.metrics;

public final class ExtensionInstallProtos {
  private ExtensionInstallProtos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface ExtensionInstallProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:metrics.ExtensionInstallProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
     * @return The type.
     */
    org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type getType();

    /**
     * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
     * @return Whether the installLocation field is set.
     */
    boolean hasInstallLocation();
    /**
     * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
     * @return The installLocation.
     */
    org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation getInstallLocation();

    /**
     * <pre>
     * The manifest version in the extension. Note: this refers to the
     * Chrome-required versioning of the manifest, not the extension version.
     * Currently, it is always 1 or 2.
     * </pre>
     *
     * <code>optional int32 manifest_version = 3;</code>
     * @return Whether the manifestVersion field is set.
     */
    boolean hasManifestVersion();
    /**
     * <pre>
     * The manifest version in the extension. Note: this refers to the
     * Chrome-required versioning of the manifest, not the extension version.
     * Currently, it is always 1 or 2.
     * </pre>
     *
     * <code>optional int32 manifest_version = 3;</code>
     * @return The manifestVersion.
     */
    int getManifestVersion();

    /**
     * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
     * @return Whether the actionType field is set.
     */
    boolean hasActionType();
    /**
     * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
     * @return The actionType.
     */
    org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType getActionType();

    /**
     * <pre>
     * If the extension has been granted file access.
     * </pre>
     *
     * <code>optional bool has_file_access = 5;</code>
     * @return Whether the hasFileAccess field is set.
     */
    boolean hasHasFileAccess();
    /**
     * <pre>
     * If the extension has been granted file access.
     * </pre>
     *
     * <code>optional bool has_file_access = 5;</code>
     * @return The hasFileAccess.
     */
    boolean getHasFileAccess();

    /**
     * <pre>
     * If the extension has been granted permission to run in incognito contexts.
     * </pre>
     *
     * <code>optional bool has_incognito_access = 6;</code>
     * @return Whether the hasIncognitoAccess field is set.
     */
    boolean hasHasIncognitoAccess();
    /**
     * <pre>
     * If the extension has been granted permission to run in incognito contexts.
     * </pre>
     *
     * <code>optional bool has_incognito_access = 6;</code>
     * @return The hasIncognitoAccess.
     */
    boolean getHasIncognitoAccess();

    /**
     * <pre>
     * If the extension originated from the Chrome Web Store according to the
     * prefs.
     * This differs from install_location, which specifies from where the location
     * on the user’s machine from where the install originated, but not whether
     * the extension is hosted in the store. For instance, sideloaded extensions
     * that are specified via ID in the registry are downloaded from the store.
     * </pre>
     *
     * <code>optional bool is_from_store = 7;</code>
     * @return Whether the isFromStore field is set.
     */
    boolean hasIsFromStore();
    /**
     * <pre>
     * If the extension originated from the Chrome Web Store according to the
     * prefs.
     * This differs from install_location, which specifies from where the location
     * on the user’s machine from where the install originated, but not whether
     * the extension is hosted in the store. For instance, sideloaded extensions
     * that are specified via ID in the registry are downloaded from the store.
     * </pre>
     *
     * <code>optional bool is_from_store = 7;</code>
     * @return The isFromStore.
     */
    boolean getIsFromStore();

    /**
     * <pre>
     * If the extension automatically updates from the Chrome Web Store.
     * </pre>
     *
     * <code>optional bool updates_from_store = 8;</code>
     * @return Whether the updatesFromStore field is set.
     */
    boolean hasUpdatesFromStore();
    /**
     * <pre>
     * If the extension automatically updates from the Chrome Web Store.
     * </pre>
     *
     * <code>optional bool updates_from_store = 8;</code>
     * @return The updatesFromStore.
     */
    boolean getUpdatesFromStore();

    /**
     * <pre>
     * If the extension is a bookmark app that was generated from a web page. This
     * is distinct from install_location above, which specifies from where on the
     * user’s machine the install originated.
     * </pre>
     *
     * <code>optional bool is_from_bookmark = 9;</code>
     * @return Whether the isFromBookmark field is set.
     */
    boolean hasIsFromBookmark();
    /**
     * <pre>
     * If the extension is a bookmark app that was generated from a web page. This
     * is distinct from install_location above, which specifies from where on the
     * user’s machine the install originated.
     * </pre>
     *
     * <code>optional bool is_from_bookmark = 9;</code>
     * @return The isFromBookmark.
     */
    boolean getIsFromBookmark();

    /**
     * <pre>
     * If the extension was created from a user script. This is distinct from
     * install_location above, which specifies from where on the user’s machine
     * the install originated.
     * </pre>
     *
     * <code>optional bool is_converted_from_user_script = 10;</code>
     * @return Whether the isConvertedFromUserScript field is set.
     */
    boolean hasIsConvertedFromUserScript();
    /**
     * <pre>
     * If the extension was created from a user script. This is distinct from
     * install_location above, which specifies from where on the user’s machine
     * the install originated.
     * </pre>
     *
     * <code>optional bool is_converted_from_user_script = 10;</code>
     * @return The isConvertedFromUserScript.
     */
    boolean getIsConvertedFromUserScript();

    /**
     * <pre>
     * If the extension was installed by default when the profile was created.
     * These extensions are specified by Chrome.
     * </pre>
     *
     * <code>optional bool is_default_installed = 11;</code>
     * @return Whether the isDefaultInstalled field is set.
     */
    boolean hasIsDefaultInstalled();
    /**
     * <pre>
     * If the extension was installed by default when the profile was created.
     * These extensions are specified by Chrome.
     * </pre>
     *
     * <code>optional bool is_default_installed = 11;</code>
     * @return The isDefaultInstalled.
     */
    boolean getIsDefaultInstalled();

    /**
     * <pre>
     * If the extension was installed by an OEM. This differs from
     * "is_default_installed", since these extensions are specified by the OEM
     * rather than by Chrome. These are specified in a file that is created as
     * part of the creation of the Chrome image, and can be specific to different
     * OEMs.
     * </pre>
     *
     * <code>optional bool is_oem_installed = 12;</code>
     * @return Whether the isOemInstalled field is set.
     */
    boolean hasIsOemInstalled();
    /**
     * <pre>
     * If the extension was installed by an OEM. This differs from
     * "is_default_installed", since these extensions are specified by the OEM
     * rather than by Chrome. These are specified in a file that is created as
     * part of the creation of the Chrome image, and can be specific to different
     * OEMs.
     * </pre>
     *
     * <code>optional bool is_oem_installed = 12;</code>
     * @return The isOemInstalled.
     */
    boolean getIsOemInstalled();

    /**
     * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
     * @return Whether the backgroundScriptType field is set.
     */
    boolean hasBackgroundScriptType();
    /**
     * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
     * @return The backgroundScriptType.
     */
    org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType getBackgroundScriptType();

    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @return A list containing the disableReasons.
     */
    java.util.List<org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason> getDisableReasonsList();
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @return The count of disableReasons.
     */
    int getDisableReasonsCount();
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @param index The index of the element to return.
     * @return The disableReasons at the given index.
     */
    org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason getDisableReasons(int index);

    /**
     * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
     * @return Whether the blacklistState field is set.
     */
    boolean hasBlacklistState();
    /**
     * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
     * @return The blacklistState.
     */
    org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState getBlacklistState();

    /**
     * <pre>
     * Whether the extension was installed in the current sampling period. This
     * is useful if trying to use extension installation in conjunction with other
     * metrics (e.g. page load). Since some of the metrics from this period will
     * have the extension installed and others won't, these records can be
     * discarded for that analysis.
     * </pre>
     *
     * <code>optional bool installed_in_this_sample_period = 16;</code>
     * @return Whether the installedInThisSamplePeriod field is set.
     */
    boolean hasInstalledInThisSamplePeriod();
    /**
     * <pre>
     * Whether the extension was installed in the current sampling period. This
     * is useful if trying to use extension installation in conjunction with other
     * metrics (e.g. page load). Since some of the metrics from this period will
     * have the extension installed and others won't, these records can be
     * discarded for that analysis.
     * </pre>
     *
     * <code>optional bool installed_in_this_sample_period = 16;</code>
     * @return The installedInThisSamplePeriod.
     */
    boolean getInstalledInThisSamplePeriod();
  }
  /**
   * <pre>
   * Stores information about an extension installed on a user's machine.
   * Next tag: 17.
   * </pre>
   *
   * Protobuf type {@code metrics.ExtensionInstallProto}
   */
  public  static final class ExtensionInstallProto extends
      com.google.protobuf.GeneratedMessageLite<
          ExtensionInstallProto, ExtensionInstallProto.Builder> implements
      // @@protoc_insertion_point(message_implements:metrics.ExtensionInstallProto)
      ExtensionInstallProtoOrBuilder {
    private ExtensionInstallProto() {
      disableReasons_ = emptyIntList();
    }
    /**
     * <pre>
     * The type of extension item this is.
     * </pre>
     *
     * Protobuf enum {@code metrics.ExtensionInstallProto.Type}
     */
    public enum Type
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Unknown (hopefully never used)
       * </pre>
       *
       * <code>UNKNOWN_TYPE = 0;</code>
       */
      UNKNOWN_TYPE(0),
      /**
       * <pre>
       * A browser extension
       * </pre>
       *
       * <code>EXTENSION = 1;</code>
       */
      EXTENSION(1),
      /**
       * <pre>
       * A browser theme
       * </pre>
       *
       * <code>THEME = 2;</code>
       */
      THEME(2),
      /**
       * <pre>
       * An extension converted from a user script
       * </pre>
       *
       * <code>USER_SCRIPT = 3;</code>
       */
      USER_SCRIPT(3),
      /**
       * <pre>
       * A hosted app
       * </pre>
       *
       * <code>HOSTED_APP = 4;</code>
       */
      HOSTED_APP(4),
      /**
       * <pre>
       * A (deprecated) v1 packaged app
       * </pre>
       *
       * <code>LEGACY_PACKAGED_APP = 5;</code>
       */
      LEGACY_PACKAGED_APP(5),
      /**
       * <pre>
       * A platform app
       * </pre>
       *
       * <code>PLATFORM_APP = 6;</code>
       */
      PLATFORM_APP(6),
      /**
       * <pre>
       * A shared module
       * </pre>
       *
       * <code>SHARED_MODULE = 7;</code>
       */
      SHARED_MODULE(7),
      /**
       * <pre>
       * An extension running on the login screen
       * </pre>
       *
       * <code>LOGIN_SCREEN_EXTENSION = 8;</code>
       */
      LOGIN_SCREEN_EXTENSION(8),
      ;

      /**
       * <pre>
       * Unknown (hopefully never used)
       * </pre>
       *
       * <code>UNKNOWN_TYPE = 0;</code>
       */
      public static final int UNKNOWN_TYPE_VALUE = 0;
      /**
       * <pre>
       * A browser extension
       * </pre>
       *
       * <code>EXTENSION = 1;</code>
       */
      public static final int EXTENSION_VALUE = 1;
      /**
       * <pre>
       * A browser theme
       * </pre>
       *
       * <code>THEME = 2;</code>
       */
      public static final int THEME_VALUE = 2;
      /**
       * <pre>
       * An extension converted from a user script
       * </pre>
       *
       * <code>USER_SCRIPT = 3;</code>
       */
      public static final int USER_SCRIPT_VALUE = 3;
      /**
       * <pre>
       * A hosted app
       * </pre>
       *
       * <code>HOSTED_APP = 4;</code>
       */
      public static final int HOSTED_APP_VALUE = 4;
      /**
       * <pre>
       * A (deprecated) v1 packaged app
       * </pre>
       *
       * <code>LEGACY_PACKAGED_APP = 5;</code>
       */
      public static final int LEGACY_PACKAGED_APP_VALUE = 5;
      /**
       * <pre>
       * A platform app
       * </pre>
       *
       * <code>PLATFORM_APP = 6;</code>
       */
      public static final int PLATFORM_APP_VALUE = 6;
      /**
       * <pre>
       * A shared module
       * </pre>
       *
       * <code>SHARED_MODULE = 7;</code>
       */
      public static final int SHARED_MODULE_VALUE = 7;
      /**
       * <pre>
       * An extension running on the login screen
       * </pre>
       *
       * <code>LOGIN_SCREEN_EXTENSION = 8;</code>
       */
      public static final int LOGIN_SCREEN_EXTENSION_VALUE = 8;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      public static Type forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_TYPE;
          case 1: return EXTENSION;
          case 2: return THEME;
          case 3: return USER_SCRIPT;
          case 4: return HOSTED_APP;
          case 5: return LEGACY_PACKAGED_APP;
          case 6: return PLATFORM_APP;
          case 7: return SHARED_MODULE;
          case 8: return LOGIN_SCREEN_EXTENSION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              @java.lang.Override
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TypeVerifier.INSTANCE;
      }

      private static final class TypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Type.forNumber(number) != null;
              }
            };

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.ExtensionInstallProto.Type)
    }

    /**
     * <pre>
     * The source of the extension.
     * </pre>
     *
     * Protobuf enum {@code metrics.ExtensionInstallProto.InstallLocation}
     */
    public enum InstallLocation
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Unknown (hopefully never used)
       * </pre>
       *
       * <code>UNKNOWN_LOCATION = 0;</code>
       */
      UNKNOWN_LOCATION(0),
      /**
       * <pre>
       * A crx file from the internal Extensions directory; most
       * </pre>
       *
       * <code>INTERNAL = 1;</code>
       */
      INTERNAL(1),
      /**
       * <pre>
       * webstore-installed extensions fall into this category.
       * </pre>
       *
       * <code>EXTERNAL_PREF = 2;</code>
       */
      EXTERNAL_PREF(2),
      /**
       * <pre>
       * A crx file from an external directory (via the
       * </pre>
       *
       * <code>EXTERNAL_REGISTRY = 3;</code>
       */
      EXTERNAL_REGISTRY(3),
      /**
       * <pre>
       * Windows registry)
       * </pre>
       *
       * <code>UNPACKED = 4;</code>
       */
      UNPACKED(4),
      /**
       * <pre>
       * An internal component extension.
       * </pre>
       *
       * <code>COMPONENT = 5;</code>
       */
      COMPONENT(5),
      /**
       * <pre>
       * A crx file from an external directory (via
       * </pre>
       *
       * <code>EXTERNAL_PREF_DOWNLOAD = 6;</code>
       */
      EXTERNAL_PREF_DOWNLOAD(6),
      /**
       * <pre>
       * prefs), downloaded from an update URL.
       * </pre>
       *
       * <code>EXTERNAL_POLICY_DOWNLOAD = 7;</code>
       */
      EXTERNAL_POLICY_DOWNLOAD(7),
      /**
       * <pre>
       * admin policies), downloaded from an update
       * URL.
       * </pre>
       *
       * <code>COMMAND_LINE = 8;</code>
       */
      COMMAND_LINE(8),
      /**
       * <pre>
       * A crx file from an external directory (via admin
       * </pre>
       *
       * <code>EXTERNAL_POLICY = 9;</code>
       */
      EXTERNAL_POLICY(9),
      /**
       * <pre>
       * policies), cached locally and installed from the
       * cache.
       * </pre>
       *
       * <code>EXTERNAL_COMPONENT = 10;</code>
       */
      EXTERNAL_COMPONENT(10),
      ;

      /**
       * <pre>
       * Unknown (hopefully never used)
       * </pre>
       *
       * <code>UNKNOWN_LOCATION = 0;</code>
       */
      public static final int UNKNOWN_LOCATION_VALUE = 0;
      /**
       * <pre>
       * A crx file from the internal Extensions directory; most
       * </pre>
       *
       * <code>INTERNAL = 1;</code>
       */
      public static final int INTERNAL_VALUE = 1;
      /**
       * <pre>
       * webstore-installed extensions fall into this category.
       * </pre>
       *
       * <code>EXTERNAL_PREF = 2;</code>
       */
      public static final int EXTERNAL_PREF_VALUE = 2;
      /**
       * <pre>
       * A crx file from an external directory (via the
       * </pre>
       *
       * <code>EXTERNAL_REGISTRY = 3;</code>
       */
      public static final int EXTERNAL_REGISTRY_VALUE = 3;
      /**
       * <pre>
       * Windows registry)
       * </pre>
       *
       * <code>UNPACKED = 4;</code>
       */
      public static final int UNPACKED_VALUE = 4;
      /**
       * <pre>
       * An internal component extension.
       * </pre>
       *
       * <code>COMPONENT = 5;</code>
       */
      public static final int COMPONENT_VALUE = 5;
      /**
       * <pre>
       * A crx file from an external directory (via
       * </pre>
       *
       * <code>EXTERNAL_PREF_DOWNLOAD = 6;</code>
       */
      public static final int EXTERNAL_PREF_DOWNLOAD_VALUE = 6;
      /**
       * <pre>
       * prefs), downloaded from an update URL.
       * </pre>
       *
       * <code>EXTERNAL_POLICY_DOWNLOAD = 7;</code>
       */
      public static final int EXTERNAL_POLICY_DOWNLOAD_VALUE = 7;
      /**
       * <pre>
       * admin policies), downloaded from an update
       * URL.
       * </pre>
       *
       * <code>COMMAND_LINE = 8;</code>
       */
      public static final int COMMAND_LINE_VALUE = 8;
      /**
       * <pre>
       * A crx file from an external directory (via admin
       * </pre>
       *
       * <code>EXTERNAL_POLICY = 9;</code>
       */
      public static final int EXTERNAL_POLICY_VALUE = 9;
      /**
       * <pre>
       * policies), cached locally and installed from the
       * cache.
       * </pre>
       *
       * <code>EXTERNAL_COMPONENT = 10;</code>
       */
      public static final int EXTERNAL_COMPONENT_VALUE = 10;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InstallLocation valueOf(int value) {
        return forNumber(value);
      }

      public static InstallLocation forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_LOCATION;
          case 1: return INTERNAL;
          case 2: return EXTERNAL_PREF;
          case 3: return EXTERNAL_REGISTRY;
          case 4: return UNPACKED;
          case 5: return COMPONENT;
          case 6: return EXTERNAL_PREF_DOWNLOAD;
          case 7: return EXTERNAL_POLICY_DOWNLOAD;
          case 8: return COMMAND_LINE;
          case 9: return EXTERNAL_POLICY;
          case 10: return EXTERNAL_COMPONENT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InstallLocation>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InstallLocation> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InstallLocation>() {
              @java.lang.Override
              public InstallLocation findValueByNumber(int number) {
                return InstallLocation.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return InstallLocationVerifier.INSTANCE;
      }

      private static final class InstallLocationVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InstallLocationVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return InstallLocation.forNumber(number) != null;
              }
            };

      private final int value;

      private InstallLocation(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.ExtensionInstallProto.InstallLocation)
    }

    /**
     * <pre>
     * The associated UI action in the extension. Each extension can have at most
     * one type of action.
     * </pre>
     *
     * Protobuf enum {@code metrics.ExtensionInstallProto.ActionType}
     */
    public enum ActionType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NO_ACTION = 0;</code>
       */
      NO_ACTION(0),
      /**
       * <code>BROWSER_ACTION = 1;</code>
       */
      BROWSER_ACTION(1),
      /**
       * <code>PAGE_ACTION = 2;</code>
       */
      PAGE_ACTION(2),
      /**
       * <code>SYSTEM_INDICATOR = 3;</code>
       */
      SYSTEM_INDICATOR(3),
      ;

      /**
       * <code>NO_ACTION = 0;</code>
       */
      public static final int NO_ACTION_VALUE = 0;
      /**
       * <code>BROWSER_ACTION = 1;</code>
       */
      public static final int BROWSER_ACTION_VALUE = 1;
      /**
       * <code>PAGE_ACTION = 2;</code>
       */
      public static final int PAGE_ACTION_VALUE = 2;
      /**
       * <code>SYSTEM_INDICATOR = 3;</code>
       */
      public static final int SYSTEM_INDICATOR_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ActionType valueOf(int value) {
        return forNumber(value);
      }

      public static ActionType forNumber(int value) {
        switch (value) {
          case 0: return NO_ACTION;
          case 1: return BROWSER_ACTION;
          case 2: return PAGE_ACTION;
          case 3: return SYSTEM_INDICATOR;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ActionType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ActionType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ActionType>() {
              @java.lang.Override
              public ActionType findValueByNumber(int number) {
                return ActionType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ActionTypeVerifier.INSTANCE;
      }

      private static final class ActionTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ActionTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ActionType.forNumber(number) != null;
              }
            };

      private final int value;

      private ActionType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.ExtensionInstallProto.ActionType)
    }

    /**
     * <pre>
     * The type of background page this extension has. Each extension can have at
     * most one type of background presence.
     * </pre>
     *
     * Protobuf enum {@code metrics.ExtensionInstallProto.BackgroundScriptType}
     */
    public enum BackgroundScriptType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * The extension has no background page.
       * </pre>
       *
       * <code>NO_BACKGROUND_SCRIPT = 0;</code>
       */
      NO_BACKGROUND_SCRIPT(0),
      /**
       * <pre>
       * The extension has a persistent
       * </pre>
       *
       * <code>PERSISTENT_BACKGROUND_PAGE = 1;</code>
       */
      PERSISTENT_BACKGROUND_PAGE(1),
      /**
       * <pre>
       * background page.
       * </pre>
       *
       * <code>EVENT_PAGE = 2;</code>
       */
      EVENT_PAGE(2),
      /**
       * <pre>
       * The extension has a service worker based
       * </pre>
       *
       * <code>SERVICE_WORKER = 3;</code>
       */
      SERVICE_WORKER(3),
      ;

      /**
       * <pre>
       * The extension has no background page.
       * </pre>
       *
       * <code>NO_BACKGROUND_SCRIPT = 0;</code>
       */
      public static final int NO_BACKGROUND_SCRIPT_VALUE = 0;
      /**
       * <pre>
       * The extension has a persistent
       * </pre>
       *
       * <code>PERSISTENT_BACKGROUND_PAGE = 1;</code>
       */
      public static final int PERSISTENT_BACKGROUND_PAGE_VALUE = 1;
      /**
       * <pre>
       * background page.
       * </pre>
       *
       * <code>EVENT_PAGE = 2;</code>
       */
      public static final int EVENT_PAGE_VALUE = 2;
      /**
       * <pre>
       * The extension has a service worker based
       * </pre>
       *
       * <code>SERVICE_WORKER = 3;</code>
       */
      public static final int SERVICE_WORKER_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BackgroundScriptType valueOf(int value) {
        return forNumber(value);
      }

      public static BackgroundScriptType forNumber(int value) {
        switch (value) {
          case 0: return NO_BACKGROUND_SCRIPT;
          case 1: return PERSISTENT_BACKGROUND_PAGE;
          case 2: return EVENT_PAGE;
          case 3: return SERVICE_WORKER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<BackgroundScriptType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          BackgroundScriptType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<BackgroundScriptType>() {
              @java.lang.Override
              public BackgroundScriptType findValueByNumber(int number) {
                return BackgroundScriptType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return BackgroundScriptTypeVerifier.INSTANCE;
      }

      private static final class BackgroundScriptTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new BackgroundScriptTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return BackgroundScriptType.forNumber(number) != null;
              }
            };

      private final int value;

      private BackgroundScriptType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.ExtensionInstallProto.BackgroundScriptType)
    }

    /**
     * <pre>
     * The reasons an extension may be disabled.
     * </pre>
     *
     * Protobuf enum {@code metrics.ExtensionInstallProto.DisableReason}
     */
    public enum DisableReason
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * The user disabled the extension.
       * </pre>
       *
       * <code>USER_ACTION = 0;</code>
       */
      USER_ACTION(0),
      /**
       * <pre>
       * The extension increased permissions.
       * </pre>
       *
       * <code>PERMISSIONS_INCREASE = 1;</code>
       */
      PERMISSIONS_INCREASE(1),
      /**
       * <pre>
       * The extension is reloading.
       * </pre>
       *
       * <code>RELOAD = 2;</code>
       */
      RELOAD(2),
      /**
       * <pre>
       * The extension has requirements that weren't
       * </pre>
       *
       * <code>UNSUPPORTED_REQUIREMENT = 3;</code>
       */
      UNSUPPORTED_REQUIREMENT(3),
      /**
       * <pre>
       * met (e.g. graphics capabilities).
       * </pre>
       *
       * <code>SIDELOAD_WIPEOUT = 4;</code>
       */
      SIDELOAD_WIPEOUT(4),
      /**
       * <pre>
       * wipeout.
       * </pre>
       *
       * <code>UNKNOWN_FROM_SYNC = 5;</code>
       */
      UNKNOWN_FROM_SYNC(5),
      /**
       * <pre>
       * The extension couldn't be verified.
       * </pre>
       *
       * <code>NOT_VERIFIED = 6;</code>
       */
      NOT_VERIFIED(6),
      /**
       * <pre>
       * The extension was found on the greylist.
       * </pre>
       *
       * <code>GREYLIST = 7;</code>
       */
      GREYLIST(7),
      /**
       * <pre>
       * The extension install was corrupted according to content
       * </pre>
       *
       * <code>CORRUPTED = 8;</code>
       */
      CORRUPTED(8),
      /**
       * <pre>
       * verification.
       * </pre>
       *
       * <code>REMOTE_INSTALL = 9;</code>
       */
      REMOTE_INSTALL(9),
      /**
       * <pre>
       * enabled.
       * </pre>
       *
       * <code>EXTERNAL_EXTENSION = 10;</code>
       */
      EXTERNAL_EXTENSION(10),
      /**
       * <pre>
       * enabled.
       * </pre>
       *
       * <code>UPDATE_REQUIRED_BY_POLICY = 11;</code>
       */
      UPDATE_REQUIRED_BY_POLICY(11),
      /**
       * <pre>
       * version.
       * </pre>
       *
       * <code>CUSTODIAN_APPROVAL_REQUIRED = 12;</code>
       */
      CUSTODIAN_APPROVAL_REQUIRED(12),
      /**
       * <pre>
       * approval for a supervised user.
       * </pre>
       *
       * <code>BLOCKED_BY_POLICY = 13;</code>
       */
      BLOCKED_BY_POLICY(13),
      /**
       * <pre>
       * by enterprise policy.
       * Deprecated: The extension is disabled because it's blocked due to mature
       * content for supervised users.
       * </pre>
       *
       * <code>DEPRECATED_BLOCKED_MATURE = 14;</code>
       */
      DEPRECATED_BLOCKED_MATURE(14),
      /**
       * <pre>
       * The extension is disabled due to having a malware attribute in the Omaha
       * config.
       * </pre>
       *
       * <code>DISABLE_REMOTELY_FOR_MALWARE = 15;</code>
       */
      DISABLE_REMOTELY_FOR_MALWARE(15),
      /**
       * <pre>
       * The extension is being reinstalled.
       * </pre>
       *
       * <code>REINSTALL = 16;</code>
       */
      REINSTALL(16),
      /**
       * <pre>
       * The extension has been disabled because it's not allowlisted and the Safe
       * Browsing allowlist is enforced in the user profile.
       * </pre>
       *
       * <code>NOT_ALLOWLISTED = 17;</code>
       */
      NOT_ALLOWLISTED(17),
      ;

      /**
       * <pre>
       * The user disabled the extension.
       * </pre>
       *
       * <code>USER_ACTION = 0;</code>
       */
      public static final int USER_ACTION_VALUE = 0;
      /**
       * <pre>
       * The extension increased permissions.
       * </pre>
       *
       * <code>PERMISSIONS_INCREASE = 1;</code>
       */
      public static final int PERMISSIONS_INCREASE_VALUE = 1;
      /**
       * <pre>
       * The extension is reloading.
       * </pre>
       *
       * <code>RELOAD = 2;</code>
       */
      public static final int RELOAD_VALUE = 2;
      /**
       * <pre>
       * The extension has requirements that weren't
       * </pre>
       *
       * <code>UNSUPPORTED_REQUIREMENT = 3;</code>
       */
      public static final int UNSUPPORTED_REQUIREMENT_VALUE = 3;
      /**
       * <pre>
       * met (e.g. graphics capabilities).
       * </pre>
       *
       * <code>SIDELOAD_WIPEOUT = 4;</code>
       */
      public static final int SIDELOAD_WIPEOUT_VALUE = 4;
      /**
       * <pre>
       * wipeout.
       * </pre>
       *
       * <code>UNKNOWN_FROM_SYNC = 5;</code>
       */
      public static final int UNKNOWN_FROM_SYNC_VALUE = 5;
      /**
       * <pre>
       * The extension couldn't be verified.
       * </pre>
       *
       * <code>NOT_VERIFIED = 6;</code>
       */
      public static final int NOT_VERIFIED_VALUE = 6;
      /**
       * <pre>
       * The extension was found on the greylist.
       * </pre>
       *
       * <code>GREYLIST = 7;</code>
       */
      public static final int GREYLIST_VALUE = 7;
      /**
       * <pre>
       * The extension install was corrupted according to content
       * </pre>
       *
       * <code>CORRUPTED = 8;</code>
       */
      public static final int CORRUPTED_VALUE = 8;
      /**
       * <pre>
       * verification.
       * </pre>
       *
       * <code>REMOTE_INSTALL = 9;</code>
       */
      public static final int REMOTE_INSTALL_VALUE = 9;
      /**
       * <pre>
       * enabled.
       * </pre>
       *
       * <code>EXTERNAL_EXTENSION = 10;</code>
       */
      public static final int EXTERNAL_EXTENSION_VALUE = 10;
      /**
       * <pre>
       * enabled.
       * </pre>
       *
       * <code>UPDATE_REQUIRED_BY_POLICY = 11;</code>
       */
      public static final int UPDATE_REQUIRED_BY_POLICY_VALUE = 11;
      /**
       * <pre>
       * version.
       * </pre>
       *
       * <code>CUSTODIAN_APPROVAL_REQUIRED = 12;</code>
       */
      public static final int CUSTODIAN_APPROVAL_REQUIRED_VALUE = 12;
      /**
       * <pre>
       * approval for a supervised user.
       * </pre>
       *
       * <code>BLOCKED_BY_POLICY = 13;</code>
       */
      public static final int BLOCKED_BY_POLICY_VALUE = 13;
      /**
       * <pre>
       * by enterprise policy.
       * Deprecated: The extension is disabled because it's blocked due to mature
       * content for supervised users.
       * </pre>
       *
       * <code>DEPRECATED_BLOCKED_MATURE = 14;</code>
       */
      public static final int DEPRECATED_BLOCKED_MATURE_VALUE = 14;
      /**
       * <pre>
       * The extension is disabled due to having a malware attribute in the Omaha
       * config.
       * </pre>
       *
       * <code>DISABLE_REMOTELY_FOR_MALWARE = 15;</code>
       */
      public static final int DISABLE_REMOTELY_FOR_MALWARE_VALUE = 15;
      /**
       * <pre>
       * The extension is being reinstalled.
       * </pre>
       *
       * <code>REINSTALL = 16;</code>
       */
      public static final int REINSTALL_VALUE = 16;
      /**
       * <pre>
       * The extension has been disabled because it's not allowlisted and the Safe
       * Browsing allowlist is enforced in the user profile.
       * </pre>
       *
       * <code>NOT_ALLOWLISTED = 17;</code>
       */
      public static final int NOT_ALLOWLISTED_VALUE = 17;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DisableReason valueOf(int value) {
        return forNumber(value);
      }

      public static DisableReason forNumber(int value) {
        switch (value) {
          case 0: return USER_ACTION;
          case 1: return PERMISSIONS_INCREASE;
          case 2: return RELOAD;
          case 3: return UNSUPPORTED_REQUIREMENT;
          case 4: return SIDELOAD_WIPEOUT;
          case 5: return UNKNOWN_FROM_SYNC;
          case 6: return NOT_VERIFIED;
          case 7: return GREYLIST;
          case 8: return CORRUPTED;
          case 9: return REMOTE_INSTALL;
          case 10: return EXTERNAL_EXTENSION;
          case 11: return UPDATE_REQUIRED_BY_POLICY;
          case 12: return CUSTODIAN_APPROVAL_REQUIRED;
          case 13: return BLOCKED_BY_POLICY;
          case 14: return DEPRECATED_BLOCKED_MATURE;
          case 15: return DISABLE_REMOTELY_FOR_MALWARE;
          case 16: return REINSTALL;
          case 17: return NOT_ALLOWLISTED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<DisableReason>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          DisableReason> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<DisableReason>() {
              @java.lang.Override
              public DisableReason findValueByNumber(int number) {
                return DisableReason.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return DisableReasonVerifier.INSTANCE;
      }

      private static final class DisableReasonVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new DisableReasonVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return DisableReason.forNumber(number) != null;
              }
            };

      private final int value;

      private DisableReason(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.ExtensionInstallProto.DisableReason)
    }

    /**
     * <pre>
     * The state of the extension in the safe browsing blacklist.
     * The numeric values here match the values of the respective enum in
     * ClientCRXListInfoResponse proto.
     * </pre>
     *
     * Protobuf enum {@code metrics.ExtensionInstallProto.BlacklistState}
     */
    public enum BlacklistState
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * The extension is not in the blacklist.
       * </pre>
       *
       * <code>NOT_BLACKLISTED = 0;</code>
       */
      NOT_BLACKLISTED(0),
      /**
       * <pre>
       * The extension is malware.
       * </pre>
       *
       * <code>BLACKLISTED_MALWARE = 1;</code>
       */
      BLACKLISTED_MALWARE(1),
      /**
       * <pre>
       * The extension has a serious security vulnerability.
       * </pre>
       *
       * <code>BLACKLISTED_SECURITY_VULNERABILITY = 2;</code>
       */
      BLACKLISTED_SECURITY_VULNERABILITY(2),
      /**
       * <pre>
       * The extension violated CWS policy.
       * </pre>
       *
       * <code>BLACKLISTED_CWS_POLICY_VIOLATION = 3;</code>
       */
      BLACKLISTED_CWS_POLICY_VIOLATION(3),
      /**
       * <pre>
       * The extension is considered potentially unwanted.
       * </pre>
       *
       * <code>BLACKLISTED_POTENTIALLY_UNWANTED = 4;</code>
       */
      BLACKLISTED_POTENTIALLY_UNWANTED(4),
      /**
       * <pre>
       * Used when we couldn't connect to server, e.g. when offline.
       * </pre>
       *
       * <code>BLACKLISTED_UNKNOWN = 5;</code>
       */
      BLACKLISTED_UNKNOWN(5),
      ;

      /**
       * <pre>
       * The extension is not in the blacklist.
       * </pre>
       *
       * <code>NOT_BLACKLISTED = 0;</code>
       */
      public static final int NOT_BLACKLISTED_VALUE = 0;
      /**
       * <pre>
       * The extension is malware.
       * </pre>
       *
       * <code>BLACKLISTED_MALWARE = 1;</code>
       */
      public static final int BLACKLISTED_MALWARE_VALUE = 1;
      /**
       * <pre>
       * The extension has a serious security vulnerability.
       * </pre>
       *
       * <code>BLACKLISTED_SECURITY_VULNERABILITY = 2;</code>
       */
      public static final int BLACKLISTED_SECURITY_VULNERABILITY_VALUE = 2;
      /**
       * <pre>
       * The extension violated CWS policy.
       * </pre>
       *
       * <code>BLACKLISTED_CWS_POLICY_VIOLATION = 3;</code>
       */
      public static final int BLACKLISTED_CWS_POLICY_VIOLATION_VALUE = 3;
      /**
       * <pre>
       * The extension is considered potentially unwanted.
       * </pre>
       *
       * <code>BLACKLISTED_POTENTIALLY_UNWANTED = 4;</code>
       */
      public static final int BLACKLISTED_POTENTIALLY_UNWANTED_VALUE = 4;
      /**
       * <pre>
       * Used when we couldn't connect to server, e.g. when offline.
       * </pre>
       *
       * <code>BLACKLISTED_UNKNOWN = 5;</code>
       */
      public static final int BLACKLISTED_UNKNOWN_VALUE = 5;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BlacklistState valueOf(int value) {
        return forNumber(value);
      }

      public static BlacklistState forNumber(int value) {
        switch (value) {
          case 0: return NOT_BLACKLISTED;
          case 1: return BLACKLISTED_MALWARE;
          case 2: return BLACKLISTED_SECURITY_VULNERABILITY;
          case 3: return BLACKLISTED_CWS_POLICY_VIOLATION;
          case 4: return BLACKLISTED_POTENTIALLY_UNWANTED;
          case 5: return BLACKLISTED_UNKNOWN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<BlacklistState>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          BlacklistState> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<BlacklistState>() {
              @java.lang.Override
              public BlacklistState findValueByNumber(int number) {
                return BlacklistState.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return BlacklistStateVerifier.INSTANCE;
      }

      private static final class BlacklistStateVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new BlacklistStateVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return BlacklistState.forNumber(number) != null;
              }
            };

      private final int value;

      private BlacklistState(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.ExtensionInstallProto.BlacklistState)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type getType() {
      org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type result = org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type.forNumber(type_);
      return result == null ? org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type.UNKNOWN_TYPE : result;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 0;
    }

    public static final int INSTALL_LOCATION_FIELD_NUMBER = 2;
    private int installLocation_;
    /**
     * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
     * @return Whether the installLocation field is set.
     */
    @java.lang.Override
    public boolean hasInstallLocation() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
     * @return The installLocation.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation getInstallLocation() {
      org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation result = org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation.forNumber(installLocation_);
      return result == null ? org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation.UNKNOWN_LOCATION : result;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
     * @param value The installLocation to set.
     */
    private void setInstallLocation(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation value) {
      installLocation_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
     */
    private void clearInstallLocation() {
      bitField0_ = (bitField0_ & ~0x00000002);
      installLocation_ = 0;
    }

    public static final int MANIFEST_VERSION_FIELD_NUMBER = 3;
    private int manifestVersion_;
    /**
     * <pre>
     * The manifest version in the extension. Note: this refers to the
     * Chrome-required versioning of the manifest, not the extension version.
     * Currently, it is always 1 or 2.
     * </pre>
     *
     * <code>optional int32 manifest_version = 3;</code>
     * @return Whether the manifestVersion field is set.
     */
    @java.lang.Override
    public boolean hasManifestVersion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The manifest version in the extension. Note: this refers to the
     * Chrome-required versioning of the manifest, not the extension version.
     * Currently, it is always 1 or 2.
     * </pre>
     *
     * <code>optional int32 manifest_version = 3;</code>
     * @return The manifestVersion.
     */
    @java.lang.Override
    public int getManifestVersion() {
      return manifestVersion_;
    }
    /**
     * <pre>
     * The manifest version in the extension. Note: this refers to the
     * Chrome-required versioning of the manifest, not the extension version.
     * Currently, it is always 1 or 2.
     * </pre>
     *
     * <code>optional int32 manifest_version = 3;</code>
     * @param value The manifestVersion to set.
     */
    private void setManifestVersion(int value) {
      bitField0_ |= 0x00000004;
      manifestVersion_ = value;
    }
    /**
     * <pre>
     * The manifest version in the extension. Note: this refers to the
     * Chrome-required versioning of the manifest, not the extension version.
     * Currently, it is always 1 or 2.
     * </pre>
     *
     * <code>optional int32 manifest_version = 3;</code>
     */
    private void clearManifestVersion() {
      bitField0_ = (bitField0_ & ~0x00000004);
      manifestVersion_ = 0;
    }

    public static final int ACTION_TYPE_FIELD_NUMBER = 4;
    private int actionType_;
    /**
     * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
     * @return Whether the actionType field is set.
     */
    @java.lang.Override
    public boolean hasActionType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
     * @return The actionType.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType getActionType() {
      org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType result = org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType.forNumber(actionType_);
      return result == null ? org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType.NO_ACTION : result;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
     * @param value The actionType to set.
     */
    private void setActionType(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType value) {
      actionType_ = value.getNumber();
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
     */
    private void clearActionType() {
      bitField0_ = (bitField0_ & ~0x00000008);
      actionType_ = 0;
    }

    public static final int HAS_FILE_ACCESS_FIELD_NUMBER = 5;
    private boolean hasFileAccess_;
    /**
     * <pre>
     * If the extension has been granted file access.
     * </pre>
     *
     * <code>optional bool has_file_access = 5;</code>
     * @return Whether the hasFileAccess field is set.
     */
    @java.lang.Override
    public boolean hasHasFileAccess() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If the extension has been granted file access.
     * </pre>
     *
     * <code>optional bool has_file_access = 5;</code>
     * @return The hasFileAccess.
     */
    @java.lang.Override
    public boolean getHasFileAccess() {
      return hasFileAccess_;
    }
    /**
     * <pre>
     * If the extension has been granted file access.
     * </pre>
     *
     * <code>optional bool has_file_access = 5;</code>
     * @param value The hasFileAccess to set.
     */
    private void setHasFileAccess(boolean value) {
      bitField0_ |= 0x00000010;
      hasFileAccess_ = value;
    }
    /**
     * <pre>
     * If the extension has been granted file access.
     * </pre>
     *
     * <code>optional bool has_file_access = 5;</code>
     */
    private void clearHasFileAccess() {
      bitField0_ = (bitField0_ & ~0x00000010);
      hasFileAccess_ = false;
    }

    public static final int HAS_INCOGNITO_ACCESS_FIELD_NUMBER = 6;
    private boolean hasIncognitoAccess_;
    /**
     * <pre>
     * If the extension has been granted permission to run in incognito contexts.
     * </pre>
     *
     * <code>optional bool has_incognito_access = 6;</code>
     * @return Whether the hasIncognitoAccess field is set.
     */
    @java.lang.Override
    public boolean hasHasIncognitoAccess() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * If the extension has been granted permission to run in incognito contexts.
     * </pre>
     *
     * <code>optional bool has_incognito_access = 6;</code>
     * @return The hasIncognitoAccess.
     */
    @java.lang.Override
    public boolean getHasIncognitoAccess() {
      return hasIncognitoAccess_;
    }
    /**
     * <pre>
     * If the extension has been granted permission to run in incognito contexts.
     * </pre>
     *
     * <code>optional bool has_incognito_access = 6;</code>
     * @param value The hasIncognitoAccess to set.
     */
    private void setHasIncognitoAccess(boolean value) {
      bitField0_ |= 0x00000020;
      hasIncognitoAccess_ = value;
    }
    /**
     * <pre>
     * If the extension has been granted permission to run in incognito contexts.
     * </pre>
     *
     * <code>optional bool has_incognito_access = 6;</code>
     */
    private void clearHasIncognitoAccess() {
      bitField0_ = (bitField0_ & ~0x00000020);
      hasIncognitoAccess_ = false;
    }

    public static final int IS_FROM_STORE_FIELD_NUMBER = 7;
    private boolean isFromStore_;
    /**
     * <pre>
     * If the extension originated from the Chrome Web Store according to the
     * prefs.
     * This differs from install_location, which specifies from where the location
     * on the user’s machine from where the install originated, but not whether
     * the extension is hosted in the store. For instance, sideloaded extensions
     * that are specified via ID in the registry are downloaded from the store.
     * </pre>
     *
     * <code>optional bool is_from_store = 7;</code>
     * @return Whether the isFromStore field is set.
     */
    @java.lang.Override
    public boolean hasIsFromStore() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * If the extension originated from the Chrome Web Store according to the
     * prefs.
     * This differs from install_location, which specifies from where the location
     * on the user’s machine from where the install originated, but not whether
     * the extension is hosted in the store. For instance, sideloaded extensions
     * that are specified via ID in the registry are downloaded from the store.
     * </pre>
     *
     * <code>optional bool is_from_store = 7;</code>
     * @return The isFromStore.
     */
    @java.lang.Override
    public boolean getIsFromStore() {
      return isFromStore_;
    }
    /**
     * <pre>
     * If the extension originated from the Chrome Web Store according to the
     * prefs.
     * This differs from install_location, which specifies from where the location
     * on the user’s machine from where the install originated, but not whether
     * the extension is hosted in the store. For instance, sideloaded extensions
     * that are specified via ID in the registry are downloaded from the store.
     * </pre>
     *
     * <code>optional bool is_from_store = 7;</code>
     * @param value The isFromStore to set.
     */
    private void setIsFromStore(boolean value) {
      bitField0_ |= 0x00000040;
      isFromStore_ = value;
    }
    /**
     * <pre>
     * If the extension originated from the Chrome Web Store according to the
     * prefs.
     * This differs from install_location, which specifies from where the location
     * on the user’s machine from where the install originated, but not whether
     * the extension is hosted in the store. For instance, sideloaded extensions
     * that are specified via ID in the registry are downloaded from the store.
     * </pre>
     *
     * <code>optional bool is_from_store = 7;</code>
     */
    private void clearIsFromStore() {
      bitField0_ = (bitField0_ & ~0x00000040);
      isFromStore_ = false;
    }

    public static final int UPDATES_FROM_STORE_FIELD_NUMBER = 8;
    private boolean updatesFromStore_;
    /**
     * <pre>
     * If the extension automatically updates from the Chrome Web Store.
     * </pre>
     *
     * <code>optional bool updates_from_store = 8;</code>
     * @return Whether the updatesFromStore field is set.
     */
    @java.lang.Override
    public boolean hasUpdatesFromStore() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * If the extension automatically updates from the Chrome Web Store.
     * </pre>
     *
     * <code>optional bool updates_from_store = 8;</code>
     * @return The updatesFromStore.
     */
    @java.lang.Override
    public boolean getUpdatesFromStore() {
      return updatesFromStore_;
    }
    /**
     * <pre>
     * If the extension automatically updates from the Chrome Web Store.
     * </pre>
     *
     * <code>optional bool updates_from_store = 8;</code>
     * @param value The updatesFromStore to set.
     */
    private void setUpdatesFromStore(boolean value) {
      bitField0_ |= 0x00000080;
      updatesFromStore_ = value;
    }
    /**
     * <pre>
     * If the extension automatically updates from the Chrome Web Store.
     * </pre>
     *
     * <code>optional bool updates_from_store = 8;</code>
     */
    private void clearUpdatesFromStore() {
      bitField0_ = (bitField0_ & ~0x00000080);
      updatesFromStore_ = false;
    }

    public static final int IS_FROM_BOOKMARK_FIELD_NUMBER = 9;
    private boolean isFromBookmark_;
    /**
     * <pre>
     * If the extension is a bookmark app that was generated from a web page. This
     * is distinct from install_location above, which specifies from where on the
     * user’s machine the install originated.
     * </pre>
     *
     * <code>optional bool is_from_bookmark = 9;</code>
     * @return Whether the isFromBookmark field is set.
     */
    @java.lang.Override
    public boolean hasIsFromBookmark() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * If the extension is a bookmark app that was generated from a web page. This
     * is distinct from install_location above, which specifies from where on the
     * user’s machine the install originated.
     * </pre>
     *
     * <code>optional bool is_from_bookmark = 9;</code>
     * @return The isFromBookmark.
     */
    @java.lang.Override
    public boolean getIsFromBookmark() {
      return isFromBookmark_;
    }
    /**
     * <pre>
     * If the extension is a bookmark app that was generated from a web page. This
     * is distinct from install_location above, which specifies from where on the
     * user’s machine the install originated.
     * </pre>
     *
     * <code>optional bool is_from_bookmark = 9;</code>
     * @param value The isFromBookmark to set.
     */
    private void setIsFromBookmark(boolean value) {
      bitField0_ |= 0x00000100;
      isFromBookmark_ = value;
    }
    /**
     * <pre>
     * If the extension is a bookmark app that was generated from a web page. This
     * is distinct from install_location above, which specifies from where on the
     * user’s machine the install originated.
     * </pre>
     *
     * <code>optional bool is_from_bookmark = 9;</code>
     */
    private void clearIsFromBookmark() {
      bitField0_ = (bitField0_ & ~0x00000100);
      isFromBookmark_ = false;
    }

    public static final int IS_CONVERTED_FROM_USER_SCRIPT_FIELD_NUMBER = 10;
    private boolean isConvertedFromUserScript_;
    /**
     * <pre>
     * If the extension was created from a user script. This is distinct from
     * install_location above, which specifies from where on the user’s machine
     * the install originated.
     * </pre>
     *
     * <code>optional bool is_converted_from_user_script = 10;</code>
     * @return Whether the isConvertedFromUserScript field is set.
     */
    @java.lang.Override
    public boolean hasIsConvertedFromUserScript() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * If the extension was created from a user script. This is distinct from
     * install_location above, which specifies from where on the user’s machine
     * the install originated.
     * </pre>
     *
     * <code>optional bool is_converted_from_user_script = 10;</code>
     * @return The isConvertedFromUserScript.
     */
    @java.lang.Override
    public boolean getIsConvertedFromUserScript() {
      return isConvertedFromUserScript_;
    }
    /**
     * <pre>
     * If the extension was created from a user script. This is distinct from
     * install_location above, which specifies from where on the user’s machine
     * the install originated.
     * </pre>
     *
     * <code>optional bool is_converted_from_user_script = 10;</code>
     * @param value The isConvertedFromUserScript to set.
     */
    private void setIsConvertedFromUserScript(boolean value) {
      bitField0_ |= 0x00000200;
      isConvertedFromUserScript_ = value;
    }
    /**
     * <pre>
     * If the extension was created from a user script. This is distinct from
     * install_location above, which specifies from where on the user’s machine
     * the install originated.
     * </pre>
     *
     * <code>optional bool is_converted_from_user_script = 10;</code>
     */
    private void clearIsConvertedFromUserScript() {
      bitField0_ = (bitField0_ & ~0x00000200);
      isConvertedFromUserScript_ = false;
    }

    public static final int IS_DEFAULT_INSTALLED_FIELD_NUMBER = 11;
    private boolean isDefaultInstalled_;
    /**
     * <pre>
     * If the extension was installed by default when the profile was created.
     * These extensions are specified by Chrome.
     * </pre>
     *
     * <code>optional bool is_default_installed = 11;</code>
     * @return Whether the isDefaultInstalled field is set.
     */
    @java.lang.Override
    public boolean hasIsDefaultInstalled() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * If the extension was installed by default when the profile was created.
     * These extensions are specified by Chrome.
     * </pre>
     *
     * <code>optional bool is_default_installed = 11;</code>
     * @return The isDefaultInstalled.
     */
    @java.lang.Override
    public boolean getIsDefaultInstalled() {
      return isDefaultInstalled_;
    }
    /**
     * <pre>
     * If the extension was installed by default when the profile was created.
     * These extensions are specified by Chrome.
     * </pre>
     *
     * <code>optional bool is_default_installed = 11;</code>
     * @param value The isDefaultInstalled to set.
     */
    private void setIsDefaultInstalled(boolean value) {
      bitField0_ |= 0x00000400;
      isDefaultInstalled_ = value;
    }
    /**
     * <pre>
     * If the extension was installed by default when the profile was created.
     * These extensions are specified by Chrome.
     * </pre>
     *
     * <code>optional bool is_default_installed = 11;</code>
     */
    private void clearIsDefaultInstalled() {
      bitField0_ = (bitField0_ & ~0x00000400);
      isDefaultInstalled_ = false;
    }

    public static final int IS_OEM_INSTALLED_FIELD_NUMBER = 12;
    private boolean isOemInstalled_;
    /**
     * <pre>
     * If the extension was installed by an OEM. This differs from
     * "is_default_installed", since these extensions are specified by the OEM
     * rather than by Chrome. These are specified in a file that is created as
     * part of the creation of the Chrome image, and can be specific to different
     * OEMs.
     * </pre>
     *
     * <code>optional bool is_oem_installed = 12;</code>
     * @return Whether the isOemInstalled field is set.
     */
    @java.lang.Override
    public boolean hasIsOemInstalled() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * If the extension was installed by an OEM. This differs from
     * "is_default_installed", since these extensions are specified by the OEM
     * rather than by Chrome. These are specified in a file that is created as
     * part of the creation of the Chrome image, and can be specific to different
     * OEMs.
     * </pre>
     *
     * <code>optional bool is_oem_installed = 12;</code>
     * @return The isOemInstalled.
     */
    @java.lang.Override
    public boolean getIsOemInstalled() {
      return isOemInstalled_;
    }
    /**
     * <pre>
     * If the extension was installed by an OEM. This differs from
     * "is_default_installed", since these extensions are specified by the OEM
     * rather than by Chrome. These are specified in a file that is created as
     * part of the creation of the Chrome image, and can be specific to different
     * OEMs.
     * </pre>
     *
     * <code>optional bool is_oem_installed = 12;</code>
     * @param value The isOemInstalled to set.
     */
    private void setIsOemInstalled(boolean value) {
      bitField0_ |= 0x00000800;
      isOemInstalled_ = value;
    }
    /**
     * <pre>
     * If the extension was installed by an OEM. This differs from
     * "is_default_installed", since these extensions are specified by the OEM
     * rather than by Chrome. These are specified in a file that is created as
     * part of the creation of the Chrome image, and can be specific to different
     * OEMs.
     * </pre>
     *
     * <code>optional bool is_oem_installed = 12;</code>
     */
    private void clearIsOemInstalled() {
      bitField0_ = (bitField0_ & ~0x00000800);
      isOemInstalled_ = false;
    }

    public static final int BACKGROUND_SCRIPT_TYPE_FIELD_NUMBER = 13;
    private int backgroundScriptType_;
    /**
     * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
     * @return Whether the backgroundScriptType field is set.
     */
    @java.lang.Override
    public boolean hasBackgroundScriptType() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
     * @return The backgroundScriptType.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType getBackgroundScriptType() {
      org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType result = org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType.forNumber(backgroundScriptType_);
      return result == null ? org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType.NO_BACKGROUND_SCRIPT : result;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
     * @param value The backgroundScriptType to set.
     */
    private void setBackgroundScriptType(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType value) {
      backgroundScriptType_ = value.getNumber();
      bitField0_ |= 0x00001000;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
     */
    private void clearBackgroundScriptType() {
      bitField0_ = (bitField0_ & ~0x00001000);
      backgroundScriptType_ = 0;
    }

    public static final int DISABLE_REASONS_FIELD_NUMBER = 14;
    private com.google.protobuf.Internal.IntList disableReasons_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason> disableReasons_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason>() {
              @java.lang.Override
              public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason convert(java.lang.Integer from) {
                org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason result = org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason.forNumber(from);
                return result == null ? org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason.USER_ACTION : result;
              }
            };
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @return A list containing the disableReasons.
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason> getDisableReasonsList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason>(disableReasons_, disableReasons_converter_);
    }
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @return The count of disableReasons.
     */
    @java.lang.Override
    public int getDisableReasonsCount() {
      return disableReasons_.size();
    }
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @param index The index of the element to return.
     * @return The disableReasons at the given index.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason getDisableReasons(int index) {
      return disableReasons_converter_.convert(disableReasons_.getInt(index));
    }
    private void ensureDisableReasonsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = disableReasons_;
      if (!tmp.isModifiable()) {
        disableReasons_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @param index The index to set the value at.
     * @param value The disableReasons to set.
     */
    private void setDisableReasons(
        int index, org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason value) {
      value.getClass();
  ensureDisableReasonsIsMutable();
      disableReasons_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @param value The disableReasons to add.
     */
    private void addDisableReasons(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason value) {
      value.getClass();
  ensureDisableReasonsIsMutable();
      disableReasons_.addInt(value.getNumber());
    }
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     * @param values The disableReasons to add.
     */
    private void addAllDisableReasons(
        java.lang.Iterable<? extends org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason> values) {
      ensureDisableReasonsIsMutable();
      for (org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason value : values) {
        disableReasons_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     * Any DisableReasons in effect for the extension. An empty list means the
     * extension is not disabled. Note that an extension that is not disabled may
     * nonetheless not be running, e.g., terminated because the extension process
     * was killed.
     * </pre>
     *
     * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
     */
    private void clearDisableReasons() {
      disableReasons_ = emptyIntList();
    }

    public static final int BLACKLIST_STATE_FIELD_NUMBER = 15;
    private int blacklistState_;
    /**
     * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
     * @return Whether the blacklistState field is set.
     */
    @java.lang.Override
    public boolean hasBlacklistState() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
     * @return The blacklistState.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState getBlacklistState() {
      org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState result = org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState.forNumber(blacklistState_);
      return result == null ? org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState.NOT_BLACKLISTED : result;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
     * @param value The blacklistState to set.
     */
    private void setBlacklistState(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState value) {
      blacklistState_ = value.getNumber();
      bitField0_ |= 0x00002000;
    }
    /**
     * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
     */
    private void clearBlacklistState() {
      bitField0_ = (bitField0_ & ~0x00002000);
      blacklistState_ = 0;
    }

    public static final int INSTALLED_IN_THIS_SAMPLE_PERIOD_FIELD_NUMBER = 16;
    private boolean installedInThisSamplePeriod_;
    /**
     * <pre>
     * Whether the extension was installed in the current sampling period. This
     * is useful if trying to use extension installation in conjunction with other
     * metrics (e.g. page load). Since some of the metrics from this period will
     * have the extension installed and others won't, these records can be
     * discarded for that analysis.
     * </pre>
     *
     * <code>optional bool installed_in_this_sample_period = 16;</code>
     * @return Whether the installedInThisSamplePeriod field is set.
     */
    @java.lang.Override
    public boolean hasInstalledInThisSamplePeriod() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Whether the extension was installed in the current sampling period. This
     * is useful if trying to use extension installation in conjunction with other
     * metrics (e.g. page load). Since some of the metrics from this period will
     * have the extension installed and others won't, these records can be
     * discarded for that analysis.
     * </pre>
     *
     * <code>optional bool installed_in_this_sample_period = 16;</code>
     * @return The installedInThisSamplePeriod.
     */
    @java.lang.Override
    public boolean getInstalledInThisSamplePeriod() {
      return installedInThisSamplePeriod_;
    }
    /**
     * <pre>
     * Whether the extension was installed in the current sampling period. This
     * is useful if trying to use extension installation in conjunction with other
     * metrics (e.g. page load). Since some of the metrics from this period will
     * have the extension installed and others won't, these records can be
     * discarded for that analysis.
     * </pre>
     *
     * <code>optional bool installed_in_this_sample_period = 16;</code>
     * @param value The installedInThisSamplePeriod to set.
     */
    private void setInstalledInThisSamplePeriod(boolean value) {
      bitField0_ |= 0x00004000;
      installedInThisSamplePeriod_ = value;
    }
    /**
     * <pre>
     * Whether the extension was installed in the current sampling period. This
     * is useful if trying to use extension installation in conjunction with other
     * metrics (e.g. page load). Since some of the metrics from this period will
     * have the extension installed and others won't, these records can be
     * discarded for that analysis.
     * </pre>
     *
     * <code>optional bool installed_in_this_sample_period = 16;</code>
     */
    private void clearInstalledInThisSamplePeriod() {
      bitField0_ = (bitField0_ & ~0x00004000);
      installedInThisSamplePeriod_ = false;
    }

    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Stores information about an extension installed on a user's machine.
     * Next tag: 17.
     * </pre>
     *
     * Protobuf type {@code metrics.ExtensionInstallProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:metrics.ExtensionInstallProto)
        org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProtoOrBuilder {
      // Construct using org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type getType() {
        return instance.getType();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
       * @return Whether the installLocation field is set.
       */
      @java.lang.Override
      public boolean hasInstallLocation() {
        return instance.hasInstallLocation();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
       * @return The installLocation.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation getInstallLocation() {
        return instance.getInstallLocation();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
       * @param value The enum numeric value on the wire for installLocation to set.
       * @return This builder for chaining.
       */
      public Builder setInstallLocation(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation value) {
        copyOnWrite();
        instance.setInstallLocation(value);
        return this;
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.InstallLocation install_location = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearInstallLocation() {
        copyOnWrite();
        instance.clearInstallLocation();
        return this;
      }

      /**
       * <pre>
       * The manifest version in the extension. Note: this refers to the
       * Chrome-required versioning of the manifest, not the extension version.
       * Currently, it is always 1 or 2.
       * </pre>
       *
       * <code>optional int32 manifest_version = 3;</code>
       * @return Whether the manifestVersion field is set.
       */
      @java.lang.Override
      public boolean hasManifestVersion() {
        return instance.hasManifestVersion();
      }
      /**
       * <pre>
       * The manifest version in the extension. Note: this refers to the
       * Chrome-required versioning of the manifest, not the extension version.
       * Currently, it is always 1 or 2.
       * </pre>
       *
       * <code>optional int32 manifest_version = 3;</code>
       * @return The manifestVersion.
       */
      @java.lang.Override
      public int getManifestVersion() {
        return instance.getManifestVersion();
      }
      /**
       * <pre>
       * The manifest version in the extension. Note: this refers to the
       * Chrome-required versioning of the manifest, not the extension version.
       * Currently, it is always 1 or 2.
       * </pre>
       *
       * <code>optional int32 manifest_version = 3;</code>
       * @param value The manifestVersion to set.
       * @return This builder for chaining.
       */
      public Builder setManifestVersion(int value) {
        copyOnWrite();
        instance.setManifestVersion(value);
        return this;
      }
      /**
       * <pre>
       * The manifest version in the extension. Note: this refers to the
       * Chrome-required versioning of the manifest, not the extension version.
       * Currently, it is always 1 or 2.
       * </pre>
       *
       * <code>optional int32 manifest_version = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearManifestVersion() {
        copyOnWrite();
        instance.clearManifestVersion();
        return this;
      }

      /**
       * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
       * @return Whether the actionType field is set.
       */
      @java.lang.Override
      public boolean hasActionType() {
        return instance.hasActionType();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
       * @return The actionType.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType getActionType() {
        return instance.getActionType();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
       * @param value The enum numeric value on the wire for actionType to set.
       * @return This builder for chaining.
       */
      public Builder setActionType(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType value) {
        copyOnWrite();
        instance.setActionType(value);
        return this;
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.ActionType action_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearActionType() {
        copyOnWrite();
        instance.clearActionType();
        return this;
      }

      /**
       * <pre>
       * If the extension has been granted file access.
       * </pre>
       *
       * <code>optional bool has_file_access = 5;</code>
       * @return Whether the hasFileAccess field is set.
       */
      @java.lang.Override
      public boolean hasHasFileAccess() {
        return instance.hasHasFileAccess();
      }
      /**
       * <pre>
       * If the extension has been granted file access.
       * </pre>
       *
       * <code>optional bool has_file_access = 5;</code>
       * @return The hasFileAccess.
       */
      @java.lang.Override
      public boolean getHasFileAccess() {
        return instance.getHasFileAccess();
      }
      /**
       * <pre>
       * If the extension has been granted file access.
       * </pre>
       *
       * <code>optional bool has_file_access = 5;</code>
       * @param value The hasFileAccess to set.
       * @return This builder for chaining.
       */
      public Builder setHasFileAccess(boolean value) {
        copyOnWrite();
        instance.setHasFileAccess(value);
        return this;
      }
      /**
       * <pre>
       * If the extension has been granted file access.
       * </pre>
       *
       * <code>optional bool has_file_access = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHasFileAccess() {
        copyOnWrite();
        instance.clearHasFileAccess();
        return this;
      }

      /**
       * <pre>
       * If the extension has been granted permission to run in incognito contexts.
       * </pre>
       *
       * <code>optional bool has_incognito_access = 6;</code>
       * @return Whether the hasIncognitoAccess field is set.
       */
      @java.lang.Override
      public boolean hasHasIncognitoAccess() {
        return instance.hasHasIncognitoAccess();
      }
      /**
       * <pre>
       * If the extension has been granted permission to run in incognito contexts.
       * </pre>
       *
       * <code>optional bool has_incognito_access = 6;</code>
       * @return The hasIncognitoAccess.
       */
      @java.lang.Override
      public boolean getHasIncognitoAccess() {
        return instance.getHasIncognitoAccess();
      }
      /**
       * <pre>
       * If the extension has been granted permission to run in incognito contexts.
       * </pre>
       *
       * <code>optional bool has_incognito_access = 6;</code>
       * @param value The hasIncognitoAccess to set.
       * @return This builder for chaining.
       */
      public Builder setHasIncognitoAccess(boolean value) {
        copyOnWrite();
        instance.setHasIncognitoAccess(value);
        return this;
      }
      /**
       * <pre>
       * If the extension has been granted permission to run in incognito contexts.
       * </pre>
       *
       * <code>optional bool has_incognito_access = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearHasIncognitoAccess() {
        copyOnWrite();
        instance.clearHasIncognitoAccess();
        return this;
      }

      /**
       * <pre>
       * If the extension originated from the Chrome Web Store according to the
       * prefs.
       * This differs from install_location, which specifies from where the location
       * on the user’s machine from where the install originated, but not whether
       * the extension is hosted in the store. For instance, sideloaded extensions
       * that are specified via ID in the registry are downloaded from the store.
       * </pre>
       *
       * <code>optional bool is_from_store = 7;</code>
       * @return Whether the isFromStore field is set.
       */
      @java.lang.Override
      public boolean hasIsFromStore() {
        return instance.hasIsFromStore();
      }
      /**
       * <pre>
       * If the extension originated from the Chrome Web Store according to the
       * prefs.
       * This differs from install_location, which specifies from where the location
       * on the user’s machine from where the install originated, but not whether
       * the extension is hosted in the store. For instance, sideloaded extensions
       * that are specified via ID in the registry are downloaded from the store.
       * </pre>
       *
       * <code>optional bool is_from_store = 7;</code>
       * @return The isFromStore.
       */
      @java.lang.Override
      public boolean getIsFromStore() {
        return instance.getIsFromStore();
      }
      /**
       * <pre>
       * If the extension originated from the Chrome Web Store according to the
       * prefs.
       * This differs from install_location, which specifies from where the location
       * on the user’s machine from where the install originated, but not whether
       * the extension is hosted in the store. For instance, sideloaded extensions
       * that are specified via ID in the registry are downloaded from the store.
       * </pre>
       *
       * <code>optional bool is_from_store = 7;</code>
       * @param value The isFromStore to set.
       * @return This builder for chaining.
       */
      public Builder setIsFromStore(boolean value) {
        copyOnWrite();
        instance.setIsFromStore(value);
        return this;
      }
      /**
       * <pre>
       * If the extension originated from the Chrome Web Store according to the
       * prefs.
       * This differs from install_location, which specifies from where the location
       * on the user’s machine from where the install originated, but not whether
       * the extension is hosted in the store. For instance, sideloaded extensions
       * that are specified via ID in the registry are downloaded from the store.
       * </pre>
       *
       * <code>optional bool is_from_store = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsFromStore() {
        copyOnWrite();
        instance.clearIsFromStore();
        return this;
      }

      /**
       * <pre>
       * If the extension automatically updates from the Chrome Web Store.
       * </pre>
       *
       * <code>optional bool updates_from_store = 8;</code>
       * @return Whether the updatesFromStore field is set.
       */
      @java.lang.Override
      public boolean hasUpdatesFromStore() {
        return instance.hasUpdatesFromStore();
      }
      /**
       * <pre>
       * If the extension automatically updates from the Chrome Web Store.
       * </pre>
       *
       * <code>optional bool updates_from_store = 8;</code>
       * @return The updatesFromStore.
       */
      @java.lang.Override
      public boolean getUpdatesFromStore() {
        return instance.getUpdatesFromStore();
      }
      /**
       * <pre>
       * If the extension automatically updates from the Chrome Web Store.
       * </pre>
       *
       * <code>optional bool updates_from_store = 8;</code>
       * @param value The updatesFromStore to set.
       * @return This builder for chaining.
       */
      public Builder setUpdatesFromStore(boolean value) {
        copyOnWrite();
        instance.setUpdatesFromStore(value);
        return this;
      }
      /**
       * <pre>
       * If the extension automatically updates from the Chrome Web Store.
       * </pre>
       *
       * <code>optional bool updates_from_store = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdatesFromStore() {
        copyOnWrite();
        instance.clearUpdatesFromStore();
        return this;
      }

      /**
       * <pre>
       * If the extension is a bookmark app that was generated from a web page. This
       * is distinct from install_location above, which specifies from where on the
       * user’s machine the install originated.
       * </pre>
       *
       * <code>optional bool is_from_bookmark = 9;</code>
       * @return Whether the isFromBookmark field is set.
       */
      @java.lang.Override
      public boolean hasIsFromBookmark() {
        return instance.hasIsFromBookmark();
      }
      /**
       * <pre>
       * If the extension is a bookmark app that was generated from a web page. This
       * is distinct from install_location above, which specifies from where on the
       * user’s machine the install originated.
       * </pre>
       *
       * <code>optional bool is_from_bookmark = 9;</code>
       * @return The isFromBookmark.
       */
      @java.lang.Override
      public boolean getIsFromBookmark() {
        return instance.getIsFromBookmark();
      }
      /**
       * <pre>
       * If the extension is a bookmark app that was generated from a web page. This
       * is distinct from install_location above, which specifies from where on the
       * user’s machine the install originated.
       * </pre>
       *
       * <code>optional bool is_from_bookmark = 9;</code>
       * @param value The isFromBookmark to set.
       * @return This builder for chaining.
       */
      public Builder setIsFromBookmark(boolean value) {
        copyOnWrite();
        instance.setIsFromBookmark(value);
        return this;
      }
      /**
       * <pre>
       * If the extension is a bookmark app that was generated from a web page. This
       * is distinct from install_location above, which specifies from where on the
       * user’s machine the install originated.
       * </pre>
       *
       * <code>optional bool is_from_bookmark = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsFromBookmark() {
        copyOnWrite();
        instance.clearIsFromBookmark();
        return this;
      }

      /**
       * <pre>
       * If the extension was created from a user script. This is distinct from
       * install_location above, which specifies from where on the user’s machine
       * the install originated.
       * </pre>
       *
       * <code>optional bool is_converted_from_user_script = 10;</code>
       * @return Whether the isConvertedFromUserScript field is set.
       */
      @java.lang.Override
      public boolean hasIsConvertedFromUserScript() {
        return instance.hasIsConvertedFromUserScript();
      }
      /**
       * <pre>
       * If the extension was created from a user script. This is distinct from
       * install_location above, which specifies from where on the user’s machine
       * the install originated.
       * </pre>
       *
       * <code>optional bool is_converted_from_user_script = 10;</code>
       * @return The isConvertedFromUserScript.
       */
      @java.lang.Override
      public boolean getIsConvertedFromUserScript() {
        return instance.getIsConvertedFromUserScript();
      }
      /**
       * <pre>
       * If the extension was created from a user script. This is distinct from
       * install_location above, which specifies from where on the user’s machine
       * the install originated.
       * </pre>
       *
       * <code>optional bool is_converted_from_user_script = 10;</code>
       * @param value The isConvertedFromUserScript to set.
       * @return This builder for chaining.
       */
      public Builder setIsConvertedFromUserScript(boolean value) {
        copyOnWrite();
        instance.setIsConvertedFromUserScript(value);
        return this;
      }
      /**
       * <pre>
       * If the extension was created from a user script. This is distinct from
       * install_location above, which specifies from where on the user’s machine
       * the install originated.
       * </pre>
       *
       * <code>optional bool is_converted_from_user_script = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsConvertedFromUserScript() {
        copyOnWrite();
        instance.clearIsConvertedFromUserScript();
        return this;
      }

      /**
       * <pre>
       * If the extension was installed by default when the profile was created.
       * These extensions are specified by Chrome.
       * </pre>
       *
       * <code>optional bool is_default_installed = 11;</code>
       * @return Whether the isDefaultInstalled field is set.
       */
      @java.lang.Override
      public boolean hasIsDefaultInstalled() {
        return instance.hasIsDefaultInstalled();
      }
      /**
       * <pre>
       * If the extension was installed by default when the profile was created.
       * These extensions are specified by Chrome.
       * </pre>
       *
       * <code>optional bool is_default_installed = 11;</code>
       * @return The isDefaultInstalled.
       */
      @java.lang.Override
      public boolean getIsDefaultInstalled() {
        return instance.getIsDefaultInstalled();
      }
      /**
       * <pre>
       * If the extension was installed by default when the profile was created.
       * These extensions are specified by Chrome.
       * </pre>
       *
       * <code>optional bool is_default_installed = 11;</code>
       * @param value The isDefaultInstalled to set.
       * @return This builder for chaining.
       */
      public Builder setIsDefaultInstalled(boolean value) {
        copyOnWrite();
        instance.setIsDefaultInstalled(value);
        return this;
      }
      /**
       * <pre>
       * If the extension was installed by default when the profile was created.
       * These extensions are specified by Chrome.
       * </pre>
       *
       * <code>optional bool is_default_installed = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsDefaultInstalled() {
        copyOnWrite();
        instance.clearIsDefaultInstalled();
        return this;
      }

      /**
       * <pre>
       * If the extension was installed by an OEM. This differs from
       * "is_default_installed", since these extensions are specified by the OEM
       * rather than by Chrome. These are specified in a file that is created as
       * part of the creation of the Chrome image, and can be specific to different
       * OEMs.
       * </pre>
       *
       * <code>optional bool is_oem_installed = 12;</code>
       * @return Whether the isOemInstalled field is set.
       */
      @java.lang.Override
      public boolean hasIsOemInstalled() {
        return instance.hasIsOemInstalled();
      }
      /**
       * <pre>
       * If the extension was installed by an OEM. This differs from
       * "is_default_installed", since these extensions are specified by the OEM
       * rather than by Chrome. These are specified in a file that is created as
       * part of the creation of the Chrome image, and can be specific to different
       * OEMs.
       * </pre>
       *
       * <code>optional bool is_oem_installed = 12;</code>
       * @return The isOemInstalled.
       */
      @java.lang.Override
      public boolean getIsOemInstalled() {
        return instance.getIsOemInstalled();
      }
      /**
       * <pre>
       * If the extension was installed by an OEM. This differs from
       * "is_default_installed", since these extensions are specified by the OEM
       * rather than by Chrome. These are specified in a file that is created as
       * part of the creation of the Chrome image, and can be specific to different
       * OEMs.
       * </pre>
       *
       * <code>optional bool is_oem_installed = 12;</code>
       * @param value The isOemInstalled to set.
       * @return This builder for chaining.
       */
      public Builder setIsOemInstalled(boolean value) {
        copyOnWrite();
        instance.setIsOemInstalled(value);
        return this;
      }
      /**
       * <pre>
       * If the extension was installed by an OEM. This differs from
       * "is_default_installed", since these extensions are specified by the OEM
       * rather than by Chrome. These are specified in a file that is created as
       * part of the creation of the Chrome image, and can be specific to different
       * OEMs.
       * </pre>
       *
       * <code>optional bool is_oem_installed = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsOemInstalled() {
        copyOnWrite();
        instance.clearIsOemInstalled();
        return this;
      }

      /**
       * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
       * @return Whether the backgroundScriptType field is set.
       */
      @java.lang.Override
      public boolean hasBackgroundScriptType() {
        return instance.hasBackgroundScriptType();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
       * @return The backgroundScriptType.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType getBackgroundScriptType() {
        return instance.getBackgroundScriptType();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
       * @param value The enum numeric value on the wire for backgroundScriptType to set.
       * @return This builder for chaining.
       */
      public Builder setBackgroundScriptType(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType value) {
        copyOnWrite();
        instance.setBackgroundScriptType(value);
        return this;
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.BackgroundScriptType background_script_type = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearBackgroundScriptType() {
        copyOnWrite();
        instance.clearBackgroundScriptType();
        return this;
      }

      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @return A list containing the disableReasons.
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason> getDisableReasonsList() {
        return instance.getDisableReasonsList();
      }
      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @return The count of disableReasons.
       */
      @java.lang.Override
      public int getDisableReasonsCount() {
        return instance.getDisableReasonsCount();
      }
      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @param index The index of the element to return.
       * @return The disableReasons at the given index.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason getDisableReasons(int index) {
        return instance.getDisableReasons(index);
      }
      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @param index The index to set the value at.
       * @param value The disableReasons to set.
       * @return This builder for chaining.
       */
      public Builder setDisableReasons(
          int index, org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason value) {
        copyOnWrite();
        instance.setDisableReasons(index, value);
        return this;
      }
      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @param value The disableReasons to add.
       * @return This builder for chaining.
       */
      public Builder addDisableReasons(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason value) {
        copyOnWrite();
        instance.addDisableReasons(value);
        return this;
      }
      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @param values The disableReasons to add.
       * @return This builder for chaining.
       */
      public Builder addAllDisableReasons(
          java.lang.Iterable<? extends org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason> values) {
        copyOnWrite();
        instance.addAllDisableReasons(values);  return this;
      }
      /**
       * <pre>
       * Any DisableReasons in effect for the extension. An empty list means the
       * extension is not disabled. Note that an extension that is not disabled may
       * nonetheless not be running, e.g., terminated because the extension process
       * was killed.
       * </pre>
       *
       * <code>repeated .metrics.ExtensionInstallProto.DisableReason disable_reasons = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearDisableReasons() {
        copyOnWrite();
        instance.clearDisableReasons();
        return this;
      }

      /**
       * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
       * @return Whether the blacklistState field is set.
       */
      @java.lang.Override
      public boolean hasBlacklistState() {
        return instance.hasBlacklistState();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
       * @return The blacklistState.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState getBlacklistState() {
        return instance.getBlacklistState();
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
       * @param value The enum numeric value on the wire for blacklistState to set.
       * @return This builder for chaining.
       */
      public Builder setBlacklistState(org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState value) {
        copyOnWrite();
        instance.setBlacklistState(value);
        return this;
      }
      /**
       * <code>optional .metrics.ExtensionInstallProto.BlacklistState blacklist_state = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlacklistState() {
        copyOnWrite();
        instance.clearBlacklistState();
        return this;
      }

      /**
       * <pre>
       * Whether the extension was installed in the current sampling period. This
       * is useful if trying to use extension installation in conjunction with other
       * metrics (e.g. page load). Since some of the metrics from this period will
       * have the extension installed and others won't, these records can be
       * discarded for that analysis.
       * </pre>
       *
       * <code>optional bool installed_in_this_sample_period = 16;</code>
       * @return Whether the installedInThisSamplePeriod field is set.
       */
      @java.lang.Override
      public boolean hasInstalledInThisSamplePeriod() {
        return instance.hasInstalledInThisSamplePeriod();
      }
      /**
       * <pre>
       * Whether the extension was installed in the current sampling period. This
       * is useful if trying to use extension installation in conjunction with other
       * metrics (e.g. page load). Since some of the metrics from this period will
       * have the extension installed and others won't, these records can be
       * discarded for that analysis.
       * </pre>
       *
       * <code>optional bool installed_in_this_sample_period = 16;</code>
       * @return The installedInThisSamplePeriod.
       */
      @java.lang.Override
      public boolean getInstalledInThisSamplePeriod() {
        return instance.getInstalledInThisSamplePeriod();
      }
      /**
       * <pre>
       * Whether the extension was installed in the current sampling period. This
       * is useful if trying to use extension installation in conjunction with other
       * metrics (e.g. page load). Since some of the metrics from this period will
       * have the extension installed and others won't, these records can be
       * discarded for that analysis.
       * </pre>
       *
       * <code>optional bool installed_in_this_sample_period = 16;</code>
       * @param value The installedInThisSamplePeriod to set.
       * @return This builder for chaining.
       */
      public Builder setInstalledInThisSamplePeriod(boolean value) {
        copyOnWrite();
        instance.setInstalledInThisSamplePeriod(value);
        return this;
      }
      /**
       * <pre>
       * Whether the extension was installed in the current sampling period. This
       * is useful if trying to use extension installation in conjunction with other
       * metrics (e.g. page load). Since some of the metrics from this period will
       * have the extension installed and others won't, these records can be
       * discarded for that analysis.
       * </pre>
       *
       * <code>optional bool installed_in_this_sample_period = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearInstalledInThisSamplePeriod() {
        copyOnWrite();
        instance.clearInstalledInThisSamplePeriod();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:metrics.ExtensionInstallProto)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.Type.internalGetVerifier(),
              "installLocation_",
              org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.InstallLocation.internalGetVerifier(),
              "manifestVersion_",
              "actionType_",
              org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.ActionType.internalGetVerifier(),
              "hasFileAccess_",
              "hasIncognitoAccess_",
              "isFromStore_",
              "updatesFromStore_",
              "isFromBookmark_",
              "isConvertedFromUserScript_",
              "isDefaultInstalled_",
              "isOemInstalled_",
              "backgroundScriptType_",
              org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BackgroundScriptType.internalGetVerifier(),
              "disableReasons_",
              org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.DisableReason.internalGetVerifier(),
              "blacklistState_",
              org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.BlacklistState.internalGetVerifier(),
              "installedInThisSamplePeriod_",
            };
            java.lang.String info =
                "\u0001\u0010\u0000\u0001\u0001\u0010\u0010\u0000\u0001\u0000\u0001\u100c\u0000\u0002" +
                "\u100c\u0001\u0003\u1004\u0002\u0004\u100c\u0003\u0005\u1007\u0004\u0006\u1007\u0005" +
                "\u0007\u1007\u0006\b\u1007\u0007\t\u1007\b\n\u1007\t\u000b\u1007\n\f\u1007\u000b" +
                "\r\u100c\f\u000e\u001e\u000f\u100c\r\u0010\u1007\u000e";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:metrics.ExtensionInstallProto)
    private static final org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto DEFAULT_INSTANCE;
    static {
      ExtensionInstallProto defaultInstance = new ExtensionInstallProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ExtensionInstallProto.class, defaultInstance);
    }

    public static org.chromium.components.metrics.ExtensionInstallProtos.ExtensionInstallProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ExtensionInstallProto> PARSER;

    public static com.google.protobuf.Parser<ExtensionInstallProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
