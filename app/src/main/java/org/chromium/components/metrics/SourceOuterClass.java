// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ukm/source.proto

package org.chromium.components.metrics;

public final class SourceOuterClass {
  private SourceOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  /**
   * <pre>
   * Types of source ids defined by
   * https://cs.chromium.org/chromium/src/base/metrics/ukm_source_id.h?l=19
   * </pre>
   *
   * Protobuf enum {@code ukm.SourceType}
   */
  public enum SourceType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>DEFAULT = 0;</code>
     */
    DEFAULT(0),
    /**
     * <code>NAVIGATION_ID = 1;</code>
     */
    NAVIGATION_ID(1),
    /**
     * <code>APP_ID = 2;</code>
     */
    APP_ID(2),
    /**
     * <code>HISTORY_ID = 3;</code>
     */
    HISTORY_ID(3),
    /**
     * <code>WEBAPK_ID = 4;</code>
     */
    WEBAPK_ID(4),
    /**
     * <code>PAYMENT_APP_ID = 5;</code>
     */
    PAYMENT_APP_ID(5),
    /**
     * <code>DESKTOP_WEB_APP_ID = 6;</code>
     */
    DESKTOP_WEB_APP_ID(6),
    /**
     * <code>WORKER_ID = 7;</code>
     */
    WORKER_ID(7),
    ;

    /**
     * <code>DEFAULT = 0;</code>
     */
    public static final int DEFAULT_VALUE = 0;
    /**
     * <code>NAVIGATION_ID = 1;</code>
     */
    public static final int NAVIGATION_ID_VALUE = 1;
    /**
     * <code>APP_ID = 2;</code>
     */
    public static final int APP_ID_VALUE = 2;
    /**
     * <code>HISTORY_ID = 3;</code>
     */
    public static final int HISTORY_ID_VALUE = 3;
    /**
     * <code>WEBAPK_ID = 4;</code>
     */
    public static final int WEBAPK_ID_VALUE = 4;
    /**
     * <code>PAYMENT_APP_ID = 5;</code>
     */
    public static final int PAYMENT_APP_ID_VALUE = 5;
    /**
     * <code>DESKTOP_WEB_APP_ID = 6;</code>
     */
    public static final int DESKTOP_WEB_APP_ID_VALUE = 6;
    /**
     * <code>WORKER_ID = 7;</code>
     */
    public static final int WORKER_ID_VALUE = 7;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SourceType valueOf(int value) {
      return forNumber(value);
    }

    public static SourceType forNumber(int value) {
      switch (value) {
        case 0: return DEFAULT;
        case 1: return NAVIGATION_ID;
        case 2: return APP_ID;
        case 3: return HISTORY_ID;
        case 4: return WEBAPK_ID;
        case 5: return PAYMENT_APP_ID;
        case 6: return DESKTOP_WEB_APP_ID;
        case 7: return WORKER_ID;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SourceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SourceType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SourceType>() {
            @java.lang.Override
            public SourceType findValueByNumber(int number) {
              return SourceType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return SourceTypeVerifier.INSTANCE;
    }

    private static final class SourceTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SourceTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return SourceType.forNumber(number) != null;
            }
          };

    private final int value;

    private SourceType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ukm.SourceType)
  }

  public interface SourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ukm.Source)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * An identifier for the source. This should be unique within a session.
     * </pre>
     *
     * <code>optional int64 id = 1;</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * An identifier for the source. This should be unique within a session.
     * </pre>
     *
     * <code>optional int64 id = 1;</code>
     * @return The id.
     */
    long getId();

    /**
     * <pre>
     * The source id of the last committed non-same-document navigation for the
     * tab this source is in. Should only be set for navigation sources. For
     * backward compatibility, this field will never be set to the source id of a
     * same-document source. In cases where the last committed navigation was a
     * same-document navigation, previous_same_document_source_id will contain
     * the source id of that previous same document navigation, while
     * previous_source_id will contain the source id of the last committed
     * non-same-document navigation. For example, if a user starts on page A (a
     * non same document page load), then performs a same document navigation to
     * B, then navigates to C (which could be either a same document or a non same
     * document navigation), previous_source_id will reference A, and
     * previous_same_document_source_id will reference B.
     * </pre>
     *
     * <code>optional int64 previous_source_id = 11;</code>
     * @return Whether the previousSourceId field is set.
     */
    boolean hasPreviousSourceId();
    /**
     * <pre>
     * The source id of the last committed non-same-document navigation for the
     * tab this source is in. Should only be set for navigation sources. For
     * backward compatibility, this field will never be set to the source id of a
     * same-document source. In cases where the last committed navigation was a
     * same-document navigation, previous_same_document_source_id will contain
     * the source id of that previous same document navigation, while
     * previous_source_id will contain the source id of the last committed
     * non-same-document navigation. For example, if a user starts on page A (a
     * non same document page load), then performs a same document navigation to
     * B, then navigates to C (which could be either a same document or a non same
     * document navigation), previous_source_id will reference A, and
     * previous_same_document_source_id will reference B.
     * </pre>
     *
     * <code>optional int64 previous_source_id = 11;</code>
     * @return The previousSourceId.
     */
    long getPreviousSourceId();

    /**
     * <pre>
     * The source id for the previous same document navigation, if the
     * previously committed source was a same document navigation. If
     * the previously committed source was not a same document
     * navigation, this field will be unset.
     * </pre>
     *
     * <code>optional int64 previous_same_document_source_id = 14;</code>
     * @return Whether the previousSameDocumentSourceId field is set.
     */
    boolean hasPreviousSameDocumentSourceId();
    /**
     * <pre>
     * The source id for the previous same document navigation, if the
     * previously committed source was a same document navigation. If
     * the previously committed source was not a same document
     * navigation, this field will be unset.
     * </pre>
     *
     * <code>optional int64 previous_same_document_source_id = 14;</code>
     * @return The previousSameDocumentSourceId.
     */
    long getPreviousSameDocumentSourceId();

    /**
     * <pre>
     * For sources representing the first navigation in a new tab, this id marks
     * the source which opened the tab. Should only be set for the first
     * navigation source in a tab.
     * </pre>
     *
     * <code>optional int64 opener_source_id = 12;</code>
     * @return Whether the openerSourceId field is set.
     */
    boolean hasOpenerSourceId();
    /**
     * <pre>
     * For sources representing the first navigation in a new tab, this id marks
     * the source which opened the tab. Should only be set for the first
     * navigation source in a tab.
     * </pre>
     *
     * <code>optional int64 opener_source_id = 12;</code>
     * @return The openerSourceId.
     */
    long getOpenerSourceId();

    /**
     * <pre>
     * Type of the source id.
     * </pre>
     *
     * <code>optional .ukm.SourceType type = 16;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of the source id.
     * </pre>
     *
     * <code>optional .ukm.SourceType type = 16;</code>
     * @return The type.
     */
    org.chromium.components.metrics.SourceOuterClass.SourceType getType();

    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    java.util.List<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> 
        getUrlsList();
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getUrls(int index);
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    int getUrlsCount();

    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    java.util.List<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> 
        getResolvedUrlsList();
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getResolvedUrls(int index);
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    int getResolvedUrlsCount();

    /**
     * <pre>
     * Whether this source is for a same document navigation. Examples of same
     * document navigations are fragment navigations, pushState/replaceState,
     * and same page history navigation.
     * </pre>
     *
     * <code>optional bool is_same_document_navigation = 13;</code>
     * @return Whether the isSameDocumentNavigation field is set.
     */
    boolean hasIsSameDocumentNavigation();
    /**
     * <pre>
     * Whether this source is for a same document navigation. Examples of same
     * document navigations are fragment navigations, pushState/replaceState,
     * and same page history navigation.
     * </pre>
     *
     * <code>optional bool is_same_document_navigation = 13;</code>
     * @return The isSameDocumentNavigation.
     */
    boolean getIsSameDocumentNavigation();

    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @return Whether the url field is set.
     */
    boolean hasUrl();
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @return The url.
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @return The bytes for url.
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @return Whether the initialUrl field is set.
     */
    boolean hasInitialUrl();
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @return The initialUrl.
     */
    java.lang.String getInitialUrl();
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @return The bytes for initialUrl.
     */
    com.google.protobuf.ByteString
        getInitialUrlBytes();

    /**
     * <pre>
     * Flag indicating if the metric was collected while inside a "custom tab".
     * </pre>
     *
     * <code>optional bool is_custom_tab = 7;</code>
     * @return Whether the isCustomTab field is set.
     */
    boolean hasIsCustomTab();
    /**
     * <pre>
     * Flag indicating if the metric was collected while inside a "custom tab".
     * </pre>
     *
     * <code>optional bool is_custom_tab = 7;</code>
     * @return The isCustomTab.
     */
    boolean getIsCustomTab();

    /**
     * <pre>
     * Relative time of navigation for this Source, as seen by the client, and is
     * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
     * related to this Source will generally be relative to this timestamp. The
     * recorded navigation time is in TimeTicks, which is the relative time since
     * the origin. The origin is platform-specific but is guaranteed to be
     * monotonically increase within each session.
     * </pre>
     *
     * <code>optional int64 navigation_time_msec = 3;</code>
     * @return Whether the navigationTimeMsec field is set.
     */
    boolean hasNavigationTimeMsec();
    /**
     * <pre>
     * Relative time of navigation for this Source, as seen by the client, and is
     * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
     * related to this Source will generally be relative to this timestamp. The
     * recorded navigation time is in TimeTicks, which is the relative time since
     * the origin. The origin is platform-specific but is guaranteed to be
     * monotonically increase within each session.
     * </pre>
     *
     * <code>optional int64 navigation_time_msec = 3;</code>
     * @return The navigationTimeMsec.
     */
    long getNavigationTimeMsec();

    /**
     * <pre>
     * Unique identifier (for a given client_id/session_id) for the tab this
     * source is associated with. Should only be set for navigation sources.
     * </pre>
     *
     * <code>optional int64 tab_id = 10;</code>
     * @return Whether the tabId field is set.
     */
    boolean hasTabId();
    /**
     * <pre>
     * Unique identifier (for a given client_id/session_id) for the tab this
     * source is associated with. Should only be set for navigation sources.
     * </pre>
     *
     * <code>optional int64 tab_id = 10;</code>
     * @return The tabId.
     */
    long getTabId();

    /**
     * <pre>
     * Time between navigation and the first contentful paint, in milliseconds.
     * Deprecated. Use ukm::Entry instead.
     * </pre>
     *
     * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
     * @return Whether the firstContentfulPaintMsec field is set.
     */
    @java.lang.Deprecated boolean hasFirstContentfulPaintMsec();
    /**
     * <pre>
     * Time between navigation and the first contentful paint, in milliseconds.
     * Deprecated. Use ukm::Entry instead.
     * </pre>
     *
     * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
     * @return The firstContentfulPaintMsec.
     */
    @java.lang.Deprecated long getFirstContentfulPaintMsec();
  }
  /**
   * <pre>
   * Source contains data related to a top-level navigation.
   * Next tag: 17
   * </pre>
   *
   * Protobuf type {@code ukm.Source}
   */
  public  static final class Source extends
      com.google.protobuf.GeneratedMessageLite<
          Source, Source.Builder> implements
      // @@protoc_insertion_point(message_implements:ukm.Source)
      SourceOrBuilder {
    private Source() {
      urls_ = emptyProtobufList();
      resolvedUrls_ = emptyProtobufList();
      url_ = "";
      initialUrl_ = "";
    }
    /**
     * <pre>
     * The URL scheme, such as HTTP, HTTPS, CHROME_EXTENSION, etc.
     * </pre>
     *
     * Protobuf enum {@code ukm.Source.UrlScheme}
     */
    public enum UrlScheme
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNSUPPORTED = 0;</code>
       */
      UNSUPPORTED(0),
      /**
       * <code>HTTP = 1;</code>
       */
      HTTP(1),
      /**
       * <code>HTTPS = 2;</code>
       */
      HTTPS(2),
      /**
       * <code>FTP = 3;</code>
       */
      FTP(3),
      /**
       * <code>ABOUT = 4;</code>
       */
      ABOUT(4),
      /**
       * <code>CHROME = 5;</code>
       */
      CHROME(5),
      /**
       * <code>CHROME_EXTENSION = 6;</code>
       */
      CHROME_EXTENSION(6),
      /**
       * <code>APP = 7;</code>
       */
      APP(7),
      ;

      /**
       * <code>UNSUPPORTED = 0;</code>
       */
      public static final int UNSUPPORTED_VALUE = 0;
      /**
       * <code>HTTP = 1;</code>
       */
      public static final int HTTP_VALUE = 1;
      /**
       * <code>HTTPS = 2;</code>
       */
      public static final int HTTPS_VALUE = 2;
      /**
       * <code>FTP = 3;</code>
       */
      public static final int FTP_VALUE = 3;
      /**
       * <code>ABOUT = 4;</code>
       */
      public static final int ABOUT_VALUE = 4;
      /**
       * <code>CHROME = 5;</code>
       */
      public static final int CHROME_VALUE = 5;
      /**
       * <code>CHROME_EXTENSION = 6;</code>
       */
      public static final int CHROME_EXTENSION_VALUE = 6;
      /**
       * <code>APP = 7;</code>
       */
      public static final int APP_VALUE = 7;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static UrlScheme valueOf(int value) {
        return forNumber(value);
      }

      public static UrlScheme forNumber(int value) {
        switch (value) {
          case 0: return UNSUPPORTED;
          case 1: return HTTP;
          case 2: return HTTPS;
          case 3: return FTP;
          case 4: return ABOUT;
          case 5: return CHROME;
          case 6: return CHROME_EXTENSION;
          case 7: return APP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<UrlScheme>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          UrlScheme> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<UrlScheme>() {
              @java.lang.Override
              public UrlScheme findValueByNumber(int number) {
                return UrlScheme.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return UrlSchemeVerifier.INSTANCE;
      }

      private static final class UrlSchemeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new UrlSchemeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return UrlScheme.forNumber(number) != null;
              }
            };

      private final int value;

      private UrlScheme(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:ukm.Source.UrlScheme)
    }

    public interface UrlInfoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:ukm.Source.UrlInfo)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return Whether the url field is set.
       */
      boolean hasUrl();
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return The url.
       */
      java.lang.String getUrl();
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return The bytes for url.
       */
      com.google.protobuf.ByteString
          getUrlBytes();

      /**
       * <pre>
       * Number of URLs seen for this source before the current URL.
       * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
       * or 0 if it’s the first UrlInfo.
       * </pre>
       *
       * <code>optional int32 previous_url_count = 2;</code>
       * @return Whether the previousUrlCount field is set.
       */
      boolean hasPreviousUrlCount();
      /**
       * <pre>
       * Number of URLs seen for this source before the current URL.
       * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
       * or 0 if it’s the first UrlInfo.
       * </pre>
       *
       * <code>optional int32 previous_url_count = 2;</code>
       * @return The previousUrlCount.
       */
      int getPreviousUrlCount();
    }
    /**
     * <pre>
     * Holds data about a URL seen by the client.
     * </pre>
     *
     * Protobuf type {@code ukm.Source.UrlInfo}
     */
    public  static final class UrlInfo extends
        com.google.protobuf.GeneratedMessageLite<
            UrlInfo, UrlInfo.Builder> implements
        // @@protoc_insertion_point(message_implements:ukm.Source.UrlInfo)
        UrlInfoOrBuilder {
      private UrlInfo() {
        url_ = "";
      }
      private int bitField0_;
      public static final int URL_FIELD_NUMBER = 1;
      private java.lang.String url_;
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return Whether the url field is set.
       */
      @java.lang.Override
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return The url.
       */
      @java.lang.Override
      public java.lang.String getUrl() {
        return url_;
      }
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return The bytes for url.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUrlBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(url_);
      }
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @param value The url to set.
       */
      private void setUrl(
          java.lang.String value) {
        value.getClass();
  bitField0_ |= 0x00000001;
        url_ = value;
      }
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      private void clearUrl() {
        bitField0_ = (bitField0_ & ~0x00000001);
        url_ = getDefaultInstance().getUrl();
      }
      /**
       * <pre>
       * The URL seen by the client.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @param value The bytes for url to set.
       */
      private void setUrlBytes(
          com.google.protobuf.ByteString value) {
        url_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int PREVIOUS_URL_COUNT_FIELD_NUMBER = 2;
      private int previousUrlCount_;
      /**
       * <pre>
       * Number of URLs seen for this source before the current URL.
       * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
       * or 0 if it’s the first UrlInfo.
       * </pre>
       *
       * <code>optional int32 previous_url_count = 2;</code>
       * @return Whether the previousUrlCount field is set.
       */
      @java.lang.Override
      public boolean hasPreviousUrlCount() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Number of URLs seen for this source before the current URL.
       * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
       * or 0 if it’s the first UrlInfo.
       * </pre>
       *
       * <code>optional int32 previous_url_count = 2;</code>
       * @return The previousUrlCount.
       */
      @java.lang.Override
      public int getPreviousUrlCount() {
        return previousUrlCount_;
      }
      /**
       * <pre>
       * Number of URLs seen for this source before the current URL.
       * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
       * or 0 if it’s the first UrlInfo.
       * </pre>
       *
       * <code>optional int32 previous_url_count = 2;</code>
       * @param value The previousUrlCount to set.
       */
      private void setPreviousUrlCount(int value) {
        bitField0_ |= 0x00000002;
        previousUrlCount_ = value;
      }
      /**
       * <pre>
       * Number of URLs seen for this source before the current URL.
       * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
       * or 0 if it’s the first UrlInfo.
       * </pre>
       *
       * <code>optional int32 previous_url_count = 2;</code>
       */
      private void clearPreviousUrlCount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        previousUrlCount_ = 0;
      }

      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Holds data about a URL seen by the client.
       * </pre>
       *
       * Protobuf type {@code ukm.Source.UrlInfo}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo, Builder> implements
          // @@protoc_insertion_point(builder_implements:ukm.Source.UrlInfo)
          org.chromium.components.metrics.SourceOuterClass.Source.UrlInfoOrBuilder {
        // Construct using org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The URL seen by the client.
         * </pre>
         *
         * <code>optional string url = 1;</code>
         * @return Whether the url field is set.
         */
        @java.lang.Override
        public boolean hasUrl() {
          return instance.hasUrl();
        }
        /**
         * <pre>
         * The URL seen by the client.
         * </pre>
         *
         * <code>optional string url = 1;</code>
         * @return The url.
         */
        @java.lang.Override
        public java.lang.String getUrl() {
          return instance.getUrl();
        }
        /**
         * <pre>
         * The URL seen by the client.
         * </pre>
         *
         * <code>optional string url = 1;</code>
         * @return The bytes for url.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getUrlBytes() {
          return instance.getUrlBytes();
        }
        /**
         * <pre>
         * The URL seen by the client.
         * </pre>
         *
         * <code>optional string url = 1;</code>
         * @param value The url to set.
         * @return This builder for chaining.
         */
        public Builder setUrl(
            java.lang.String value) {
          copyOnWrite();
          instance.setUrl(value);
          return this;
        }
        /**
         * <pre>
         * The URL seen by the client.
         * </pre>
         *
         * <code>optional string url = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearUrl() {
          copyOnWrite();
          instance.clearUrl();
          return this;
        }
        /**
         * <pre>
         * The URL seen by the client.
         * </pre>
         *
         * <code>optional string url = 1;</code>
         * @param value The bytes for url to set.
         * @return This builder for chaining.
         */
        public Builder setUrlBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setUrlBytes(value);
          return this;
        }

        /**
         * <pre>
         * Number of URLs seen for this source before the current URL.
         * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
         * or 0 if it’s the first UrlInfo.
         * </pre>
         *
         * <code>optional int32 previous_url_count = 2;</code>
         * @return Whether the previousUrlCount field is set.
         */
        @java.lang.Override
        public boolean hasPreviousUrlCount() {
          return instance.hasPreviousUrlCount();
        }
        /**
         * <pre>
         * Number of URLs seen for this source before the current URL.
         * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
         * or 0 if it’s the first UrlInfo.
         * </pre>
         *
         * <code>optional int32 previous_url_count = 2;</code>
         * @return The previousUrlCount.
         */
        @java.lang.Override
        public int getPreviousUrlCount() {
          return instance.getPreviousUrlCount();
        }
        /**
         * <pre>
         * Number of URLs seen for this source before the current URL.
         * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
         * or 0 if it’s the first UrlInfo.
         * </pre>
         *
         * <code>optional int32 previous_url_count = 2;</code>
         * @param value The previousUrlCount to set.
         * @return This builder for chaining.
         */
        public Builder setPreviousUrlCount(int value) {
          copyOnWrite();
          instance.setPreviousUrlCount(value);
          return this;
        }
        /**
         * <pre>
         * Number of URLs seen for this source before the current URL.
         * If unset, it’s equivalent to the count of the UrlInfo before it + 1,
         * or 0 if it’s the first UrlInfo.
         * </pre>
         *
         * <code>optional int32 previous_url_count = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearPreviousUrlCount() {
          copyOnWrite();
          instance.clearPreviousUrlCount();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:ukm.Source.UrlInfo)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "url_",
                "previousUrlCount_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                  "\u1004\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> parser = PARSER;
            if (parser == null) {
              synchronized (org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:ukm.Source.UrlInfo)
      private static final org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo DEFAULT_INSTANCE;
      static {
        UrlInfo defaultInstance = new UrlInfo();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          UrlInfo.class, defaultInstance);
      }

      public static org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<UrlInfo> PARSER;

      public static com.google.protobuf.Parser<UrlInfo> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private long id_;
    /**
     * <pre>
     * An identifier for the source. This should be unique within a session.
     * </pre>
     *
     * <code>optional int64 id = 1;</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * An identifier for the source. This should be unique within a session.
     * </pre>
     *
     * <code>optional int64 id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public long getId() {
      return id_;
    }
    /**
     * <pre>
     * An identifier for the source. This should be unique within a session.
     * </pre>
     *
     * <code>optional int64 id = 1;</code>
     * @param value The id to set.
     */
    private void setId(long value) {
      bitField0_ |= 0x00000001;
      id_ = value;
    }
    /**
     * <pre>
     * An identifier for the source. This should be unique within a session.
     * </pre>
     *
     * <code>optional int64 id = 1;</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      id_ = 0L;
    }

    public static final int PREVIOUS_SOURCE_ID_FIELD_NUMBER = 11;
    private long previousSourceId_;
    /**
     * <pre>
     * The source id of the last committed non-same-document navigation for the
     * tab this source is in. Should only be set for navigation sources. For
     * backward compatibility, this field will never be set to the source id of a
     * same-document source. In cases where the last committed navigation was a
     * same-document navigation, previous_same_document_source_id will contain
     * the source id of that previous same document navigation, while
     * previous_source_id will contain the source id of the last committed
     * non-same-document navigation. For example, if a user starts on page A (a
     * non same document page load), then performs a same document navigation to
     * B, then navigates to C (which could be either a same document or a non same
     * document navigation), previous_source_id will reference A, and
     * previous_same_document_source_id will reference B.
     * </pre>
     *
     * <code>optional int64 previous_source_id = 11;</code>
     * @return Whether the previousSourceId field is set.
     */
    @java.lang.Override
    public boolean hasPreviousSourceId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The source id of the last committed non-same-document navigation for the
     * tab this source is in. Should only be set for navigation sources. For
     * backward compatibility, this field will never be set to the source id of a
     * same-document source. In cases where the last committed navigation was a
     * same-document navigation, previous_same_document_source_id will contain
     * the source id of that previous same document navigation, while
     * previous_source_id will contain the source id of the last committed
     * non-same-document navigation. For example, if a user starts on page A (a
     * non same document page load), then performs a same document navigation to
     * B, then navigates to C (which could be either a same document or a non same
     * document navigation), previous_source_id will reference A, and
     * previous_same_document_source_id will reference B.
     * </pre>
     *
     * <code>optional int64 previous_source_id = 11;</code>
     * @return The previousSourceId.
     */
    @java.lang.Override
    public long getPreviousSourceId() {
      return previousSourceId_;
    }
    /**
     * <pre>
     * The source id of the last committed non-same-document navigation for the
     * tab this source is in. Should only be set for navigation sources. For
     * backward compatibility, this field will never be set to the source id of a
     * same-document source. In cases where the last committed navigation was a
     * same-document navigation, previous_same_document_source_id will contain
     * the source id of that previous same document navigation, while
     * previous_source_id will contain the source id of the last committed
     * non-same-document navigation. For example, if a user starts on page A (a
     * non same document page load), then performs a same document navigation to
     * B, then navigates to C (which could be either a same document or a non same
     * document navigation), previous_source_id will reference A, and
     * previous_same_document_source_id will reference B.
     * </pre>
     *
     * <code>optional int64 previous_source_id = 11;</code>
     * @param value The previousSourceId to set.
     */
    private void setPreviousSourceId(long value) {
      bitField0_ |= 0x00000002;
      previousSourceId_ = value;
    }
    /**
     * <pre>
     * The source id of the last committed non-same-document navigation for the
     * tab this source is in. Should only be set for navigation sources. For
     * backward compatibility, this field will never be set to the source id of a
     * same-document source. In cases where the last committed navigation was a
     * same-document navigation, previous_same_document_source_id will contain
     * the source id of that previous same document navigation, while
     * previous_source_id will contain the source id of the last committed
     * non-same-document navigation. For example, if a user starts on page A (a
     * non same document page load), then performs a same document navigation to
     * B, then navigates to C (which could be either a same document or a non same
     * document navigation), previous_source_id will reference A, and
     * previous_same_document_source_id will reference B.
     * </pre>
     *
     * <code>optional int64 previous_source_id = 11;</code>
     */
    private void clearPreviousSourceId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      previousSourceId_ = 0L;
    }

    public static final int PREVIOUS_SAME_DOCUMENT_SOURCE_ID_FIELD_NUMBER = 14;
    private long previousSameDocumentSourceId_;
    /**
     * <pre>
     * The source id for the previous same document navigation, if the
     * previously committed source was a same document navigation. If
     * the previously committed source was not a same document
     * navigation, this field will be unset.
     * </pre>
     *
     * <code>optional int64 previous_same_document_source_id = 14;</code>
     * @return Whether the previousSameDocumentSourceId field is set.
     */
    @java.lang.Override
    public boolean hasPreviousSameDocumentSourceId() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The source id for the previous same document navigation, if the
     * previously committed source was a same document navigation. If
     * the previously committed source was not a same document
     * navigation, this field will be unset.
     * </pre>
     *
     * <code>optional int64 previous_same_document_source_id = 14;</code>
     * @return The previousSameDocumentSourceId.
     */
    @java.lang.Override
    public long getPreviousSameDocumentSourceId() {
      return previousSameDocumentSourceId_;
    }
    /**
     * <pre>
     * The source id for the previous same document navigation, if the
     * previously committed source was a same document navigation. If
     * the previously committed source was not a same document
     * navigation, this field will be unset.
     * </pre>
     *
     * <code>optional int64 previous_same_document_source_id = 14;</code>
     * @param value The previousSameDocumentSourceId to set.
     */
    private void setPreviousSameDocumentSourceId(long value) {
      bitField0_ |= 0x00000004;
      previousSameDocumentSourceId_ = value;
    }
    /**
     * <pre>
     * The source id for the previous same document navigation, if the
     * previously committed source was a same document navigation. If
     * the previously committed source was not a same document
     * navigation, this field will be unset.
     * </pre>
     *
     * <code>optional int64 previous_same_document_source_id = 14;</code>
     */
    private void clearPreviousSameDocumentSourceId() {
      bitField0_ = (bitField0_ & ~0x00000004);
      previousSameDocumentSourceId_ = 0L;
    }

    public static final int OPENER_SOURCE_ID_FIELD_NUMBER = 12;
    private long openerSourceId_;
    /**
     * <pre>
     * For sources representing the first navigation in a new tab, this id marks
     * the source which opened the tab. Should only be set for the first
     * navigation source in a tab.
     * </pre>
     *
     * <code>optional int64 opener_source_id = 12;</code>
     * @return Whether the openerSourceId field is set.
     */
    @java.lang.Override
    public boolean hasOpenerSourceId() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * For sources representing the first navigation in a new tab, this id marks
     * the source which opened the tab. Should only be set for the first
     * navigation source in a tab.
     * </pre>
     *
     * <code>optional int64 opener_source_id = 12;</code>
     * @return The openerSourceId.
     */
    @java.lang.Override
    public long getOpenerSourceId() {
      return openerSourceId_;
    }
    /**
     * <pre>
     * For sources representing the first navigation in a new tab, this id marks
     * the source which opened the tab. Should only be set for the first
     * navigation source in a tab.
     * </pre>
     *
     * <code>optional int64 opener_source_id = 12;</code>
     * @param value The openerSourceId to set.
     */
    private void setOpenerSourceId(long value) {
      bitField0_ |= 0x00000008;
      openerSourceId_ = value;
    }
    /**
     * <pre>
     * For sources representing the first navigation in a new tab, this id marks
     * the source which opened the tab. Should only be set for the first
     * navigation source in a tab.
     * </pre>
     *
     * <code>optional int64 opener_source_id = 12;</code>
     */
    private void clearOpenerSourceId() {
      bitField0_ = (bitField0_ & ~0x00000008);
      openerSourceId_ = 0L;
    }

    public static final int TYPE_FIELD_NUMBER = 16;
    private int type_;
    /**
     * <pre>
     * Type of the source id.
     * </pre>
     *
     * <code>optional .ukm.SourceType type = 16;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Type of the source id.
     * </pre>
     *
     * <code>optional .ukm.SourceType type = 16;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.chromium.components.metrics.SourceOuterClass.SourceType getType() {
      org.chromium.components.metrics.SourceOuterClass.SourceType result = org.chromium.components.metrics.SourceOuterClass.SourceType.forNumber(type_);
      return result == null ? org.chromium.components.metrics.SourceOuterClass.SourceType.DEFAULT : result;
    }
    /**
     * <pre>
     * Type of the source id.
     * </pre>
     *
     * <code>optional .ukm.SourceType type = 16;</code>
     * @param value The type to set.
     */
    private void setType(org.chromium.components.metrics.SourceOuterClass.SourceType value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * Type of the source id.
     * </pre>
     *
     * <code>optional .ukm.SourceType type = 16;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000010);
      type_ = 0;
    }

    public static final int URLS_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> urls_;
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> getUrlsList() {
      return urls_;
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    public java.util.List<? extends org.chromium.components.metrics.SourceOuterClass.Source.UrlInfoOrBuilder> 
        getUrlsOrBuilderList() {
      return urls_;
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    @java.lang.Override
    public int getUrlsCount() {
      return urls_.size();
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getUrls(int index) {
      return urls_.get(index);
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    public org.chromium.components.metrics.SourceOuterClass.Source.UrlInfoOrBuilder getUrlsOrBuilder(
        int index) {
      return urls_.get(index);
    }
    private void ensureUrlsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> tmp = urls_;
      if (!tmp.isModifiable()) {
        urls_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    private void setUrls(
        int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
      value.getClass();
  ensureUrlsIsMutable();
      urls_.set(index, value);
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    private void addUrls(org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
      value.getClass();
  ensureUrlsIsMutable();
      urls_.add(value);
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    private void addUrls(
        int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
      value.getClass();
  ensureUrlsIsMutable();
      urls_.add(index, value);
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    private void addAllUrls(
        java.lang.Iterable<? extends org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> values) {
      ensureUrlsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, urls_);
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    private void clearUrls() {
      urls_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Data about each URL associated with the source_id within the record's
     * scope, in the order that the URLs were encountered. Data may include full
     * or partial redirect chains for main frame navigations.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
     */
    private void removeUrls(int index) {
      ensureUrlsIsMutable();
      urls_.remove(index);
    }

    public static final int RESOLVED_URLS_FIELD_NUMBER = 15;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> resolvedUrls_;
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> getResolvedUrlsList() {
      return resolvedUrls_;
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    public java.util.List<? extends org.chromium.components.metrics.SourceOuterClass.Source.UrlInfoOrBuilder> 
        getResolvedUrlsOrBuilderList() {
      return resolvedUrls_;
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    @java.lang.Override
    public int getResolvedUrlsCount() {
      return resolvedUrls_.size();
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getResolvedUrls(int index) {
      return resolvedUrls_.get(index);
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    public org.chromium.components.metrics.SourceOuterClass.Source.UrlInfoOrBuilder getResolvedUrlsOrBuilder(
        int index) {
      return resolvedUrls_.get(index);
    }
    private void ensureResolvedUrlsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> tmp = resolvedUrls_;
      if (!tmp.isModifiable()) {
        resolvedUrls_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    private void setResolvedUrls(
        int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
      value.getClass();
  ensureResolvedUrlsIsMutable();
      resolvedUrls_.set(index, value);
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    private void addResolvedUrls(org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
      value.getClass();
  ensureResolvedUrlsIsMutable();
      resolvedUrls_.add(value);
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    private void addResolvedUrls(
        int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
      value.getClass();
  ensureResolvedUrlsIsMutable();
      resolvedUrls_.add(index, value);
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    private void addAllResolvedUrls(
        java.lang.Iterable<? extends org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> values) {
      ensureResolvedUrlsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, resolvedUrls_);
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    private void clearResolvedUrls() {
      resolvedUrls_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Data about the URL of the Document, copied from the Source message whose
     * id matched the navigation source id of the DocumentCreated event.
     * </pre>
     *
     * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
     */
    private void removeResolvedUrls(int index) {
      ensureResolvedUrlsIsMutable();
      resolvedUrls_.remove(index);
    }

    public static final int IS_SAME_DOCUMENT_NAVIGATION_FIELD_NUMBER = 13;
    private boolean isSameDocumentNavigation_;
    /**
     * <pre>
     * Whether this source is for a same document navigation. Examples of same
     * document navigations are fragment navigations, pushState/replaceState,
     * and same page history navigation.
     * </pre>
     *
     * <code>optional bool is_same_document_navigation = 13;</code>
     * @return Whether the isSameDocumentNavigation field is set.
     */
    @java.lang.Override
    public boolean hasIsSameDocumentNavigation() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Whether this source is for a same document navigation. Examples of same
     * document navigations are fragment navigations, pushState/replaceState,
     * and same page history navigation.
     * </pre>
     *
     * <code>optional bool is_same_document_navigation = 13;</code>
     * @return The isSameDocumentNavigation.
     */
    @java.lang.Override
    public boolean getIsSameDocumentNavigation() {
      return isSameDocumentNavigation_;
    }
    /**
     * <pre>
     * Whether this source is for a same document navigation. Examples of same
     * document navigations are fragment navigations, pushState/replaceState,
     * and same page history navigation.
     * </pre>
     *
     * <code>optional bool is_same_document_navigation = 13;</code>
     * @param value The isSameDocumentNavigation to set.
     */
    private void setIsSameDocumentNavigation(boolean value) {
      bitField0_ |= 0x00000020;
      isSameDocumentNavigation_ = value;
    }
    /**
     * <pre>
     * Whether this source is for a same document navigation. Examples of same
     * document navigations are fragment navigations, pushState/replaceState,
     * and same page history navigation.
     * </pre>
     *
     * <code>optional bool is_same_document_navigation = 13;</code>
     */
    private void clearIsSameDocumentNavigation() {
      bitField0_ = (bitField0_ & ~0x00000020);
      isSameDocumentNavigation_ = false;
    }

    public static final int URL_FIELD_NUMBER = 2;
    private java.lang.String url_;
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @return Whether the url field is set.
     */
    @java.lang.Override
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @return The url.
     */
    @java.lang.Override
    public java.lang.String getUrl() {
      return url_;
    }
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @return The bytes for url.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUrlBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(url_);
    }
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @param value The url to set.
     */
    private void setUrl(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000040;
      url_ = value;
    }
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     */
    private void clearUrl() {
      bitField0_ = (bitField0_ & ~0x00000040);
      url_ = getDefaultInstance().getUrl();
    }
    /**
     * <pre>
     * The URL of the source, as recorded in history. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string url = 2;</code>
     * @param value The bytes for url to set.
     */
    private void setUrlBytes(
        com.google.protobuf.ByteString value) {
      url_ = value.toStringUtf8();
      bitField0_ |= 0x00000040;
    }

    public static final int INITIAL_URL_FIELD_NUMBER = 6;
    private java.lang.String initialUrl_;
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @return Whether the initialUrl field is set.
     */
    @java.lang.Override
    public boolean hasInitialUrl() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @return The initialUrl.
     */
    @java.lang.Override
    public java.lang.String getInitialUrl() {
      return initialUrl_;
    }
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @return The bytes for initialUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInitialUrlBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(initialUrl_);
    }
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @param value The initialUrl to set.
     */
    private void setInitialUrl(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000080;
      initialUrl_ = value;
    }
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     */
    private void clearInitialUrl() {
      bitField0_ = (bitField0_ & ~0x00000080);
      initialUrl_ = getDefaultInstance().getInitialUrl();
    }
    /**
     * <pre>
     * The initial URL of the source. Set in cases where the source URL changed
     * (e.g. it was redirected), otherwise unset. If this URL has not been
     * discovered by Google's crawler, it should not be recorded.
     * </pre>
     *
     * <code>optional string initial_url = 6;</code>
     * @param value The bytes for initialUrl to set.
     */
    private void setInitialUrlBytes(
        com.google.protobuf.ByteString value) {
      initialUrl_ = value.toStringUtf8();
      bitField0_ |= 0x00000080;
    }

    public static final int IS_CUSTOM_TAB_FIELD_NUMBER = 7;
    private boolean isCustomTab_;
    /**
     * <pre>
     * Flag indicating if the metric was collected while inside a "custom tab".
     * </pre>
     *
     * <code>optional bool is_custom_tab = 7;</code>
     * @return Whether the isCustomTab field is set.
     */
    @java.lang.Override
    public boolean hasIsCustomTab() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Flag indicating if the metric was collected while inside a "custom tab".
     * </pre>
     *
     * <code>optional bool is_custom_tab = 7;</code>
     * @return The isCustomTab.
     */
    @java.lang.Override
    public boolean getIsCustomTab() {
      return isCustomTab_;
    }
    /**
     * <pre>
     * Flag indicating if the metric was collected while inside a "custom tab".
     * </pre>
     *
     * <code>optional bool is_custom_tab = 7;</code>
     * @param value The isCustomTab to set.
     */
    private void setIsCustomTab(boolean value) {
      bitField0_ |= 0x00000100;
      isCustomTab_ = value;
    }
    /**
     * <pre>
     * Flag indicating if the metric was collected while inside a "custom tab".
     * </pre>
     *
     * <code>optional bool is_custom_tab = 7;</code>
     */
    private void clearIsCustomTab() {
      bitField0_ = (bitField0_ & ~0x00000100);
      isCustomTab_ = false;
    }

    public static final int NAVIGATION_TIME_MSEC_FIELD_NUMBER = 3;
    private long navigationTimeMsec_;
    /**
     * <pre>
     * Relative time of navigation for this Source, as seen by the client, and is
     * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
     * related to this Source will generally be relative to this timestamp. The
     * recorded navigation time is in TimeTicks, which is the relative time since
     * the origin. The origin is platform-specific but is guaranteed to be
     * monotonically increase within each session.
     * </pre>
     *
     * <code>optional int64 navigation_time_msec = 3;</code>
     * @return Whether the navigationTimeMsec field is set.
     */
    @java.lang.Override
    public boolean hasNavigationTimeMsec() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Relative time of navigation for this Source, as seen by the client, and is
     * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
     * related to this Source will generally be relative to this timestamp. The
     * recorded navigation time is in TimeTicks, which is the relative time since
     * the origin. The origin is platform-specific but is guaranteed to be
     * monotonically increase within each session.
     * </pre>
     *
     * <code>optional int64 navigation_time_msec = 3;</code>
     * @return The navigationTimeMsec.
     */
    @java.lang.Override
    public long getNavigationTimeMsec() {
      return navigationTimeMsec_;
    }
    /**
     * <pre>
     * Relative time of navigation for this Source, as seen by the client, and is
     * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
     * related to this Source will generally be relative to this timestamp. The
     * recorded navigation time is in TimeTicks, which is the relative time since
     * the origin. The origin is platform-specific but is guaranteed to be
     * monotonically increase within each session.
     * </pre>
     *
     * <code>optional int64 navigation_time_msec = 3;</code>
     * @param value The navigationTimeMsec to set.
     */
    private void setNavigationTimeMsec(long value) {
      bitField0_ |= 0x00000200;
      navigationTimeMsec_ = value;
    }
    /**
     * <pre>
     * Relative time of navigation for this Source, as seen by the client, and is
     * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
     * related to this Source will generally be relative to this timestamp. The
     * recorded navigation time is in TimeTicks, which is the relative time since
     * the origin. The origin is platform-specific but is guaranteed to be
     * monotonically increase within each session.
     * </pre>
     *
     * <code>optional int64 navigation_time_msec = 3;</code>
     */
    private void clearNavigationTimeMsec() {
      bitField0_ = (bitField0_ & ~0x00000200);
      navigationTimeMsec_ = 0L;
    }

    public static final int TAB_ID_FIELD_NUMBER = 10;
    private long tabId_;
    /**
     * <pre>
     * Unique identifier (for a given client_id/session_id) for the tab this
     * source is associated with. Should only be set for navigation sources.
     * </pre>
     *
     * <code>optional int64 tab_id = 10;</code>
     * @return Whether the tabId field is set.
     */
    @java.lang.Override
    public boolean hasTabId() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Unique identifier (for a given client_id/session_id) for the tab this
     * source is associated with. Should only be set for navigation sources.
     * </pre>
     *
     * <code>optional int64 tab_id = 10;</code>
     * @return The tabId.
     */
    @java.lang.Override
    public long getTabId() {
      return tabId_;
    }
    /**
     * <pre>
     * Unique identifier (for a given client_id/session_id) for the tab this
     * source is associated with. Should only be set for navigation sources.
     * </pre>
     *
     * <code>optional int64 tab_id = 10;</code>
     * @param value The tabId to set.
     */
    private void setTabId(long value) {
      bitField0_ |= 0x00000400;
      tabId_ = value;
    }
    /**
     * <pre>
     * Unique identifier (for a given client_id/session_id) for the tab this
     * source is associated with. Should only be set for navigation sources.
     * </pre>
     *
     * <code>optional int64 tab_id = 10;</code>
     */
    private void clearTabId() {
      bitField0_ = (bitField0_ & ~0x00000400);
      tabId_ = 0L;
    }

    public static final int FIRST_CONTENTFUL_PAINT_MSEC_FIELD_NUMBER = 4;
    private long firstContentfulPaintMsec_;
    /**
     * <pre>
     * Time between navigation and the first contentful paint, in milliseconds.
     * Deprecated. Use ukm::Entry instead.
     * </pre>
     *
     * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
     * @return Whether the firstContentfulPaintMsec field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasFirstContentfulPaintMsec() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Time between navigation and the first contentful paint, in milliseconds.
     * Deprecated. Use ukm::Entry instead.
     * </pre>
     *
     * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
     * @return The firstContentfulPaintMsec.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getFirstContentfulPaintMsec() {
      return firstContentfulPaintMsec_;
    }
    /**
     * <pre>
     * Time between navigation and the first contentful paint, in milliseconds.
     * Deprecated. Use ukm::Entry instead.
     * </pre>
     *
     * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
     * @param value The firstContentfulPaintMsec to set.
     */
    private void setFirstContentfulPaintMsec(long value) {
      bitField0_ |= 0x00000800;
      firstContentfulPaintMsec_ = value;
    }
    /**
     * <pre>
     * Time between navigation and the first contentful paint, in milliseconds.
     * Deprecated. Use ukm::Entry instead.
     * </pre>
     *
     * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
     */
    private void clearFirstContentfulPaintMsec() {
      bitField0_ = (bitField0_ & ~0x00000800);
      firstContentfulPaintMsec_ = 0L;
    }

    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.SourceOuterClass.Source parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.metrics.SourceOuterClass.Source prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Source contains data related to a top-level navigation.
     * Next tag: 17
     * </pre>
     *
     * Protobuf type {@code ukm.Source}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.metrics.SourceOuterClass.Source, Builder> implements
        // @@protoc_insertion_point(builder_implements:ukm.Source)
        org.chromium.components.metrics.SourceOuterClass.SourceOrBuilder {
      // Construct using org.chromium.components.metrics.SourceOuterClass.Source.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * An identifier for the source. This should be unique within a session.
       * </pre>
       *
       * <code>optional int64 id = 1;</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * An identifier for the source. This should be unique within a session.
       * </pre>
       *
       * <code>optional int64 id = 1;</code>
       * @return The id.
       */
      @java.lang.Override
      public long getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * An identifier for the source. This should be unique within a session.
       * </pre>
       *
       * <code>optional int64 id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(long value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * An identifier for the source. This should be unique within a session.
       * </pre>
       *
       * <code>optional int64 id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }

      /**
       * <pre>
       * The source id of the last committed non-same-document navigation for the
       * tab this source is in. Should only be set for navigation sources. For
       * backward compatibility, this field will never be set to the source id of a
       * same-document source. In cases where the last committed navigation was a
       * same-document navigation, previous_same_document_source_id will contain
       * the source id of that previous same document navigation, while
       * previous_source_id will contain the source id of the last committed
       * non-same-document navigation. For example, if a user starts on page A (a
       * non same document page load), then performs a same document navigation to
       * B, then navigates to C (which could be either a same document or a non same
       * document navigation), previous_source_id will reference A, and
       * previous_same_document_source_id will reference B.
       * </pre>
       *
       * <code>optional int64 previous_source_id = 11;</code>
       * @return Whether the previousSourceId field is set.
       */
      @java.lang.Override
      public boolean hasPreviousSourceId() {
        return instance.hasPreviousSourceId();
      }
      /**
       * <pre>
       * The source id of the last committed non-same-document navigation for the
       * tab this source is in. Should only be set for navigation sources. For
       * backward compatibility, this field will never be set to the source id of a
       * same-document source. In cases where the last committed navigation was a
       * same-document navigation, previous_same_document_source_id will contain
       * the source id of that previous same document navigation, while
       * previous_source_id will contain the source id of the last committed
       * non-same-document navigation. For example, if a user starts on page A (a
       * non same document page load), then performs a same document navigation to
       * B, then navigates to C (which could be either a same document or a non same
       * document navigation), previous_source_id will reference A, and
       * previous_same_document_source_id will reference B.
       * </pre>
       *
       * <code>optional int64 previous_source_id = 11;</code>
       * @return The previousSourceId.
       */
      @java.lang.Override
      public long getPreviousSourceId() {
        return instance.getPreviousSourceId();
      }
      /**
       * <pre>
       * The source id of the last committed non-same-document navigation for the
       * tab this source is in. Should only be set for navigation sources. For
       * backward compatibility, this field will never be set to the source id of a
       * same-document source. In cases where the last committed navigation was a
       * same-document navigation, previous_same_document_source_id will contain
       * the source id of that previous same document navigation, while
       * previous_source_id will contain the source id of the last committed
       * non-same-document navigation. For example, if a user starts on page A (a
       * non same document page load), then performs a same document navigation to
       * B, then navigates to C (which could be either a same document or a non same
       * document navigation), previous_source_id will reference A, and
       * previous_same_document_source_id will reference B.
       * </pre>
       *
       * <code>optional int64 previous_source_id = 11;</code>
       * @param value The previousSourceId to set.
       * @return This builder for chaining.
       */
      public Builder setPreviousSourceId(long value) {
        copyOnWrite();
        instance.setPreviousSourceId(value);
        return this;
      }
      /**
       * <pre>
       * The source id of the last committed non-same-document navigation for the
       * tab this source is in. Should only be set for navigation sources. For
       * backward compatibility, this field will never be set to the source id of a
       * same-document source. In cases where the last committed navigation was a
       * same-document navigation, previous_same_document_source_id will contain
       * the source id of that previous same document navigation, while
       * previous_source_id will contain the source id of the last committed
       * non-same-document navigation. For example, if a user starts on page A (a
       * non same document page load), then performs a same document navigation to
       * B, then navigates to C (which could be either a same document or a non same
       * document navigation), previous_source_id will reference A, and
       * previous_same_document_source_id will reference B.
       * </pre>
       *
       * <code>optional int64 previous_source_id = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreviousSourceId() {
        copyOnWrite();
        instance.clearPreviousSourceId();
        return this;
      }

      /**
       * <pre>
       * The source id for the previous same document navigation, if the
       * previously committed source was a same document navigation. If
       * the previously committed source was not a same document
       * navigation, this field will be unset.
       * </pre>
       *
       * <code>optional int64 previous_same_document_source_id = 14;</code>
       * @return Whether the previousSameDocumentSourceId field is set.
       */
      @java.lang.Override
      public boolean hasPreviousSameDocumentSourceId() {
        return instance.hasPreviousSameDocumentSourceId();
      }
      /**
       * <pre>
       * The source id for the previous same document navigation, if the
       * previously committed source was a same document navigation. If
       * the previously committed source was not a same document
       * navigation, this field will be unset.
       * </pre>
       *
       * <code>optional int64 previous_same_document_source_id = 14;</code>
       * @return The previousSameDocumentSourceId.
       */
      @java.lang.Override
      public long getPreviousSameDocumentSourceId() {
        return instance.getPreviousSameDocumentSourceId();
      }
      /**
       * <pre>
       * The source id for the previous same document navigation, if the
       * previously committed source was a same document navigation. If
       * the previously committed source was not a same document
       * navigation, this field will be unset.
       * </pre>
       *
       * <code>optional int64 previous_same_document_source_id = 14;</code>
       * @param value The previousSameDocumentSourceId to set.
       * @return This builder for chaining.
       */
      public Builder setPreviousSameDocumentSourceId(long value) {
        copyOnWrite();
        instance.setPreviousSameDocumentSourceId(value);
        return this;
      }
      /**
       * <pre>
       * The source id for the previous same document navigation, if the
       * previously committed source was a same document navigation. If
       * the previously committed source was not a same document
       * navigation, this field will be unset.
       * </pre>
       *
       * <code>optional int64 previous_same_document_source_id = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreviousSameDocumentSourceId() {
        copyOnWrite();
        instance.clearPreviousSameDocumentSourceId();
        return this;
      }

      /**
       * <pre>
       * For sources representing the first navigation in a new tab, this id marks
       * the source which opened the tab. Should only be set for the first
       * navigation source in a tab.
       * </pre>
       *
       * <code>optional int64 opener_source_id = 12;</code>
       * @return Whether the openerSourceId field is set.
       */
      @java.lang.Override
      public boolean hasOpenerSourceId() {
        return instance.hasOpenerSourceId();
      }
      /**
       * <pre>
       * For sources representing the first navigation in a new tab, this id marks
       * the source which opened the tab. Should only be set for the first
       * navigation source in a tab.
       * </pre>
       *
       * <code>optional int64 opener_source_id = 12;</code>
       * @return The openerSourceId.
       */
      @java.lang.Override
      public long getOpenerSourceId() {
        return instance.getOpenerSourceId();
      }
      /**
       * <pre>
       * For sources representing the first navigation in a new tab, this id marks
       * the source which opened the tab. Should only be set for the first
       * navigation source in a tab.
       * </pre>
       *
       * <code>optional int64 opener_source_id = 12;</code>
       * @param value The openerSourceId to set.
       * @return This builder for chaining.
       */
      public Builder setOpenerSourceId(long value) {
        copyOnWrite();
        instance.setOpenerSourceId(value);
        return this;
      }
      /**
       * <pre>
       * For sources representing the first navigation in a new tab, this id marks
       * the source which opened the tab. Should only be set for the first
       * navigation source in a tab.
       * </pre>
       *
       * <code>optional int64 opener_source_id = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearOpenerSourceId() {
        copyOnWrite();
        instance.clearOpenerSourceId();
        return this;
      }

      /**
       * <pre>
       * Type of the source id.
       * </pre>
       *
       * <code>optional .ukm.SourceType type = 16;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <pre>
       * Type of the source id.
       * </pre>
       *
       * <code>optional .ukm.SourceType type = 16;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.chromium.components.metrics.SourceOuterClass.SourceType getType() {
        return instance.getType();
      }
      /**
       * <pre>
       * Type of the source id.
       * </pre>
       *
       * <code>optional .ukm.SourceType type = 16;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.chromium.components.metrics.SourceOuterClass.SourceType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <pre>
       * Type of the source id.
       * </pre>
       *
       * <code>optional .ukm.SourceType type = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> getUrlsList() {
        return java.util.Collections.unmodifiableList(
            instance.getUrlsList());
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      @java.lang.Override
      public int getUrlsCount() {
        return instance.getUrlsCount();
      }/**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getUrls(int index) {
        return instance.getUrls(index);
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder setUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
        copyOnWrite();
        instance.setUrls(index, value);
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder setUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setUrls(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder addUrls(org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
        copyOnWrite();
        instance.addUrls(value);
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder addUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
        copyOnWrite();
        instance.addUrls(index, value);
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder addUrls(
          org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addUrls(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder addUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addUrls(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder addAllUrls(
          java.lang.Iterable<? extends org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> values) {
        copyOnWrite();
        instance.addAllUrls(values);
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder clearUrls() {
        copyOnWrite();
        instance.clearUrls();
        return this;
      }
      /**
       * <pre>
       * Data about each URL associated with the source_id within the record's
       * scope, in the order that the URLs were encountered. Data may include full
       * or partial redirect chains for main frame navigations.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo urls = 8;</code>
       */
      public Builder removeUrls(int index) {
        copyOnWrite();
        instance.removeUrls(index);
        return this;
      }

      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> getResolvedUrlsList() {
        return java.util.Collections.unmodifiableList(
            instance.getResolvedUrlsList());
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      @java.lang.Override
      public int getResolvedUrlsCount() {
        return instance.getResolvedUrlsCount();
      }/**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo getResolvedUrls(int index) {
        return instance.getResolvedUrls(index);
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder setResolvedUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
        copyOnWrite();
        instance.setResolvedUrls(index, value);
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder setResolvedUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setResolvedUrls(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder addResolvedUrls(org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
        copyOnWrite();
        instance.addResolvedUrls(value);
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder addResolvedUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo value) {
        copyOnWrite();
        instance.addResolvedUrls(index, value);
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder addResolvedUrls(
          org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addResolvedUrls(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder addResolvedUrls(
          int index, org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addResolvedUrls(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder addAllResolvedUrls(
          java.lang.Iterable<? extends org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo> values) {
        copyOnWrite();
        instance.addAllResolvedUrls(values);
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder clearResolvedUrls() {
        copyOnWrite();
        instance.clearResolvedUrls();
        return this;
      }
      /**
       * <pre>
       * Data about the URL of the Document, copied from the Source message whose
       * id matched the navigation source id of the DocumentCreated event.
       * </pre>
       *
       * <code>repeated .ukm.Source.UrlInfo resolved_urls = 15;</code>
       */
      public Builder removeResolvedUrls(int index) {
        copyOnWrite();
        instance.removeResolvedUrls(index);
        return this;
      }

      /**
       * <pre>
       * Whether this source is for a same document navigation. Examples of same
       * document navigations are fragment navigations, pushState/replaceState,
       * and same page history navigation.
       * </pre>
       *
       * <code>optional bool is_same_document_navigation = 13;</code>
       * @return Whether the isSameDocumentNavigation field is set.
       */
      @java.lang.Override
      public boolean hasIsSameDocumentNavigation() {
        return instance.hasIsSameDocumentNavigation();
      }
      /**
       * <pre>
       * Whether this source is for a same document navigation. Examples of same
       * document navigations are fragment navigations, pushState/replaceState,
       * and same page history navigation.
       * </pre>
       *
       * <code>optional bool is_same_document_navigation = 13;</code>
       * @return The isSameDocumentNavigation.
       */
      @java.lang.Override
      public boolean getIsSameDocumentNavigation() {
        return instance.getIsSameDocumentNavigation();
      }
      /**
       * <pre>
       * Whether this source is for a same document navigation. Examples of same
       * document navigations are fragment navigations, pushState/replaceState,
       * and same page history navigation.
       * </pre>
       *
       * <code>optional bool is_same_document_navigation = 13;</code>
       * @param value The isSameDocumentNavigation to set.
       * @return This builder for chaining.
       */
      public Builder setIsSameDocumentNavigation(boolean value) {
        copyOnWrite();
        instance.setIsSameDocumentNavigation(value);
        return this;
      }
      /**
       * <pre>
       * Whether this source is for a same document navigation. Examples of same
       * document navigations are fragment navigations, pushState/replaceState,
       * and same page history navigation.
       * </pre>
       *
       * <code>optional bool is_same_document_navigation = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsSameDocumentNavigation() {
        copyOnWrite();
        instance.clearIsSameDocumentNavigation();
        return this;
      }

      /**
       * <pre>
       * The URL of the source, as recorded in history. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string url = 2;</code>
       * @return Whether the url field is set.
       */
      @java.lang.Override
      public boolean hasUrl() {
        return instance.hasUrl();
      }
      /**
       * <pre>
       * The URL of the source, as recorded in history. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string url = 2;</code>
       * @return The url.
       */
      @java.lang.Override
      public java.lang.String getUrl() {
        return instance.getUrl();
      }
      /**
       * <pre>
       * The URL of the source, as recorded in history. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string url = 2;</code>
       * @return The bytes for url.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUrlBytes() {
        return instance.getUrlBytes();
      }
      /**
       * <pre>
       * The URL of the source, as recorded in history. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string url = 2;</code>
       * @param value The url to set.
       * @return This builder for chaining.
       */
      public Builder setUrl(
          java.lang.String value) {
        copyOnWrite();
        instance.setUrl(value);
        return this;
      }
      /**
       * <pre>
       * The URL of the source, as recorded in history. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string url = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearUrl() {
        copyOnWrite();
        instance.clearUrl();
        return this;
      }
      /**
       * <pre>
       * The URL of the source, as recorded in history. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string url = 2;</code>
       * @param value The bytes for url to set.
       * @return This builder for chaining.
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUrlBytes(value);
        return this;
      }

      /**
       * <pre>
       * The initial URL of the source. Set in cases where the source URL changed
       * (e.g. it was redirected), otherwise unset. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string initial_url = 6;</code>
       * @return Whether the initialUrl field is set.
       */
      @java.lang.Override
      public boolean hasInitialUrl() {
        return instance.hasInitialUrl();
      }
      /**
       * <pre>
       * The initial URL of the source. Set in cases where the source URL changed
       * (e.g. it was redirected), otherwise unset. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string initial_url = 6;</code>
       * @return The initialUrl.
       */
      @java.lang.Override
      public java.lang.String getInitialUrl() {
        return instance.getInitialUrl();
      }
      /**
       * <pre>
       * The initial URL of the source. Set in cases where the source URL changed
       * (e.g. it was redirected), otherwise unset. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string initial_url = 6;</code>
       * @return The bytes for initialUrl.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getInitialUrlBytes() {
        return instance.getInitialUrlBytes();
      }
      /**
       * <pre>
       * The initial URL of the source. Set in cases where the source URL changed
       * (e.g. it was redirected), otherwise unset. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string initial_url = 6;</code>
       * @param value The initialUrl to set.
       * @return This builder for chaining.
       */
      public Builder setInitialUrl(
          java.lang.String value) {
        copyOnWrite();
        instance.setInitialUrl(value);
        return this;
      }
      /**
       * <pre>
       * The initial URL of the source. Set in cases where the source URL changed
       * (e.g. it was redirected), otherwise unset. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string initial_url = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearInitialUrl() {
        copyOnWrite();
        instance.clearInitialUrl();
        return this;
      }
      /**
       * <pre>
       * The initial URL of the source. Set in cases where the source URL changed
       * (e.g. it was redirected), otherwise unset. If this URL has not been
       * discovered by Google's crawler, it should not be recorded.
       * </pre>
       *
       * <code>optional string initial_url = 6;</code>
       * @param value The bytes for initialUrl to set.
       * @return This builder for chaining.
       */
      public Builder setInitialUrlBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInitialUrlBytes(value);
        return this;
      }

      /**
       * <pre>
       * Flag indicating if the metric was collected while inside a "custom tab".
       * </pre>
       *
       * <code>optional bool is_custom_tab = 7;</code>
       * @return Whether the isCustomTab field is set.
       */
      @java.lang.Override
      public boolean hasIsCustomTab() {
        return instance.hasIsCustomTab();
      }
      /**
       * <pre>
       * Flag indicating if the metric was collected while inside a "custom tab".
       * </pre>
       *
       * <code>optional bool is_custom_tab = 7;</code>
       * @return The isCustomTab.
       */
      @java.lang.Override
      public boolean getIsCustomTab() {
        return instance.getIsCustomTab();
      }
      /**
       * <pre>
       * Flag indicating if the metric was collected while inside a "custom tab".
       * </pre>
       *
       * <code>optional bool is_custom_tab = 7;</code>
       * @param value The isCustomTab to set.
       * @return This builder for chaining.
       */
      public Builder setIsCustomTab(boolean value) {
        copyOnWrite();
        instance.setIsCustomTab(value);
        return this;
      }
      /**
       * <pre>
       * Flag indicating if the metric was collected while inside a "custom tab".
       * </pre>
       *
       * <code>optional bool is_custom_tab = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsCustomTab() {
        copyOnWrite();
        instance.clearIsCustomTab();
        return this;
      }

      /**
       * <pre>
       * Relative time of navigation for this Source, as seen by the client, and is
       * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
       * related to this Source will generally be relative to this timestamp. The
       * recorded navigation time is in TimeTicks, which is the relative time since
       * the origin. The origin is platform-specific but is guaranteed to be
       * monotonically increase within each session.
       * </pre>
       *
       * <code>optional int64 navigation_time_msec = 3;</code>
       * @return Whether the navigationTimeMsec field is set.
       */
      @java.lang.Override
      public boolean hasNavigationTimeMsec() {
        return instance.hasNavigationTimeMsec();
      }
      /**
       * <pre>
       * Relative time of navigation for this Source, as seen by the client, and is
       * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
       * related to this Source will generally be relative to this timestamp. The
       * recorded navigation time is in TimeTicks, which is the relative time since
       * the origin. The origin is platform-specific but is guaranteed to be
       * monotonically increase within each session.
       * </pre>
       *
       * <code>optional int64 navigation_time_msec = 3;</code>
       * @return The navigationTimeMsec.
       */
      @java.lang.Override
      public long getNavigationTimeMsec() {
        return instance.getNavigationTimeMsec();
      }
      /**
       * <pre>
       * Relative time of navigation for this Source, as seen by the client, and is
       * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
       * related to this Source will generally be relative to this timestamp. The
       * recorded navigation time is in TimeTicks, which is the relative time since
       * the origin. The origin is platform-specific but is guaranteed to be
       * monotonically increase within each session.
       * </pre>
       *
       * <code>optional int64 navigation_time_msec = 3;</code>
       * @param value The navigationTimeMsec to set.
       * @return This builder for chaining.
       */
      public Builder setNavigationTimeMsec(long value) {
        copyOnWrite();
        instance.setNavigationTimeMsec(value);
        return this;
      }
      /**
       * <pre>
       * Relative time of navigation for this Source, as seen by the client, and is
       * set for sources of type ukm::SourceIdType::NAVIGATION_ID. Time of events
       * related to this Source will generally be relative to this timestamp. The
       * recorded navigation time is in TimeTicks, which is the relative time since
       * the origin. The origin is platform-specific but is guaranteed to be
       * monotonically increase within each session.
       * </pre>
       *
       * <code>optional int64 navigation_time_msec = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNavigationTimeMsec() {
        copyOnWrite();
        instance.clearNavigationTimeMsec();
        return this;
      }

      /**
       * <pre>
       * Unique identifier (for a given client_id/session_id) for the tab this
       * source is associated with. Should only be set for navigation sources.
       * </pre>
       *
       * <code>optional int64 tab_id = 10;</code>
       * @return Whether the tabId field is set.
       */
      @java.lang.Override
      public boolean hasTabId() {
        return instance.hasTabId();
      }
      /**
       * <pre>
       * Unique identifier (for a given client_id/session_id) for the tab this
       * source is associated with. Should only be set for navigation sources.
       * </pre>
       *
       * <code>optional int64 tab_id = 10;</code>
       * @return The tabId.
       */
      @java.lang.Override
      public long getTabId() {
        return instance.getTabId();
      }
      /**
       * <pre>
       * Unique identifier (for a given client_id/session_id) for the tab this
       * source is associated with. Should only be set for navigation sources.
       * </pre>
       *
       * <code>optional int64 tab_id = 10;</code>
       * @param value The tabId to set.
       * @return This builder for chaining.
       */
      public Builder setTabId(long value) {
        copyOnWrite();
        instance.setTabId(value);
        return this;
      }
      /**
       * <pre>
       * Unique identifier (for a given client_id/session_id) for the tab this
       * source is associated with. Should only be set for navigation sources.
       * </pre>
       *
       * <code>optional int64 tab_id = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearTabId() {
        copyOnWrite();
        instance.clearTabId();
        return this;
      }

      /**
       * <pre>
       * Time between navigation and the first contentful paint, in milliseconds.
       * Deprecated. Use ukm::Entry instead.
       * </pre>
       *
       * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
       * @return Whether the firstContentfulPaintMsec field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasFirstContentfulPaintMsec() {
        return instance.hasFirstContentfulPaintMsec();
      }
      /**
       * <pre>
       * Time between navigation and the first contentful paint, in milliseconds.
       * Deprecated. Use ukm::Entry instead.
       * </pre>
       *
       * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
       * @return The firstContentfulPaintMsec.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getFirstContentfulPaintMsec() {
        return instance.getFirstContentfulPaintMsec();
      }
      /**
       * <pre>
       * Time between navigation and the first contentful paint, in milliseconds.
       * Deprecated. Use ukm::Entry instead.
       * </pre>
       *
       * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
       * @param value The firstContentfulPaintMsec to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setFirstContentfulPaintMsec(long value) {
        copyOnWrite();
        instance.setFirstContentfulPaintMsec(value);
        return this;
      }
      /**
       * <pre>
       * Time between navigation and the first contentful paint, in milliseconds.
       * Deprecated. Use ukm::Entry instead.
       * </pre>
       *
       * <code>optional int64 first_contentful_paint_msec = 4 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearFirstContentfulPaintMsec() {
        copyOnWrite();
        instance.clearFirstContentfulPaintMsec();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:ukm.Source)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.metrics.SourceOuterClass.Source();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "id_",
              "url_",
              "navigationTimeMsec_",
              "firstContentfulPaintMsec_",
              "initialUrl_",
              "isCustomTab_",
              "urls_",
              org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.class,
              "tabId_",
              "previousSourceId_",
              "openerSourceId_",
              "isSameDocumentNavigation_",
              "previousSameDocumentSourceId_",
              "resolvedUrls_",
              org.chromium.components.metrics.SourceOuterClass.Source.UrlInfo.class,
              "type_",
              org.chromium.components.metrics.SourceOuterClass.SourceType.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u000e\u0000\u0001\u0001\u0010\u000e\u0000\u0002\u0000\u0001\u1002\u0000\u0002" +
                "\u1008\u0006\u0003\u1002\t\u0004\u1002\u000b\u0006\u1008\u0007\u0007\u1007\b\b\u001b" +
                "\n\u1002\n\u000b\u1002\u0001\f\u1002\u0003\r\u1007\u0005\u000e\u1002\u0002\u000f" +
                "\u001b\u0010\u100c\u0004";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.metrics.SourceOuterClass.Source> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.metrics.SourceOuterClass.Source.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.metrics.SourceOuterClass.Source>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:ukm.Source)
    private static final org.chromium.components.metrics.SourceOuterClass.Source DEFAULT_INSTANCE;
    static {
      Source defaultInstance = new Source();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Source.class, defaultInstance);
    }

    public static org.chromium.components.metrics.SourceOuterClass.Source getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Source> PARSER;

    public static com.google.protobuf.Parser<Source> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
