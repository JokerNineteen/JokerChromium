// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: memory_leak_report.proto

package org.chromium.components.metrics;

public final class MemoryLeakReport {
  private MemoryLeakReport() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface MemoryLeakReportProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:metrics.MemoryLeakReportProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @return A list containing the callStack.
     */
    java.util.List<java.lang.Long> getCallStackList();
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @return The count of callStack.
     */
    int getCallStackCount();
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @param index The index of the element to return.
     * @return The callStack at the given index.
     */
    long getCallStack(int index);

    /**
     * <pre>
     * Size of the memory allocation involved in the leak.
     * </pre>
     *
     * <code>optional uint32 size_bytes = 2;</code>
     * @return Whether the sizeBytes field is set.
     */
    boolean hasSizeBytes();
    /**
     * <pre>
     * Size of the memory allocation involved in the leak.
     * </pre>
     *
     * <code>optional uint32 size_bytes = 2;</code>
     * @return The sizeBytes.
     */
    int getSizeBytes();

    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     * @return Whether the params field is set.
     */
    boolean hasParams();
    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     * @return The params.
     */
    org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params getParams();

    /**
     * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
     * @return Whether the sourceProcess field is set.
     */
    boolean hasSourceProcess();
    /**
     * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
     * @return The sourceProcess.
     */
    org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType getSourceProcess();

    /**
     * <pre>
     * The build ID of the Chrome binary from which this leak report was obtained.
     * The build ID is typically a 16- or 20-byte hash that is generated by the
     * compiler that built the binary. This value will be read directly from the
     * GNU build notes section of the Chrome binary.
     * </pre>
     *
     * <code>optional bytes build_id = 6;</code>
     * @return Whether the buildId field is set.
     */
    boolean hasBuildId();
    /**
     * <pre>
     * The build ID of the Chrome binary from which this leak report was obtained.
     * The build ID is typically a 16- or 20-byte hash that is generated by the
     * compiler that built the binary. This value will be read directly from the
     * GNU build notes section of the Chrome binary.
     * </pre>
     *
     * <code>optional bytes build_id = 6;</code>
     * @return The buildId.
     */
    com.google.protobuf.ByteString getBuildId();

    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    java.util.List<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> 
        getAllocBreakdownHistoryList();
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown getAllocBreakdownHistory(int index);
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    int getAllocBreakdownHistoryCount();

    /**
     * <pre>
     * The following two fields describe the last increasing trend in the number
     * of allocations from the size and call stack that generated this
     * leak report.
     * |num_rising_intervals| equals timeslot_now - timeslot_drop,
     * where timeslot_drop is the timeslot number of the last frame that saw
     * a drop in the number of allocations, or the first frame in the history
     * if there were no drops (history is cleared when the net number of
     * allocations hits 0).
     * If it is &lt; 32, it will be visible in the allocation history graph.
     * If it is &gt;= 32, it will not be seen in the graph.
     * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
     * </pre>
     *
     * <code>optional uint32 num_rising_intervals = 7;</code>
     * @return Whether the numRisingIntervals field is set.
     */
    boolean hasNumRisingIntervals();
    /**
     * <pre>
     * The following two fields describe the last increasing trend in the number
     * of allocations from the size and call stack that generated this
     * leak report.
     * |num_rising_intervals| equals timeslot_now - timeslot_drop,
     * where timeslot_drop is the timeslot number of the last frame that saw
     * a drop in the number of allocations, or the first frame in the history
     * if there were no drops (history is cleared when the net number of
     * allocations hits 0).
     * If it is &lt; 32, it will be visible in the allocation history graph.
     * If it is &gt;= 32, it will not be seen in the graph.
     * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
     * </pre>
     *
     * <code>optional uint32 num_rising_intervals = 7;</code>
     * @return The numRisingIntervals.
     */
    int getNumRisingIntervals();

    /**
     * <pre>
     * Indicates the magnitude of the current uptrend in allocations.
     * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
     * </pre>
     *
     * <code>optional uint32 num_allocs_increase = 8;</code>
     * @return Whether the numAllocsIncrease field is set.
     */
    boolean hasNumAllocsIncrease();
    /**
     * <pre>
     * Indicates the magnitude of the current uptrend in allocations.
     * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
     * </pre>
     *
     * <code>optional uint32 num_allocs_increase = 8;</code>
     * @return The numAllocsIncrease.
     */
    int getNumAllocsIncrease();

    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     * @return Whether the memoryUsageInfo field is set.
     */
    boolean hasMemoryUsageInfo();
    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     * @return The memoryUsageInfo.
     */
    org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo getMemoryUsageInfo();
  }
  /**
   * <pre>
   * Next tag: 10
   * </pre>
   *
   * Protobuf type {@code metrics.MemoryLeakReportProto}
   */
  public  static final class MemoryLeakReportProto extends
      com.google.protobuf.GeneratedMessageLite<
          MemoryLeakReportProto, MemoryLeakReportProto.Builder> implements
      // @@protoc_insertion_point(message_implements:metrics.MemoryLeakReportProto)
      MemoryLeakReportProtoOrBuilder {
    private MemoryLeakReportProto() {
      callStack_ = emptyLongList();
      buildId_ = com.google.protobuf.ByteString.EMPTY;
      allocBreakdownHistory_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The type of Chrome process on which this leak report was generated.
     * </pre>
     *
     * Protobuf enum {@code metrics.MemoryLeakReportProto.ProcessType}
     */
    public enum ProcessType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNKNOWN_PROCESS = 0;</code>
       */
      UNKNOWN_PROCESS(0),
      /**
       * <code>BROWSER_PROCESS = 1;</code>
       */
      BROWSER_PROCESS(1),
      /**
       * <code>RENDERER_PROCESS = 2;</code>
       */
      RENDERER_PROCESS(2),
      ;

      /**
       * <code>UNKNOWN_PROCESS = 0;</code>
       */
      public static final int UNKNOWN_PROCESS_VALUE = 0;
      /**
       * <code>BROWSER_PROCESS = 1;</code>
       */
      public static final int BROWSER_PROCESS_VALUE = 1;
      /**
       * <code>RENDERER_PROCESS = 2;</code>
       */
      public static final int RENDERER_PROCESS_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ProcessType valueOf(int value) {
        return forNumber(value);
      }

      public static ProcessType forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_PROCESS;
          case 1: return BROWSER_PROCESS;
          case 2: return RENDERER_PROCESS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ProcessType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ProcessType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ProcessType>() {
              @java.lang.Override
              public ProcessType findValueByNumber(int number) {
                return ProcessType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ProcessTypeVerifier.INSTANCE;
      }

      private static final class ProcessTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ProcessTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ProcessType.forNumber(number) != null;
              }
            };

      private final int value;

      private ProcessType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.MemoryLeakReportProto.ProcessType)
    }

    public interface ParamsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:metrics.MemoryLeakReportProto.Params)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The rate at which allocations are pseudorandomly sampled. Ranges from 0
       * to 1. A rate of 1 means all incoming allocations are sampled by the leak
       * detector, which is the maximum possible.
       * </pre>
       *
       * <code>optional float sampling_rate = 1;</code>
       * @return Whether the samplingRate field is set.
       */
      boolean hasSamplingRate();
      /**
       * <pre>
       * The rate at which allocations are pseudorandomly sampled. Ranges from 0
       * to 1. A rate of 1 means all incoming allocations are sampled by the leak
       * detector, which is the maximum possible.
       * </pre>
       *
       * <code>optional float sampling_rate = 1;</code>
       * @return The samplingRate.
       */
      float getSamplingRate();

      /**
       * <pre>
       * The max depth to which the call stacks were unwound by the leak detector.
       * This may be greater than the size of |call_stack|.
       * </pre>
       *
       * <code>optional uint32 max_stack_depth = 2;</code>
       * @return Whether the maxStackDepth field is set.
       */
      boolean hasMaxStackDepth();
      /**
       * <pre>
       * The max depth to which the call stacks were unwound by the leak detector.
       * This may be greater than the size of |call_stack|.
       * </pre>
       *
       * <code>optional uint32 max_stack_depth = 2;</code>
       * @return The maxStackDepth.
       */
      int getMaxStackDepth();

      /**
       * <pre>
       * The leak analysis takes place every so often, with an interval based on
       * the number of bytes allocated. This is independent of the sampling rate
       * as it is computed from allocation sizes before sampling.
       * </pre>
       *
       * <code>optional uint64 analysis_interval_bytes = 3;</code>
       * @return Whether the analysisIntervalBytes field is set.
       */
      boolean hasAnalysisIntervalBytes();
      /**
       * <pre>
       * The leak analysis takes place every so often, with an interval based on
       * the number of bytes allocated. This is independent of the sampling rate
       * as it is computed from allocation sizes before sampling.
       * </pre>
       *
       * <code>optional uint64 analysis_interval_bytes = 3;</code>
       * @return The analysisIntervalBytes.
       */
      long getAnalysisIntervalBytes();

      /**
       * <pre>
       * Suspicion thresholds used in leak analysis for size and call stacks,
       * respectively. If an allocation size or call stack is suspected this many
       * times in a row, the leak analysis escalates to the next level. For
       * allocation sizes, the next level is to start analyzing by call stack. For
       * call stacks, the next level is to generate a memory leak report.
       * </pre>
       *
       * <code>optional uint32 size_suspicion_threshold = 4;</code>
       * @return Whether the sizeSuspicionThreshold field is set.
       */
      boolean hasSizeSuspicionThreshold();
      /**
       * <pre>
       * Suspicion thresholds used in leak analysis for size and call stacks,
       * respectively. If an allocation size or call stack is suspected this many
       * times in a row, the leak analysis escalates to the next level. For
       * allocation sizes, the next level is to start analyzing by call stack. For
       * call stacks, the next level is to generate a memory leak report.
       * </pre>
       *
       * <code>optional uint32 size_suspicion_threshold = 4;</code>
       * @return The sizeSuspicionThreshold.
       */
      int getSizeSuspicionThreshold();

      /**
       * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
       * @return Whether the callStackSuspicionThreshold field is set.
       */
      boolean hasCallStackSuspicionThreshold();
      /**
       * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
       * @return The callStackSuspicionThreshold.
       */
      int getCallStackSuspicionThreshold();
    }
    /**
     * <pre>
     * Contains all parameters passed to the leak detector during initialization.
     * Since these are known at the beginning, this message can be stored locally
     * and then added to generated memory leak report protobufs.
     * Next tag: 6
     * </pre>
     *
     * Protobuf type {@code metrics.MemoryLeakReportProto.Params}
     */
    public  static final class Params extends
        com.google.protobuf.GeneratedMessageLite<
            Params, Params.Builder> implements
        // @@protoc_insertion_point(message_implements:metrics.MemoryLeakReportProto.Params)
        ParamsOrBuilder {
      private Params() {
      }
      private int bitField0_;
      public static final int SAMPLING_RATE_FIELD_NUMBER = 1;
      private float samplingRate_;
      /**
       * <pre>
       * The rate at which allocations are pseudorandomly sampled. Ranges from 0
       * to 1. A rate of 1 means all incoming allocations are sampled by the leak
       * detector, which is the maximum possible.
       * </pre>
       *
       * <code>optional float sampling_rate = 1;</code>
       * @return Whether the samplingRate field is set.
       */
      @java.lang.Override
      public boolean hasSamplingRate() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The rate at which allocations are pseudorandomly sampled. Ranges from 0
       * to 1. A rate of 1 means all incoming allocations are sampled by the leak
       * detector, which is the maximum possible.
       * </pre>
       *
       * <code>optional float sampling_rate = 1;</code>
       * @return The samplingRate.
       */
      @java.lang.Override
      public float getSamplingRate() {
        return samplingRate_;
      }
      /**
       * <pre>
       * The rate at which allocations are pseudorandomly sampled. Ranges from 0
       * to 1. A rate of 1 means all incoming allocations are sampled by the leak
       * detector, which is the maximum possible.
       * </pre>
       *
       * <code>optional float sampling_rate = 1;</code>
       * @param value The samplingRate to set.
       */
      private void setSamplingRate(float value) {
        bitField0_ |= 0x00000001;
        samplingRate_ = value;
      }
      /**
       * <pre>
       * The rate at which allocations are pseudorandomly sampled. Ranges from 0
       * to 1. A rate of 1 means all incoming allocations are sampled by the leak
       * detector, which is the maximum possible.
       * </pre>
       *
       * <code>optional float sampling_rate = 1;</code>
       */
      private void clearSamplingRate() {
        bitField0_ = (bitField0_ & ~0x00000001);
        samplingRate_ = 0F;
      }

      public static final int MAX_STACK_DEPTH_FIELD_NUMBER = 2;
      private int maxStackDepth_;
      /**
       * <pre>
       * The max depth to which the call stacks were unwound by the leak detector.
       * This may be greater than the size of |call_stack|.
       * </pre>
       *
       * <code>optional uint32 max_stack_depth = 2;</code>
       * @return Whether the maxStackDepth field is set.
       */
      @java.lang.Override
      public boolean hasMaxStackDepth() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The max depth to which the call stacks were unwound by the leak detector.
       * This may be greater than the size of |call_stack|.
       * </pre>
       *
       * <code>optional uint32 max_stack_depth = 2;</code>
       * @return The maxStackDepth.
       */
      @java.lang.Override
      public int getMaxStackDepth() {
        return maxStackDepth_;
      }
      /**
       * <pre>
       * The max depth to which the call stacks were unwound by the leak detector.
       * This may be greater than the size of |call_stack|.
       * </pre>
       *
       * <code>optional uint32 max_stack_depth = 2;</code>
       * @param value The maxStackDepth to set.
       */
      private void setMaxStackDepth(int value) {
        bitField0_ |= 0x00000002;
        maxStackDepth_ = value;
      }
      /**
       * <pre>
       * The max depth to which the call stacks were unwound by the leak detector.
       * This may be greater than the size of |call_stack|.
       * </pre>
       *
       * <code>optional uint32 max_stack_depth = 2;</code>
       */
      private void clearMaxStackDepth() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxStackDepth_ = 0;
      }

      public static final int ANALYSIS_INTERVAL_BYTES_FIELD_NUMBER = 3;
      private long analysisIntervalBytes_;
      /**
       * <pre>
       * The leak analysis takes place every so often, with an interval based on
       * the number of bytes allocated. This is independent of the sampling rate
       * as it is computed from allocation sizes before sampling.
       * </pre>
       *
       * <code>optional uint64 analysis_interval_bytes = 3;</code>
       * @return Whether the analysisIntervalBytes field is set.
       */
      @java.lang.Override
      public boolean hasAnalysisIntervalBytes() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The leak analysis takes place every so often, with an interval based on
       * the number of bytes allocated. This is independent of the sampling rate
       * as it is computed from allocation sizes before sampling.
       * </pre>
       *
       * <code>optional uint64 analysis_interval_bytes = 3;</code>
       * @return The analysisIntervalBytes.
       */
      @java.lang.Override
      public long getAnalysisIntervalBytes() {
        return analysisIntervalBytes_;
      }
      /**
       * <pre>
       * The leak analysis takes place every so often, with an interval based on
       * the number of bytes allocated. This is independent of the sampling rate
       * as it is computed from allocation sizes before sampling.
       * </pre>
       *
       * <code>optional uint64 analysis_interval_bytes = 3;</code>
       * @param value The analysisIntervalBytes to set.
       */
      private void setAnalysisIntervalBytes(long value) {
        bitField0_ |= 0x00000004;
        analysisIntervalBytes_ = value;
      }
      /**
       * <pre>
       * The leak analysis takes place every so often, with an interval based on
       * the number of bytes allocated. This is independent of the sampling rate
       * as it is computed from allocation sizes before sampling.
       * </pre>
       *
       * <code>optional uint64 analysis_interval_bytes = 3;</code>
       */
      private void clearAnalysisIntervalBytes() {
        bitField0_ = (bitField0_ & ~0x00000004);
        analysisIntervalBytes_ = 0L;
      }

      public static final int SIZE_SUSPICION_THRESHOLD_FIELD_NUMBER = 4;
      private int sizeSuspicionThreshold_;
      /**
       * <pre>
       * Suspicion thresholds used in leak analysis for size and call stacks,
       * respectively. If an allocation size or call stack is suspected this many
       * times in a row, the leak analysis escalates to the next level. For
       * allocation sizes, the next level is to start analyzing by call stack. For
       * call stacks, the next level is to generate a memory leak report.
       * </pre>
       *
       * <code>optional uint32 size_suspicion_threshold = 4;</code>
       * @return Whether the sizeSuspicionThreshold field is set.
       */
      @java.lang.Override
      public boolean hasSizeSuspicionThreshold() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Suspicion thresholds used in leak analysis for size and call stacks,
       * respectively. If an allocation size or call stack is suspected this many
       * times in a row, the leak analysis escalates to the next level. For
       * allocation sizes, the next level is to start analyzing by call stack. For
       * call stacks, the next level is to generate a memory leak report.
       * </pre>
       *
       * <code>optional uint32 size_suspicion_threshold = 4;</code>
       * @return The sizeSuspicionThreshold.
       */
      @java.lang.Override
      public int getSizeSuspicionThreshold() {
        return sizeSuspicionThreshold_;
      }
      /**
       * <pre>
       * Suspicion thresholds used in leak analysis for size and call stacks,
       * respectively. If an allocation size or call stack is suspected this many
       * times in a row, the leak analysis escalates to the next level. For
       * allocation sizes, the next level is to start analyzing by call stack. For
       * call stacks, the next level is to generate a memory leak report.
       * </pre>
       *
       * <code>optional uint32 size_suspicion_threshold = 4;</code>
       * @param value The sizeSuspicionThreshold to set.
       */
      private void setSizeSuspicionThreshold(int value) {
        bitField0_ |= 0x00000008;
        sizeSuspicionThreshold_ = value;
      }
      /**
       * <pre>
       * Suspicion thresholds used in leak analysis for size and call stacks,
       * respectively. If an allocation size or call stack is suspected this many
       * times in a row, the leak analysis escalates to the next level. For
       * allocation sizes, the next level is to start analyzing by call stack. For
       * call stacks, the next level is to generate a memory leak report.
       * </pre>
       *
       * <code>optional uint32 size_suspicion_threshold = 4;</code>
       */
      private void clearSizeSuspicionThreshold() {
        bitField0_ = (bitField0_ & ~0x00000008);
        sizeSuspicionThreshold_ = 0;
      }

      public static final int CALL_STACK_SUSPICION_THRESHOLD_FIELD_NUMBER = 5;
      private int callStackSuspicionThreshold_;
      /**
       * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
       * @return Whether the callStackSuspicionThreshold field is set.
       */
      @java.lang.Override
      public boolean hasCallStackSuspicionThreshold() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
       * @return The callStackSuspicionThreshold.
       */
      @java.lang.Override
      public int getCallStackSuspicionThreshold() {
        return callStackSuspicionThreshold_;
      }
      /**
       * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
       * @param value The callStackSuspicionThreshold to set.
       */
      private void setCallStackSuspicionThreshold(int value) {
        bitField0_ |= 0x00000010;
        callStackSuspicionThreshold_ = value;
      }
      /**
       * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
       */
      private void clearCallStackSuspicionThreshold() {
        bitField0_ = (bitField0_ & ~0x00000010);
        callStackSuspicionThreshold_ = 0;
      }

      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Contains all parameters passed to the leak detector during initialization.
       * Since these are known at the beginning, this message can be stored locally
       * and then added to generated memory leak report protobufs.
       * Next tag: 6
       * </pre>
       *
       * Protobuf type {@code metrics.MemoryLeakReportProto.Params}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params, Builder> implements
          // @@protoc_insertion_point(builder_implements:metrics.MemoryLeakReportProto.Params)
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ParamsOrBuilder {
        // Construct using org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The rate at which allocations are pseudorandomly sampled. Ranges from 0
         * to 1. A rate of 1 means all incoming allocations are sampled by the leak
         * detector, which is the maximum possible.
         * </pre>
         *
         * <code>optional float sampling_rate = 1;</code>
         * @return Whether the samplingRate field is set.
         */
        @java.lang.Override
        public boolean hasSamplingRate() {
          return instance.hasSamplingRate();
        }
        /**
         * <pre>
         * The rate at which allocations are pseudorandomly sampled. Ranges from 0
         * to 1. A rate of 1 means all incoming allocations are sampled by the leak
         * detector, which is the maximum possible.
         * </pre>
         *
         * <code>optional float sampling_rate = 1;</code>
         * @return The samplingRate.
         */
        @java.lang.Override
        public float getSamplingRate() {
          return instance.getSamplingRate();
        }
        /**
         * <pre>
         * The rate at which allocations are pseudorandomly sampled. Ranges from 0
         * to 1. A rate of 1 means all incoming allocations are sampled by the leak
         * detector, which is the maximum possible.
         * </pre>
         *
         * <code>optional float sampling_rate = 1;</code>
         * @param value The samplingRate to set.
         * @return This builder for chaining.
         */
        public Builder setSamplingRate(float value) {
          copyOnWrite();
          instance.setSamplingRate(value);
          return this;
        }
        /**
         * <pre>
         * The rate at which allocations are pseudorandomly sampled. Ranges from 0
         * to 1. A rate of 1 means all incoming allocations are sampled by the leak
         * detector, which is the maximum possible.
         * </pre>
         *
         * <code>optional float sampling_rate = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearSamplingRate() {
          copyOnWrite();
          instance.clearSamplingRate();
          return this;
        }

        /**
         * <pre>
         * The max depth to which the call stacks were unwound by the leak detector.
         * This may be greater than the size of |call_stack|.
         * </pre>
         *
         * <code>optional uint32 max_stack_depth = 2;</code>
         * @return Whether the maxStackDepth field is set.
         */
        @java.lang.Override
        public boolean hasMaxStackDepth() {
          return instance.hasMaxStackDepth();
        }
        /**
         * <pre>
         * The max depth to which the call stacks were unwound by the leak detector.
         * This may be greater than the size of |call_stack|.
         * </pre>
         *
         * <code>optional uint32 max_stack_depth = 2;</code>
         * @return The maxStackDepth.
         */
        @java.lang.Override
        public int getMaxStackDepth() {
          return instance.getMaxStackDepth();
        }
        /**
         * <pre>
         * The max depth to which the call stacks were unwound by the leak detector.
         * This may be greater than the size of |call_stack|.
         * </pre>
         *
         * <code>optional uint32 max_stack_depth = 2;</code>
         * @param value The maxStackDepth to set.
         * @return This builder for chaining.
         */
        public Builder setMaxStackDepth(int value) {
          copyOnWrite();
          instance.setMaxStackDepth(value);
          return this;
        }
        /**
         * <pre>
         * The max depth to which the call stacks were unwound by the leak detector.
         * This may be greater than the size of |call_stack|.
         * </pre>
         *
         * <code>optional uint32 max_stack_depth = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearMaxStackDepth() {
          copyOnWrite();
          instance.clearMaxStackDepth();
          return this;
        }

        /**
         * <pre>
         * The leak analysis takes place every so often, with an interval based on
         * the number of bytes allocated. This is independent of the sampling rate
         * as it is computed from allocation sizes before sampling.
         * </pre>
         *
         * <code>optional uint64 analysis_interval_bytes = 3;</code>
         * @return Whether the analysisIntervalBytes field is set.
         */
        @java.lang.Override
        public boolean hasAnalysisIntervalBytes() {
          return instance.hasAnalysisIntervalBytes();
        }
        /**
         * <pre>
         * The leak analysis takes place every so often, with an interval based on
         * the number of bytes allocated. This is independent of the sampling rate
         * as it is computed from allocation sizes before sampling.
         * </pre>
         *
         * <code>optional uint64 analysis_interval_bytes = 3;</code>
         * @return The analysisIntervalBytes.
         */
        @java.lang.Override
        public long getAnalysisIntervalBytes() {
          return instance.getAnalysisIntervalBytes();
        }
        /**
         * <pre>
         * The leak analysis takes place every so often, with an interval based on
         * the number of bytes allocated. This is independent of the sampling rate
         * as it is computed from allocation sizes before sampling.
         * </pre>
         *
         * <code>optional uint64 analysis_interval_bytes = 3;</code>
         * @param value The analysisIntervalBytes to set.
         * @return This builder for chaining.
         */
        public Builder setAnalysisIntervalBytes(long value) {
          copyOnWrite();
          instance.setAnalysisIntervalBytes(value);
          return this;
        }
        /**
         * <pre>
         * The leak analysis takes place every so often, with an interval based on
         * the number of bytes allocated. This is independent of the sampling rate
         * as it is computed from allocation sizes before sampling.
         * </pre>
         *
         * <code>optional uint64 analysis_interval_bytes = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearAnalysisIntervalBytes() {
          copyOnWrite();
          instance.clearAnalysisIntervalBytes();
          return this;
        }

        /**
         * <pre>
         * Suspicion thresholds used in leak analysis for size and call stacks,
         * respectively. If an allocation size or call stack is suspected this many
         * times in a row, the leak analysis escalates to the next level. For
         * allocation sizes, the next level is to start analyzing by call stack. For
         * call stacks, the next level is to generate a memory leak report.
         * </pre>
         *
         * <code>optional uint32 size_suspicion_threshold = 4;</code>
         * @return Whether the sizeSuspicionThreshold field is set.
         */
        @java.lang.Override
        public boolean hasSizeSuspicionThreshold() {
          return instance.hasSizeSuspicionThreshold();
        }
        /**
         * <pre>
         * Suspicion thresholds used in leak analysis for size and call stacks,
         * respectively. If an allocation size or call stack is suspected this many
         * times in a row, the leak analysis escalates to the next level. For
         * allocation sizes, the next level is to start analyzing by call stack. For
         * call stacks, the next level is to generate a memory leak report.
         * </pre>
         *
         * <code>optional uint32 size_suspicion_threshold = 4;</code>
         * @return The sizeSuspicionThreshold.
         */
        @java.lang.Override
        public int getSizeSuspicionThreshold() {
          return instance.getSizeSuspicionThreshold();
        }
        /**
         * <pre>
         * Suspicion thresholds used in leak analysis for size and call stacks,
         * respectively. If an allocation size or call stack is suspected this many
         * times in a row, the leak analysis escalates to the next level. For
         * allocation sizes, the next level is to start analyzing by call stack. For
         * call stacks, the next level is to generate a memory leak report.
         * </pre>
         *
         * <code>optional uint32 size_suspicion_threshold = 4;</code>
         * @param value The sizeSuspicionThreshold to set.
         * @return This builder for chaining.
         */
        public Builder setSizeSuspicionThreshold(int value) {
          copyOnWrite();
          instance.setSizeSuspicionThreshold(value);
          return this;
        }
        /**
         * <pre>
         * Suspicion thresholds used in leak analysis for size and call stacks,
         * respectively. If an allocation size or call stack is suspected this many
         * times in a row, the leak analysis escalates to the next level. For
         * allocation sizes, the next level is to start analyzing by call stack. For
         * call stacks, the next level is to generate a memory leak report.
         * </pre>
         *
         * <code>optional uint32 size_suspicion_threshold = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearSizeSuspicionThreshold() {
          copyOnWrite();
          instance.clearSizeSuspicionThreshold();
          return this;
        }

        /**
         * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
         * @return Whether the callStackSuspicionThreshold field is set.
         */
        @java.lang.Override
        public boolean hasCallStackSuspicionThreshold() {
          return instance.hasCallStackSuspicionThreshold();
        }
        /**
         * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
         * @return The callStackSuspicionThreshold.
         */
        @java.lang.Override
        public int getCallStackSuspicionThreshold() {
          return instance.getCallStackSuspicionThreshold();
        }
        /**
         * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
         * @param value The callStackSuspicionThreshold to set.
         * @return This builder for chaining.
         */
        public Builder setCallStackSuspicionThreshold(int value) {
          copyOnWrite();
          instance.setCallStackSuspicionThreshold(value);
          return this;
        }
        /**
         * <code>optional uint32 call_stack_suspicion_threshold = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearCallStackSuspicionThreshold() {
          copyOnWrite();
          instance.clearCallStackSuspicionThreshold();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:metrics.MemoryLeakReportProto.Params)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "samplingRate_",
                "maxStackDepth_",
                "analysisIntervalBytes_",
                "sizeSuspicionThreshold_",
                "callStackSuspicionThreshold_",
              };
              java.lang.String info =
                  "\u0001\u0005\u0000\u0001\u0001\u0005\u0005\u0000\u0000\u0000\u0001\u1001\u0000\u0002" +
                  "\u100b\u0001\u0003\u1003\u0002\u0004\u100b\u0003\u0005\u100b\u0004";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params> parser = PARSER;
            if (parser == null) {
              synchronized (org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:metrics.MemoryLeakReportProto.Params)
      private static final org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params DEFAULT_INSTANCE;
      static {
        Params defaultInstance = new Params();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Params.class, defaultInstance);
      }

      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Params> PARSER;

      public static com.google.protobuf.Parser<Params> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface AllocationBreakdownOrBuilder extends
        // @@protoc_insertion_point(interface_extends:metrics.MemoryLeakReportProto.AllocationBreakdown)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @return A list containing the countsBySize.
       */
      java.util.List<java.lang.Integer> getCountsBySizeList();
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @return The count of countsBySize.
       */
      int getCountsBySizeCount();
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @param index The index of the element to return.
       * @return The countsBySize at the given index.
       */
      int getCountsBySize(int index);

      /**
       * <pre>
       * The number of extant allocations with size = |size_bytes| and made from
       * the call site given by |call_stack|. If it is not set, it means tracking
       * of allocs per call site for allocation size = |size_bytes| has not yet
       * begun at the time of this entry.
       * </pre>
       *
       * <code>optional uint32 count_for_call_stack = 2;</code>
       * @return Whether the countForCallStack field is set.
       */
      boolean hasCountForCallStack();
      /**
       * <pre>
       * The number of extant allocations with size = |size_bytes| and made from
       * the call site given by |call_stack|. If it is not set, it means tracking
       * of allocs per call site for allocation size = |size_bytes| has not yet
       * begun at the time of this entry.
       * </pre>
       *
       * <code>optional uint32 count_for_call_stack = 2;</code>
       * @return The countForCallStack.
       */
      int getCountForCallStack();
    }
    /**
     * <pre>
     * Represents a single snapshot of the internal bookkeeping of the Runtime
     * Memory Leak Detector, which tracks the number of extant allocations (a
     * block of heap memory that has been allocated but not yet freed).
     * Next tag: 3
     * </pre>
     *
     * Protobuf type {@code metrics.MemoryLeakReportProto.AllocationBreakdown}
     */
    public  static final class AllocationBreakdown extends
        com.google.protobuf.GeneratedMessageLite<
            AllocationBreakdown, AllocationBreakdown.Builder> implements
        // @@protoc_insertion_point(message_implements:metrics.MemoryLeakReportProto.AllocationBreakdown)
        AllocationBreakdownOrBuilder {
      private AllocationBreakdown() {
        countsBySize_ = emptyIntList();
      }
      private int bitField0_;
      public static final int COUNTS_BY_SIZE_FIELD_NUMBER = 1;
      private com.google.protobuf.Internal.IntList countsBySize_;
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @return A list containing the countsBySize.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getCountsBySizeList() {
        return countsBySize_;
      }
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @return The count of countsBySize.
       */
      @java.lang.Override
      public int getCountsBySizeCount() {
        return countsBySize_.size();
      }
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @param index The index of the element to return.
       * @return The countsBySize at the given index.
       */
      @java.lang.Override
      public int getCountsBySize(int index) {
        return countsBySize_.getInt(index);
      }
      private void ensureCountsBySizeIsMutable() {
        com.google.protobuf.Internal.IntList tmp = countsBySize_;
        if (!tmp.isModifiable()) {
          countsBySize_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @param index The index to set the value at.
       * @param value The countsBySize to set.
       */
      private void setCountsBySize(
          int index, int value) {
        ensureCountsBySizeIsMutable();
        countsBySize_.setInt(index, value);
      }
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @param value The countsBySize to add.
       */
      private void addCountsBySize(int value) {
        ensureCountsBySizeIsMutable();
        countsBySize_.addInt(value);
      }
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       * @param values The countsBySize to add.
       */
      private void addAllCountsBySize(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureCountsBySizeIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, countsBySize_);
      }
      /**
       * <pre>
       * Table of number of extant allocations for each allocation size. The i-th
       * entry in the vector is the net number of allocations for sizes in the
       * range [i * 4, i * 4 + 3].
       * </pre>
       *
       * <code>repeated uint32 counts_by_size = 1;</code>
       */
      private void clearCountsBySize() {
        countsBySize_ = emptyIntList();
      }

      public static final int COUNT_FOR_CALL_STACK_FIELD_NUMBER = 2;
      private int countForCallStack_;
      /**
       * <pre>
       * The number of extant allocations with size = |size_bytes| and made from
       * the call site given by |call_stack|. If it is not set, it means tracking
       * of allocs per call site for allocation size = |size_bytes| has not yet
       * begun at the time of this entry.
       * </pre>
       *
       * <code>optional uint32 count_for_call_stack = 2;</code>
       * @return Whether the countForCallStack field is set.
       */
      @java.lang.Override
      public boolean hasCountForCallStack() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The number of extant allocations with size = |size_bytes| and made from
       * the call site given by |call_stack|. If it is not set, it means tracking
       * of allocs per call site for allocation size = |size_bytes| has not yet
       * begun at the time of this entry.
       * </pre>
       *
       * <code>optional uint32 count_for_call_stack = 2;</code>
       * @return The countForCallStack.
       */
      @java.lang.Override
      public int getCountForCallStack() {
        return countForCallStack_;
      }
      /**
       * <pre>
       * The number of extant allocations with size = |size_bytes| and made from
       * the call site given by |call_stack|. If it is not set, it means tracking
       * of allocs per call site for allocation size = |size_bytes| has not yet
       * begun at the time of this entry.
       * </pre>
       *
       * <code>optional uint32 count_for_call_stack = 2;</code>
       * @param value The countForCallStack to set.
       */
      private void setCountForCallStack(int value) {
        bitField0_ |= 0x00000001;
        countForCallStack_ = value;
      }
      /**
       * <pre>
       * The number of extant allocations with size = |size_bytes| and made from
       * the call site given by |call_stack|. If it is not set, it means tracking
       * of allocs per call site for allocation size = |size_bytes| has not yet
       * begun at the time of this entry.
       * </pre>
       *
       * <code>optional uint32 count_for_call_stack = 2;</code>
       */
      private void clearCountForCallStack() {
        bitField0_ = (bitField0_ & ~0x00000001);
        countForCallStack_ = 0;
      }

      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Represents a single snapshot of the internal bookkeeping of the Runtime
       * Memory Leak Detector, which tracks the number of extant allocations (a
       * block of heap memory that has been allocated but not yet freed).
       * Next tag: 3
       * </pre>
       *
       * Protobuf type {@code metrics.MemoryLeakReportProto.AllocationBreakdown}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown, Builder> implements
          // @@protoc_insertion_point(builder_implements:metrics.MemoryLeakReportProto.AllocationBreakdown)
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdownOrBuilder {
        // Construct using org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @return A list containing the countsBySize.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
            getCountsBySizeList() {
          return java.util.Collections.unmodifiableList(
              instance.getCountsBySizeList());
        }
        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @return The count of countsBySize.
         */
        @java.lang.Override
        public int getCountsBySizeCount() {
          return instance.getCountsBySizeCount();
        }
        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @param index The index of the element to return.
         * @return The countsBySize at the given index.
         */
        @java.lang.Override
        public int getCountsBySize(int index) {
          return instance.getCountsBySize(index);
        }
        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @param value The countsBySize to set.
         * @return This builder for chaining.
         */
        public Builder setCountsBySize(
            int index, int value) {
          copyOnWrite();
          instance.setCountsBySize(index, value);
          return this;
        }
        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @param value The countsBySize to add.
         * @return This builder for chaining.
         */
        public Builder addCountsBySize(int value) {
          copyOnWrite();
          instance.addCountsBySize(value);
          return this;
        }
        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @param values The countsBySize to add.
         * @return This builder for chaining.
         */
        public Builder addAllCountsBySize(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          copyOnWrite();
          instance.addAllCountsBySize(values);
          return this;
        }
        /**
         * <pre>
         * Table of number of extant allocations for each allocation size. The i-th
         * entry in the vector is the net number of allocations for sizes in the
         * range [i * 4, i * 4 + 3].
         * </pre>
         *
         * <code>repeated uint32 counts_by_size = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearCountsBySize() {
          copyOnWrite();
          instance.clearCountsBySize();
          return this;
        }

        /**
         * <pre>
         * The number of extant allocations with size = |size_bytes| and made from
         * the call site given by |call_stack|. If it is not set, it means tracking
         * of allocs per call site for allocation size = |size_bytes| has not yet
         * begun at the time of this entry.
         * </pre>
         *
         * <code>optional uint32 count_for_call_stack = 2;</code>
         * @return Whether the countForCallStack field is set.
         */
        @java.lang.Override
        public boolean hasCountForCallStack() {
          return instance.hasCountForCallStack();
        }
        /**
         * <pre>
         * The number of extant allocations with size = |size_bytes| and made from
         * the call site given by |call_stack|. If it is not set, it means tracking
         * of allocs per call site for allocation size = |size_bytes| has not yet
         * begun at the time of this entry.
         * </pre>
         *
         * <code>optional uint32 count_for_call_stack = 2;</code>
         * @return The countForCallStack.
         */
        @java.lang.Override
        public int getCountForCallStack() {
          return instance.getCountForCallStack();
        }
        /**
         * <pre>
         * The number of extant allocations with size = |size_bytes| and made from
         * the call site given by |call_stack|. If it is not set, it means tracking
         * of allocs per call site for allocation size = |size_bytes| has not yet
         * begun at the time of this entry.
         * </pre>
         *
         * <code>optional uint32 count_for_call_stack = 2;</code>
         * @param value The countForCallStack to set.
         * @return This builder for chaining.
         */
        public Builder setCountForCallStack(int value) {
          copyOnWrite();
          instance.setCountForCallStack(value);
          return this;
        }
        /**
         * <pre>
         * The number of extant allocations with size = |size_bytes| and made from
         * the call site given by |call_stack|. If it is not set, it means tracking
         * of allocs per call site for allocation size = |size_bytes| has not yet
         * begun at the time of this entry.
         * </pre>
         *
         * <code>optional uint32 count_for_call_stack = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearCountForCallStack() {
          copyOnWrite();
          instance.clearCountForCallStack();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:metrics.MemoryLeakReportProto.AllocationBreakdown)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "countsBySize_",
                "countForCallStack_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u001d\u0002\u100b" +
                  "\u0000";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> parser = PARSER;
            if (parser == null) {
              synchronized (org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:metrics.MemoryLeakReportProto.AllocationBreakdown)
      private static final org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown DEFAULT_INSTANCE;
      static {
        AllocationBreakdown defaultInstance = new AllocationBreakdown();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          AllocationBreakdown.class, defaultInstance);
      }

      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<AllocationBreakdown> PARSER;

      public static com.google.protobuf.Parser<AllocationBreakdown> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface MemoryUsageInfoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:metrics.MemoryLeakReportProto.MemoryUsageInfo)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * How much available physical memory the system has.
       * </pre>
       *
       * <code>optional uint64 available_ram_mb = 1;</code>
       * @return Whether the availableRamMb field is set.
       */
      boolean hasAvailableRamMb();
      /**
       * <pre>
       * How much available physical memory the system has.
       * </pre>
       *
       * <code>optional uint64 available_ram_mb = 1;</code>
       * @return The availableRamMb.
       */
      long getAvailableRamMb();

      /**
       * <pre>
       * Total private working set memory across all Chrome processes.
       * </pre>
       *
       * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
       * @return Whether the chromeRamUsageMb field is set.
       */
      boolean hasChromeRamUsageMb();
      /**
       * <pre>
       * Total private working set memory across all Chrome processes.
       * </pre>
       *
       * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
       * @return The chromeRamUsageMb.
       */
      long getChromeRamUsageMb();
    }
    /**
     * <pre>
     * Contains additional data about the memory usage from the OS.
     * There is no need to store the total system memory as it is
     * available under SystemProfileProto::Hardware::system_ram_mb.
     * Next tag: 3
     * </pre>
     *
     * Protobuf type {@code metrics.MemoryLeakReportProto.MemoryUsageInfo}
     */
    public  static final class MemoryUsageInfo extends
        com.google.protobuf.GeneratedMessageLite<
            MemoryUsageInfo, MemoryUsageInfo.Builder> implements
        // @@protoc_insertion_point(message_implements:metrics.MemoryLeakReportProto.MemoryUsageInfo)
        MemoryUsageInfoOrBuilder {
      private MemoryUsageInfo() {
      }
      private int bitField0_;
      public static final int AVAILABLE_RAM_MB_FIELD_NUMBER = 1;
      private long availableRamMb_;
      /**
       * <pre>
       * How much available physical memory the system has.
       * </pre>
       *
       * <code>optional uint64 available_ram_mb = 1;</code>
       * @return Whether the availableRamMb field is set.
       */
      @java.lang.Override
      public boolean hasAvailableRamMb() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * How much available physical memory the system has.
       * </pre>
       *
       * <code>optional uint64 available_ram_mb = 1;</code>
       * @return The availableRamMb.
       */
      @java.lang.Override
      public long getAvailableRamMb() {
        return availableRamMb_;
      }
      /**
       * <pre>
       * How much available physical memory the system has.
       * </pre>
       *
       * <code>optional uint64 available_ram_mb = 1;</code>
       * @param value The availableRamMb to set.
       */
      private void setAvailableRamMb(long value) {
        bitField0_ |= 0x00000001;
        availableRamMb_ = value;
      }
      /**
       * <pre>
       * How much available physical memory the system has.
       * </pre>
       *
       * <code>optional uint64 available_ram_mb = 1;</code>
       */
      private void clearAvailableRamMb() {
        bitField0_ = (bitField0_ & ~0x00000001);
        availableRamMb_ = 0L;
      }

      public static final int CHROME_RAM_USAGE_MB_FIELD_NUMBER = 2;
      private long chromeRamUsageMb_;
      /**
       * <pre>
       * Total private working set memory across all Chrome processes.
       * </pre>
       *
       * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
       * @return Whether the chromeRamUsageMb field is set.
       */
      @java.lang.Override
      public boolean hasChromeRamUsageMb() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Total private working set memory across all Chrome processes.
       * </pre>
       *
       * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
       * @return The chromeRamUsageMb.
       */
      @java.lang.Override
      public long getChromeRamUsageMb() {
        return chromeRamUsageMb_;
      }
      /**
       * <pre>
       * Total private working set memory across all Chrome processes.
       * </pre>
       *
       * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
       * @param value The chromeRamUsageMb to set.
       */
      private void setChromeRamUsageMb(long value) {
        bitField0_ |= 0x00000002;
        chromeRamUsageMb_ = value;
      }
      /**
       * <pre>
       * Total private working set memory across all Chrome processes.
       * </pre>
       *
       * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
       */
      private void clearChromeRamUsageMb() {
        bitField0_ = (bitField0_ & ~0x00000002);
        chromeRamUsageMb_ = 0L;
      }

      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Contains additional data about the memory usage from the OS.
       * There is no need to store the total system memory as it is
       * available under SystemProfileProto::Hardware::system_ram_mb.
       * Next tag: 3
       * </pre>
       *
       * Protobuf type {@code metrics.MemoryLeakReportProto.MemoryUsageInfo}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo, Builder> implements
          // @@protoc_insertion_point(builder_implements:metrics.MemoryLeakReportProto.MemoryUsageInfo)
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfoOrBuilder {
        // Construct using org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * How much available physical memory the system has.
         * </pre>
         *
         * <code>optional uint64 available_ram_mb = 1;</code>
         * @return Whether the availableRamMb field is set.
         */
        @java.lang.Override
        public boolean hasAvailableRamMb() {
          return instance.hasAvailableRamMb();
        }
        /**
         * <pre>
         * How much available physical memory the system has.
         * </pre>
         *
         * <code>optional uint64 available_ram_mb = 1;</code>
         * @return The availableRamMb.
         */
        @java.lang.Override
        public long getAvailableRamMb() {
          return instance.getAvailableRamMb();
        }
        /**
         * <pre>
         * How much available physical memory the system has.
         * </pre>
         *
         * <code>optional uint64 available_ram_mb = 1;</code>
         * @param value The availableRamMb to set.
         * @return This builder for chaining.
         */
        public Builder setAvailableRamMb(long value) {
          copyOnWrite();
          instance.setAvailableRamMb(value);
          return this;
        }
        /**
         * <pre>
         * How much available physical memory the system has.
         * </pre>
         *
         * <code>optional uint64 available_ram_mb = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearAvailableRamMb() {
          copyOnWrite();
          instance.clearAvailableRamMb();
          return this;
        }

        /**
         * <pre>
         * Total private working set memory across all Chrome processes.
         * </pre>
         *
         * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
         * @return Whether the chromeRamUsageMb field is set.
         */
        @java.lang.Override
        public boolean hasChromeRamUsageMb() {
          return instance.hasChromeRamUsageMb();
        }
        /**
         * <pre>
         * Total private working set memory across all Chrome processes.
         * </pre>
         *
         * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
         * @return The chromeRamUsageMb.
         */
        @java.lang.Override
        public long getChromeRamUsageMb() {
          return instance.getChromeRamUsageMb();
        }
        /**
         * <pre>
         * Total private working set memory across all Chrome processes.
         * </pre>
         *
         * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
         * @param value The chromeRamUsageMb to set.
         * @return This builder for chaining.
         */
        public Builder setChromeRamUsageMb(long value) {
          copyOnWrite();
          instance.setChromeRamUsageMb(value);
          return this;
        }
        /**
         * <pre>
         * Total private working set memory across all Chrome processes.
         * </pre>
         *
         * <code>optional uint64 chrome_ram_usage_mb = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearChromeRamUsageMb() {
          copyOnWrite();
          instance.clearChromeRamUsageMb();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:metrics.MemoryLeakReportProto.MemoryUsageInfo)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "availableRamMb_",
                "chromeRamUsageMb_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1003\u0000\u0002" +
                  "\u1003\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo> parser = PARSER;
            if (parser == null) {
              synchronized (org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:metrics.MemoryLeakReportProto.MemoryUsageInfo)
      private static final org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo DEFAULT_INSTANCE;
      static {
        MemoryUsageInfo defaultInstance = new MemoryUsageInfo();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          MemoryUsageInfo.class, defaultInstance);
      }

      public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<MemoryUsageInfo> PARSER;

      public static com.google.protobuf.Parser<MemoryUsageInfo> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int CALL_STACK_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.LongList callStack_;
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @return A list containing the callStack.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getCallStackList() {
      return callStack_;
    }
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @return The count of callStack.
     */
    @java.lang.Override
    public int getCallStackCount() {
      return callStack_.size();
    }
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @param index The index of the element to return.
     * @return The callStack at the given index.
     */
    @java.lang.Override
    public long getCallStack(int index) {
      return callStack_.getLong(index);
    }
    private void ensureCallStackIsMutable() {
      com.google.protobuf.Internal.LongList tmp = callStack_;
      if (!tmp.isModifiable()) {
        callStack_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @param index The index to set the value at.
     * @param value The callStack to set.
     */
    private void setCallStack(
        int index, long value) {
      ensureCallStackIsMutable();
      callStack_.setLong(index, value);
    }
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @param value The callStack to add.
     */
    private void addCallStack(long value) {
      ensureCallStackIsMutable();
      callStack_.addLong(value);
    }
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     * @param values The callStack to add.
     */
    private void addAllCallStack(
        java.lang.Iterable<? extends java.lang.Long> values) {
      ensureCallStackIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, callStack_);
    }
    /**
     * <pre>
     * The call stack at which the leak was found. This is a list of offsets
     * within the program binary. The first entry is the deepest level of the call
     * stack.
     * Some call stack entries may not be within the Chrome binary (e.g.
     * JavaScript code). Those entries are given as the absolute offset in memory.
     * The offsets within Chrome are determined by whether the original call stack
     * address was within the executable region of the Chrome binary's mapping in
     * memory. To symbolize these results, look up these values as offsets within
     * the Chrome debug binary. If the value doesn't fit within the Chrome
     * binary's offset range, then it is considered to be from another binary.
     * </pre>
     *
     * <code>repeated uint64 call_stack = 1;</code>
     */
    private void clearCallStack() {
      callStack_ = emptyLongList();
    }

    public static final int SIZE_BYTES_FIELD_NUMBER = 2;
    private int sizeBytes_;
    /**
     * <pre>
     * Size of the memory allocation involved in the leak.
     * </pre>
     *
     * <code>optional uint32 size_bytes = 2;</code>
     * @return Whether the sizeBytes field is set.
     */
    @java.lang.Override
    public boolean hasSizeBytes() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Size of the memory allocation involved in the leak.
     * </pre>
     *
     * <code>optional uint32 size_bytes = 2;</code>
     * @return The sizeBytes.
     */
    @java.lang.Override
    public int getSizeBytes() {
      return sizeBytes_;
    }
    /**
     * <pre>
     * Size of the memory allocation involved in the leak.
     * </pre>
     *
     * <code>optional uint32 size_bytes = 2;</code>
     * @param value The sizeBytes to set.
     */
    private void setSizeBytes(int value) {
      bitField0_ |= 0x00000001;
      sizeBytes_ = value;
    }
    /**
     * <pre>
     * Size of the memory allocation involved in the leak.
     * </pre>
     *
     * <code>optional uint32 size_bytes = 2;</code>
     */
    private void clearSizeBytes() {
      bitField0_ = (bitField0_ & ~0x00000001);
      sizeBytes_ = 0;
    }

    public static final int PARAMS_FIELD_NUMBER = 3;
    private org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params params_;
    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     */
    @java.lang.Override
    public boolean hasParams() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params getParams() {
      return params_ == null ? org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params.getDefaultInstance() : params_;
    }
    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     */
    private void setParams(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params value) {
      value.getClass();
  params_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeParams(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params value) {
      value.getClass();
  if (params_ != null &&
          params_ != org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params.getDefaultInstance()) {
        params_ =
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params.newBuilder(params_).mergeFrom(value).buildPartial();
      } else {
        params_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Parameters used to initialize the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
     */
    private void clearParams() {  params_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int SOURCE_PROCESS_FIELD_NUMBER = 5;
    private int sourceProcess_;
    /**
     * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
     * @return Whether the sourceProcess field is set.
     */
    @java.lang.Override
    public boolean hasSourceProcess() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
     * @return The sourceProcess.
     */
    @java.lang.Override
    public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType getSourceProcess() {
      org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType result = org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType.forNumber(sourceProcess_);
      return result == null ? org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType.UNKNOWN_PROCESS : result;
    }
    /**
     * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
     * @param value The sourceProcess to set.
     */
    private void setSourceProcess(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType value) {
      sourceProcess_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
     */
    private void clearSourceProcess() {
      bitField0_ = (bitField0_ & ~0x00000004);
      sourceProcess_ = 0;
    }

    public static final int BUILD_ID_FIELD_NUMBER = 6;
    private com.google.protobuf.ByteString buildId_;
    /**
     * <pre>
     * The build ID of the Chrome binary from which this leak report was obtained.
     * The build ID is typically a 16- or 20-byte hash that is generated by the
     * compiler that built the binary. This value will be read directly from the
     * GNU build notes section of the Chrome binary.
     * </pre>
     *
     * <code>optional bytes build_id = 6;</code>
     * @return Whether the buildId field is set.
     */
    @java.lang.Override
    public boolean hasBuildId() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The build ID of the Chrome binary from which this leak report was obtained.
     * The build ID is typically a 16- or 20-byte hash that is generated by the
     * compiler that built the binary. This value will be read directly from the
     * GNU build notes section of the Chrome binary.
     * </pre>
     *
     * <code>optional bytes build_id = 6;</code>
     * @return The buildId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBuildId() {
      return buildId_;
    }
    /**
     * <pre>
     * The build ID of the Chrome binary from which this leak report was obtained.
     * The build ID is typically a 16- or 20-byte hash that is generated by the
     * compiler that built the binary. This value will be read directly from the
     * GNU build notes section of the Chrome binary.
     * </pre>
     *
     * <code>optional bytes build_id = 6;</code>
     * @param value The buildId to set.
     */
    private void setBuildId(com.google.protobuf.ByteString value) {
      value.getClass();
  bitField0_ |= 0x00000008;
      buildId_ = value;
    }
    /**
     * <pre>
     * The build ID of the Chrome binary from which this leak report was obtained.
     * The build ID is typically a 16- or 20-byte hash that is generated by the
     * compiler that built the binary. This value will be read directly from the
     * GNU build notes section of the Chrome binary.
     * </pre>
     *
     * <code>optional bytes build_id = 6;</code>
     */
    private void clearBuildId() {
      bitField0_ = (bitField0_ & ~0x00000008);
      buildId_ = getDefaultInstance().getBuildId();
    }

    public static final int ALLOC_BREAKDOWN_HISTORY_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> allocBreakdownHistory_;
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> getAllocBreakdownHistoryList() {
      return allocBreakdownHistory_;
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    public java.util.List<? extends org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdownOrBuilder> 
        getAllocBreakdownHistoryOrBuilderList() {
      return allocBreakdownHistory_;
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    @java.lang.Override
    public int getAllocBreakdownHistoryCount() {
      return allocBreakdownHistory_.size();
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown getAllocBreakdownHistory(int index) {
      return allocBreakdownHistory_.get(index);
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdownOrBuilder getAllocBreakdownHistoryOrBuilder(
        int index) {
      return allocBreakdownHistory_.get(index);
    }
    private void ensureAllocBreakdownHistoryIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> tmp = allocBreakdownHistory_;
      if (!tmp.isModifiable()) {
        allocBreakdownHistory_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    private void setAllocBreakdownHistory(
        int index, org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown value) {
      value.getClass();
  ensureAllocBreakdownHistoryIsMutable();
      allocBreakdownHistory_.set(index, value);
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    private void addAllocBreakdownHistory(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown value) {
      value.getClass();
  ensureAllocBreakdownHistoryIsMutable();
      allocBreakdownHistory_.add(value);
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    private void addAllocBreakdownHistory(
        int index, org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown value) {
      value.getClass();
  ensureAllocBreakdownHistoryIsMutable();
      allocBreakdownHistory_.add(index, value);
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    private void addAllAllocBreakdownHistory(
        java.lang.Iterable<? extends org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> values) {
      ensureAllocBreakdownHistoryIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, allocBreakdownHistory_);
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    private void clearAllocBreakdownHistory() {
      allocBreakdownHistory_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A record of past allocation data leading up to the circumstances that
     * generated the current leak report.
     * A new snapshot is taken every |analysis_interval_bytes| of memory
     * allocation. The oldest record is at the beginning. The most recent record,
     * taken at the time the report was generated, is at the end.
     * </pre>
     *
     * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
     */
    private void removeAllocBreakdownHistory(int index) {
      ensureAllocBreakdownHistoryIsMutable();
      allocBreakdownHistory_.remove(index);
    }

    public static final int NUM_RISING_INTERVALS_FIELD_NUMBER = 7;
    private int numRisingIntervals_;
    /**
     * <pre>
     * The following two fields describe the last increasing trend in the number
     * of allocations from the size and call stack that generated this
     * leak report.
     * |num_rising_intervals| equals timeslot_now - timeslot_drop,
     * where timeslot_drop is the timeslot number of the last frame that saw
     * a drop in the number of allocations, or the first frame in the history
     * if there were no drops (history is cleared when the net number of
     * allocations hits 0).
     * If it is &lt; 32, it will be visible in the allocation history graph.
     * If it is &gt;= 32, it will not be seen in the graph.
     * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
     * </pre>
     *
     * <code>optional uint32 num_rising_intervals = 7;</code>
     * @return Whether the numRisingIntervals field is set.
     */
    @java.lang.Override
    public boolean hasNumRisingIntervals() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The following two fields describe the last increasing trend in the number
     * of allocations from the size and call stack that generated this
     * leak report.
     * |num_rising_intervals| equals timeslot_now - timeslot_drop,
     * where timeslot_drop is the timeslot number of the last frame that saw
     * a drop in the number of allocations, or the first frame in the history
     * if there were no drops (history is cleared when the net number of
     * allocations hits 0).
     * If it is &lt; 32, it will be visible in the allocation history graph.
     * If it is &gt;= 32, it will not be seen in the graph.
     * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
     * </pre>
     *
     * <code>optional uint32 num_rising_intervals = 7;</code>
     * @return The numRisingIntervals.
     */
    @java.lang.Override
    public int getNumRisingIntervals() {
      return numRisingIntervals_;
    }
    /**
     * <pre>
     * The following two fields describe the last increasing trend in the number
     * of allocations from the size and call stack that generated this
     * leak report.
     * |num_rising_intervals| equals timeslot_now - timeslot_drop,
     * where timeslot_drop is the timeslot number of the last frame that saw
     * a drop in the number of allocations, or the first frame in the history
     * if there were no drops (history is cleared when the net number of
     * allocations hits 0).
     * If it is &lt; 32, it will be visible in the allocation history graph.
     * If it is &gt;= 32, it will not be seen in the graph.
     * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
     * </pre>
     *
     * <code>optional uint32 num_rising_intervals = 7;</code>
     * @param value The numRisingIntervals to set.
     */
    private void setNumRisingIntervals(int value) {
      bitField0_ |= 0x00000010;
      numRisingIntervals_ = value;
    }
    /**
     * <pre>
     * The following two fields describe the last increasing trend in the number
     * of allocations from the size and call stack that generated this
     * leak report.
     * |num_rising_intervals| equals timeslot_now - timeslot_drop,
     * where timeslot_drop is the timeslot number of the last frame that saw
     * a drop in the number of allocations, or the first frame in the history
     * if there were no drops (history is cleared when the net number of
     * allocations hits 0).
     * If it is &lt; 32, it will be visible in the allocation history graph.
     * If it is &gt;= 32, it will not be seen in the graph.
     * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
     * </pre>
     *
     * <code>optional uint32 num_rising_intervals = 7;</code>
     */
    private void clearNumRisingIntervals() {
      bitField0_ = (bitField0_ & ~0x00000010);
      numRisingIntervals_ = 0;
    }

    public static final int NUM_ALLOCS_INCREASE_FIELD_NUMBER = 8;
    private int numAllocsIncrease_;
    /**
     * <pre>
     * Indicates the magnitude of the current uptrend in allocations.
     * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
     * </pre>
     *
     * <code>optional uint32 num_allocs_increase = 8;</code>
     * @return Whether the numAllocsIncrease field is set.
     */
    @java.lang.Override
    public boolean hasNumAllocsIncrease() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Indicates the magnitude of the current uptrend in allocations.
     * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
     * </pre>
     *
     * <code>optional uint32 num_allocs_increase = 8;</code>
     * @return The numAllocsIncrease.
     */
    @java.lang.Override
    public int getNumAllocsIncrease() {
      return numAllocsIncrease_;
    }
    /**
     * <pre>
     * Indicates the magnitude of the current uptrend in allocations.
     * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
     * </pre>
     *
     * <code>optional uint32 num_allocs_increase = 8;</code>
     * @param value The numAllocsIncrease to set.
     */
    private void setNumAllocsIncrease(int value) {
      bitField0_ |= 0x00000020;
      numAllocsIncrease_ = value;
    }
    /**
     * <pre>
     * Indicates the magnitude of the current uptrend in allocations.
     * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
     * </pre>
     *
     * <code>optional uint32 num_allocs_increase = 8;</code>
     */
    private void clearNumAllocsIncrease() {
      bitField0_ = (bitField0_ & ~0x00000020);
      numAllocsIncrease_ = 0;
    }

    public static final int MEMORY_USAGE_INFO_FIELD_NUMBER = 9;
    private org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo memoryUsageInfo_;
    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     */
    @java.lang.Override
    public boolean hasMemoryUsageInfo() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo getMemoryUsageInfo() {
      return memoryUsageInfo_ == null ? org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo.getDefaultInstance() : memoryUsageInfo_;
    }
    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     */
    private void setMemoryUsageInfo(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo value) {
      value.getClass();
  memoryUsageInfo_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeMemoryUsageInfo(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo value) {
      value.getClass();
  if (memoryUsageInfo_ != null &&
          memoryUsageInfo_ != org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo.getDefaultInstance()) {
        memoryUsageInfo_ =
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo.newBuilder(memoryUsageInfo_).mergeFrom(value).buildPartial();
      } else {
        memoryUsageInfo_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <pre>
     * Information about the memory usage from the OS collected right after
     * the leak report was created in the leak detector.
     * </pre>
     *
     * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
     */
    private void clearMemoryUsageInfo() {  memoryUsageInfo_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Next tag: 10
     * </pre>
     *
     * Protobuf type {@code metrics.MemoryLeakReportProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:metrics.MemoryLeakReportProto)
        org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProtoOrBuilder {
      // Construct using org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @return A list containing the callStack.
       */
      @java.lang.Override
      public java.util.List<java.lang.Long>
          getCallStackList() {
        return java.util.Collections.unmodifiableList(
            instance.getCallStackList());
      }
      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @return The count of callStack.
       */
      @java.lang.Override
      public int getCallStackCount() {
        return instance.getCallStackCount();
      }
      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @param index The index of the element to return.
       * @return The callStack at the given index.
       */
      @java.lang.Override
      public long getCallStack(int index) {
        return instance.getCallStack(index);
      }
      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @param value The callStack to set.
       * @return This builder for chaining.
       */
      public Builder setCallStack(
          int index, long value) {
        copyOnWrite();
        instance.setCallStack(index, value);
        return this;
      }
      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @param value The callStack to add.
       * @return This builder for chaining.
       */
      public Builder addCallStack(long value) {
        copyOnWrite();
        instance.addCallStack(value);
        return this;
      }
      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @param values The callStack to add.
       * @return This builder for chaining.
       */
      public Builder addAllCallStack(
          java.lang.Iterable<? extends java.lang.Long> values) {
        copyOnWrite();
        instance.addAllCallStack(values);
        return this;
      }
      /**
       * <pre>
       * The call stack at which the leak was found. This is a list of offsets
       * within the program binary. The first entry is the deepest level of the call
       * stack.
       * Some call stack entries may not be within the Chrome binary (e.g.
       * JavaScript code). Those entries are given as the absolute offset in memory.
       * The offsets within Chrome are determined by whether the original call stack
       * address was within the executable region of the Chrome binary's mapping in
       * memory. To symbolize these results, look up these values as offsets within
       * the Chrome debug binary. If the value doesn't fit within the Chrome
       * binary's offset range, then it is considered to be from another binary.
       * </pre>
       *
       * <code>repeated uint64 call_stack = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCallStack() {
        copyOnWrite();
        instance.clearCallStack();
        return this;
      }

      /**
       * <pre>
       * Size of the memory allocation involved in the leak.
       * </pre>
       *
       * <code>optional uint32 size_bytes = 2;</code>
       * @return Whether the sizeBytes field is set.
       */
      @java.lang.Override
      public boolean hasSizeBytes() {
        return instance.hasSizeBytes();
      }
      /**
       * <pre>
       * Size of the memory allocation involved in the leak.
       * </pre>
       *
       * <code>optional uint32 size_bytes = 2;</code>
       * @return The sizeBytes.
       */
      @java.lang.Override
      public int getSizeBytes() {
        return instance.getSizeBytes();
      }
      /**
       * <pre>
       * Size of the memory allocation involved in the leak.
       * </pre>
       *
       * <code>optional uint32 size_bytes = 2;</code>
       * @param value The sizeBytes to set.
       * @return This builder for chaining.
       */
      public Builder setSizeBytes(int value) {
        copyOnWrite();
        instance.setSizeBytes(value);
        return this;
      }
      /**
       * <pre>
       * Size of the memory allocation involved in the leak.
       * </pre>
       *
       * <code>optional uint32 size_bytes = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSizeBytes() {
        copyOnWrite();
        instance.clearSizeBytes();
        return this;
      }

      /**
       * <pre>
       * Parameters used to initialize the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
       */
      @java.lang.Override
      public boolean hasParams() {
        return instance.hasParams();
      }
      /**
       * <pre>
       * Parameters used to initialize the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params getParams() {
        return instance.getParams();
      }
      /**
       * <pre>
       * Parameters used to initialize the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
       */
      public Builder setParams(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params value) {
        copyOnWrite();
        instance.setParams(value);
        return this;
        }
      /**
       * <pre>
       * Parameters used to initialize the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
       */
      public Builder setParams(
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params.Builder builderForValue) {
        copyOnWrite();
        instance.setParams(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Parameters used to initialize the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
       */
      public Builder mergeParams(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.Params value) {
        copyOnWrite();
        instance.mergeParams(value);
        return this;
      }
      /**
       * <pre>
       * Parameters used to initialize the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.Params params = 3;</code>
       */
      public Builder clearParams() {  copyOnWrite();
        instance.clearParams();
        return this;
      }

      /**
       * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
       * @return Whether the sourceProcess field is set.
       */
      @java.lang.Override
      public boolean hasSourceProcess() {
        return instance.hasSourceProcess();
      }
      /**
       * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
       * @return The sourceProcess.
       */
      @java.lang.Override
      public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType getSourceProcess() {
        return instance.getSourceProcess();
      }
      /**
       * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
       * @param value The enum numeric value on the wire for sourceProcess to set.
       * @return This builder for chaining.
       */
      public Builder setSourceProcess(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType value) {
        copyOnWrite();
        instance.setSourceProcess(value);
        return this;
      }
      /**
       * <code>optional .metrics.MemoryLeakReportProto.ProcessType source_process = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSourceProcess() {
        copyOnWrite();
        instance.clearSourceProcess();
        return this;
      }

      /**
       * <pre>
       * The build ID of the Chrome binary from which this leak report was obtained.
       * The build ID is typically a 16- or 20-byte hash that is generated by the
       * compiler that built the binary. This value will be read directly from the
       * GNU build notes section of the Chrome binary.
       * </pre>
       *
       * <code>optional bytes build_id = 6;</code>
       * @return Whether the buildId field is set.
       */
      @java.lang.Override
      public boolean hasBuildId() {
        return instance.hasBuildId();
      }
      /**
       * <pre>
       * The build ID of the Chrome binary from which this leak report was obtained.
       * The build ID is typically a 16- or 20-byte hash that is generated by the
       * compiler that built the binary. This value will be read directly from the
       * GNU build notes section of the Chrome binary.
       * </pre>
       *
       * <code>optional bytes build_id = 6;</code>
       * @return The buildId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBuildId() {
        return instance.getBuildId();
      }
      /**
       * <pre>
       * The build ID of the Chrome binary from which this leak report was obtained.
       * The build ID is typically a 16- or 20-byte hash that is generated by the
       * compiler that built the binary. This value will be read directly from the
       * GNU build notes section of the Chrome binary.
       * </pre>
       *
       * <code>optional bytes build_id = 6;</code>
       * @param value The buildId to set.
       * @return This builder for chaining.
       */
      public Builder setBuildId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setBuildId(value);
        return this;
      }
      /**
       * <pre>
       * The build ID of the Chrome binary from which this leak report was obtained.
       * The build ID is typically a 16- or 20-byte hash that is generated by the
       * compiler that built the binary. This value will be read directly from the
       * GNU build notes section of the Chrome binary.
       * </pre>
       *
       * <code>optional bytes build_id = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearBuildId() {
        copyOnWrite();
        instance.clearBuildId();
        return this;
      }

      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> getAllocBreakdownHistoryList() {
        return java.util.Collections.unmodifiableList(
            instance.getAllocBreakdownHistoryList());
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      @java.lang.Override
      public int getAllocBreakdownHistoryCount() {
        return instance.getAllocBreakdownHistoryCount();
      }/**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown getAllocBreakdownHistory(int index) {
        return instance.getAllocBreakdownHistory(index);
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder setAllocBreakdownHistory(
          int index, org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown value) {
        copyOnWrite();
        instance.setAllocBreakdownHistory(index, value);
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder setAllocBreakdownHistory(
          int index, org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown.Builder builderForValue) {
        copyOnWrite();
        instance.setAllocBreakdownHistory(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder addAllocBreakdownHistory(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown value) {
        copyOnWrite();
        instance.addAllocBreakdownHistory(value);
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder addAllocBreakdownHistory(
          int index, org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown value) {
        copyOnWrite();
        instance.addAllocBreakdownHistory(index, value);
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder addAllocBreakdownHistory(
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown.Builder builderForValue) {
        copyOnWrite();
        instance.addAllocBreakdownHistory(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder addAllocBreakdownHistory(
          int index, org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown.Builder builderForValue) {
        copyOnWrite();
        instance.addAllocBreakdownHistory(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder addAllAllocBreakdownHistory(
          java.lang.Iterable<? extends org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown> values) {
        copyOnWrite();
        instance.addAllAllocBreakdownHistory(values);
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder clearAllocBreakdownHistory() {
        copyOnWrite();
        instance.clearAllocBreakdownHistory();
        return this;
      }
      /**
       * <pre>
       * A record of past allocation data leading up to the circumstances that
       * generated the current leak report.
       * A new snapshot is taken every |analysis_interval_bytes| of memory
       * allocation. The oldest record is at the beginning. The most recent record,
       * taken at the time the report was generated, is at the end.
       * </pre>
       *
       * <code>repeated .metrics.MemoryLeakReportProto.AllocationBreakdown alloc_breakdown_history = 4;</code>
       */
      public Builder removeAllocBreakdownHistory(int index) {
        copyOnWrite();
        instance.removeAllocBreakdownHistory(index);
        return this;
      }

      /**
       * <pre>
       * The following two fields describe the last increasing trend in the number
       * of allocations from the size and call stack that generated this
       * leak report.
       * |num_rising_intervals| equals timeslot_now - timeslot_drop,
       * where timeslot_drop is the timeslot number of the last frame that saw
       * a drop in the number of allocations, or the first frame in the history
       * if there were no drops (history is cleared when the net number of
       * allocations hits 0).
       * If it is &lt; 32, it will be visible in the allocation history graph.
       * If it is &gt;= 32, it will not be seen in the graph.
       * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
       * </pre>
       *
       * <code>optional uint32 num_rising_intervals = 7;</code>
       * @return Whether the numRisingIntervals field is set.
       */
      @java.lang.Override
      public boolean hasNumRisingIntervals() {
        return instance.hasNumRisingIntervals();
      }
      /**
       * <pre>
       * The following two fields describe the last increasing trend in the number
       * of allocations from the size and call stack that generated this
       * leak report.
       * |num_rising_intervals| equals timeslot_now - timeslot_drop,
       * where timeslot_drop is the timeslot number of the last frame that saw
       * a drop in the number of allocations, or the first frame in the history
       * if there were no drops (history is cleared when the net number of
       * allocations hits 0).
       * If it is &lt; 32, it will be visible in the allocation history graph.
       * If it is &gt;= 32, it will not be seen in the graph.
       * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
       * </pre>
       *
       * <code>optional uint32 num_rising_intervals = 7;</code>
       * @return The numRisingIntervals.
       */
      @java.lang.Override
      public int getNumRisingIntervals() {
        return instance.getNumRisingIntervals();
      }
      /**
       * <pre>
       * The following two fields describe the last increasing trend in the number
       * of allocations from the size and call stack that generated this
       * leak report.
       * |num_rising_intervals| equals timeslot_now - timeslot_drop,
       * where timeslot_drop is the timeslot number of the last frame that saw
       * a drop in the number of allocations, or the first frame in the history
       * if there were no drops (history is cleared when the net number of
       * allocations hits 0).
       * If it is &lt; 32, it will be visible in the allocation history graph.
       * If it is &gt;= 32, it will not be seen in the graph.
       * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
       * </pre>
       *
       * <code>optional uint32 num_rising_intervals = 7;</code>
       * @param value The numRisingIntervals to set.
       * @return This builder for chaining.
       */
      public Builder setNumRisingIntervals(int value) {
        copyOnWrite();
        instance.setNumRisingIntervals(value);
        return this;
      }
      /**
       * <pre>
       * The following two fields describe the last increasing trend in the number
       * of allocations from the size and call stack that generated this
       * leak report.
       * |num_rising_intervals| equals timeslot_now - timeslot_drop,
       * where timeslot_drop is the timeslot number of the last frame that saw
       * a drop in the number of allocations, or the first frame in the history
       * if there were no drops (history is cleared when the net number of
       * allocations hits 0).
       * If it is &lt; 32, it will be visible in the allocation history graph.
       * If it is &gt;= 32, it will not be seen in the graph.
       * E.g. for history [3,2,4,4,7] |num_rising_intervals| equals 3.
       * </pre>
       *
       * <code>optional uint32 num_rising_intervals = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumRisingIntervals() {
        copyOnWrite();
        instance.clearNumRisingIntervals();
        return this;
      }

      /**
       * <pre>
       * Indicates the magnitude of the current uptrend in allocations.
       * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
       * </pre>
       *
       * <code>optional uint32 num_allocs_increase = 8;</code>
       * @return Whether the numAllocsIncrease field is set.
       */
      @java.lang.Override
      public boolean hasNumAllocsIncrease() {
        return instance.hasNumAllocsIncrease();
      }
      /**
       * <pre>
       * Indicates the magnitude of the current uptrend in allocations.
       * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
       * </pre>
       *
       * <code>optional uint32 num_allocs_increase = 8;</code>
       * @return The numAllocsIncrease.
       */
      @java.lang.Override
      public int getNumAllocsIncrease() {
        return instance.getNumAllocsIncrease();
      }
      /**
       * <pre>
       * Indicates the magnitude of the current uptrend in allocations.
       * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
       * </pre>
       *
       * <code>optional uint32 num_allocs_increase = 8;</code>
       * @param value The numAllocsIncrease to set.
       * @return This builder for chaining.
       */
      public Builder setNumAllocsIncrease(int value) {
        copyOnWrite();
        instance.setNumAllocsIncrease(value);
        return this;
      }
      /**
       * <pre>
       * Indicates the magnitude of the current uptrend in allocations.
       * E.g. for history [3,2,4,4,7] |num_allocs_increase| equals 5.
       * </pre>
       *
       * <code>optional uint32 num_allocs_increase = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumAllocsIncrease() {
        copyOnWrite();
        instance.clearNumAllocsIncrease();
        return this;
      }

      /**
       * <pre>
       * Information about the memory usage from the OS collected right after
       * the leak report was created in the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
       */
      @java.lang.Override
      public boolean hasMemoryUsageInfo() {
        return instance.hasMemoryUsageInfo();
      }
      /**
       * <pre>
       * Information about the memory usage from the OS collected right after
       * the leak report was created in the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo getMemoryUsageInfo() {
        return instance.getMemoryUsageInfo();
      }
      /**
       * <pre>
       * Information about the memory usage from the OS collected right after
       * the leak report was created in the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
       */
      public Builder setMemoryUsageInfo(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo value) {
        copyOnWrite();
        instance.setMemoryUsageInfo(value);
        return this;
        }
      /**
       * <pre>
       * Information about the memory usage from the OS collected right after
       * the leak report was created in the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
       */
      public Builder setMemoryUsageInfo(
          org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setMemoryUsageInfo(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Information about the memory usage from the OS collected right after
       * the leak report was created in the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
       */
      public Builder mergeMemoryUsageInfo(org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.MemoryUsageInfo value) {
        copyOnWrite();
        instance.mergeMemoryUsageInfo(value);
        return this;
      }
      /**
       * <pre>
       * Information about the memory usage from the OS collected right after
       * the leak report was created in the leak detector.
       * </pre>
       *
       * <code>optional .metrics.MemoryLeakReportProto.MemoryUsageInfo memory_usage_info = 9;</code>
       */
      public Builder clearMemoryUsageInfo() {  copyOnWrite();
        instance.clearMemoryUsageInfo();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:metrics.MemoryLeakReportProto)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "callStack_",
              "sizeBytes_",
              "params_",
              "allocBreakdownHistory_",
              org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.AllocationBreakdown.class,
              "sourceProcess_",
              org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.ProcessType.internalGetVerifier(),
              "buildId_",
              "numRisingIntervals_",
              "numAllocsIncrease_",
              "memoryUsageInfo_",
            };
            java.lang.String info =
                "\u0001\t\u0000\u0001\u0001\t\t\u0000\u0002\u0000\u0001\u0015\u0002\u100b\u0000\u0003" +
                "\u1009\u0001\u0004\u001b\u0005\u100c\u0002\u0006\u100a\u0003\u0007\u100b\u0004\b" +
                "\u100b\u0005\t\u1009\u0006";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:metrics.MemoryLeakReportProto)
    private static final org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto DEFAULT_INSTANCE;
    static {
      MemoryLeakReportProto defaultInstance = new MemoryLeakReportProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MemoryLeakReportProto.class, defaultInstance);
    }

    public static org.chromium.components.metrics.MemoryLeakReport.MemoryLeakReportProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MemoryLeakReportProto> PARSER;

    public static com.google.protobuf.Parser<MemoryLeakReportProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
