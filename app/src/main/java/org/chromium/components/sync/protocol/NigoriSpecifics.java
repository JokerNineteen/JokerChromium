// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/nigori_specifics.proto

package org.chromium.components.sync.protocol;

/**
 * <pre>
 * Properties of nigori sync object.
 * </pre>
 *
 * Protobuf type {@code sync_pb.NigoriSpecifics}
 */
public  final class NigoriSpecifics extends
    com.google.protobuf.GeneratedMessageLite<
        NigoriSpecifics, NigoriSpecifics.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.NigoriSpecifics)
    NigoriSpecificsOrBuilder {
  private NigoriSpecifics() {
    passphraseType_ = 1;
    customPassphraseKeyDerivationSalt_ = "";
  }
  /**
   * <pre>
   * The state of the passphrase required to decrypt |encryption_keybag|.
   * </pre>
   *
   * Protobuf enum {@code sync_pb.NigoriSpecifics.PassphraseType}
   */
  public enum PassphraseType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * Proto enums should begin with an 'unknown' value for switch statements,
     * unknown fields, etc.
     * </pre>
     *
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <pre>
     * Gaia-based encryption passphrase. Legacy.
     * </pre>
     *
     * <code>IMPLICIT_PASSPHRASE = 1;</code>
     */
    IMPLICIT_PASSPHRASE(1),
    /**
     * <pre>
     * Keystore key encryption passphrase. Uses |keystore_bootstrap| to
     * decrypt |encryption_keybag|.
     * </pre>
     *
     * <code>KEYSTORE_PASSPHRASE = 2;</code>
     */
    KEYSTORE_PASSPHRASE(2),
    /**
     * <pre>
     * Previous Gaia-based passphrase frozen and treated as a custom passphrase.
     * </pre>
     *
     * <code>FROZEN_IMPLICIT_PASSPHRASE = 3;</code>
     */
    FROZEN_IMPLICIT_PASSPHRASE(3),
    /**
     * <pre>
     * User provided custom passphrase.
     * </pre>
     *
     * <code>CUSTOM_PASSPHRASE = 4;</code>
     */
    CUSTOM_PASSPHRASE(4),
    /**
     * <pre>
     * Encryption key provided by a trusted vault.
     * </pre>
     *
     * <code>TRUSTED_VAULT_PASSPHRASE = 5;</code>
     */
    TRUSTED_VAULT_PASSPHRASE(5),
    ;

    /**
     * <pre>
     * Proto enums should begin with an 'unknown' value for switch statements,
     * unknown fields, etc.
     * </pre>
     *
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <pre>
     * Gaia-based encryption passphrase. Legacy.
     * </pre>
     *
     * <code>IMPLICIT_PASSPHRASE = 1;</code>
     */
    public static final int IMPLICIT_PASSPHRASE_VALUE = 1;
    /**
     * <pre>
     * Keystore key encryption passphrase. Uses |keystore_bootstrap| to
     * decrypt |encryption_keybag|.
     * </pre>
     *
     * <code>KEYSTORE_PASSPHRASE = 2;</code>
     */
    public static final int KEYSTORE_PASSPHRASE_VALUE = 2;
    /**
     * <pre>
     * Previous Gaia-based passphrase frozen and treated as a custom passphrase.
     * </pre>
     *
     * <code>FROZEN_IMPLICIT_PASSPHRASE = 3;</code>
     */
    public static final int FROZEN_IMPLICIT_PASSPHRASE_VALUE = 3;
    /**
     * <pre>
     * User provided custom passphrase.
     * </pre>
     *
     * <code>CUSTOM_PASSPHRASE = 4;</code>
     */
    public static final int CUSTOM_PASSPHRASE_VALUE = 4;
    /**
     * <pre>
     * Encryption key provided by a trusted vault.
     * </pre>
     *
     * <code>TRUSTED_VAULT_PASSPHRASE = 5;</code>
     */
    public static final int TRUSTED_VAULT_PASSPHRASE_VALUE = 5;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PassphraseType valueOf(int value) {
      return forNumber(value);
    }

    public static PassphraseType forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return IMPLICIT_PASSPHRASE;
        case 2: return KEYSTORE_PASSPHRASE;
        case 3: return FROZEN_IMPLICIT_PASSPHRASE;
        case 4: return CUSTOM_PASSPHRASE;
        case 5: return TRUSTED_VAULT_PASSPHRASE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PassphraseType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PassphraseType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PassphraseType>() {
            @java.lang.Override
            public PassphraseType findValueByNumber(int number) {
              return PassphraseType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return PassphraseTypeVerifier.INSTANCE;
    }

    private static final class PassphraseTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PassphraseTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return PassphraseType.forNumber(number) != null;
            }
          };

    private final int value;

    private PassphraseType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.NigoriSpecifics.PassphraseType)
  }

  /**
   * Protobuf enum {@code sync_pb.NigoriSpecifics.KeyDerivationMethod}
   */
  public enum KeyDerivationMethod
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * This comes from a &lt;= M69 client, who does not know about the field
     * (but implicitly uses PBKDF2_HMAC_SHA1_1003).
     * </pre>
     *
     * <code>UNSPECIFIED = 0;</code>
     */
    UNSPECIFIED(0),
    /**
     * <pre>
     * PBKDF2-HMAC-SHA1 with 1003 iterations and constant hardcoded salt. Was
     * implicitly used in &lt;= M69.
     * </pre>
     *
     * <code>PBKDF2_HMAC_SHA1_1003 = 1;</code>
     */
    PBKDF2_HMAC_SHA1_1003(1),
    /**
     * <pre>
     * scrypt with N = 2^13, r = 8, p = 11 and random salt. Was added in M70.
     * </pre>
     *
     * <code>SCRYPT_8192_8_11 = 2;</code>
     */
    SCRYPT_8192_8_11(2),
    ;

    /**
     * <pre>
     * This comes from a &lt;= M69 client, who does not know about the field
     * (but implicitly uses PBKDF2_HMAC_SHA1_1003).
     * </pre>
     *
     * <code>UNSPECIFIED = 0;</code>
     */
    public static final int UNSPECIFIED_VALUE = 0;
    /**
     * <pre>
     * PBKDF2-HMAC-SHA1 with 1003 iterations and constant hardcoded salt. Was
     * implicitly used in &lt;= M69.
     * </pre>
     *
     * <code>PBKDF2_HMAC_SHA1_1003 = 1;</code>
     */
    public static final int PBKDF2_HMAC_SHA1_1003_VALUE = 1;
    /**
     * <pre>
     * scrypt with N = 2^13, r = 8, p = 11 and random salt. Was added in M70.
     * </pre>
     *
     * <code>SCRYPT_8192_8_11 = 2;</code>
     */
    public static final int SCRYPT_8192_8_11_VALUE = 2;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static KeyDerivationMethod valueOf(int value) {
      return forNumber(value);
    }

    public static KeyDerivationMethod forNumber(int value) {
      switch (value) {
        case 0: return UNSPECIFIED;
        case 1: return PBKDF2_HMAC_SHA1_1003;
        case 2: return SCRYPT_8192_8_11;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<KeyDerivationMethod>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        KeyDerivationMethod> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<KeyDerivationMethod>() {
            @java.lang.Override
            public KeyDerivationMethod findValueByNumber(int number) {
              return KeyDerivationMethod.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return KeyDerivationMethodVerifier.INSTANCE;
    }

    private static final class KeyDerivationMethodVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new KeyDerivationMethodVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return KeyDerivationMethod.forNumber(number) != null;
            }
          };

    private final int value;

    private KeyDerivationMethod(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.NigoriSpecifics.KeyDerivationMethod)
  }

  private int bitField0_;
  private int bitField1_;
  public static final int ENCRYPTION_KEYBAG_FIELD_NUMBER = 1;
  private org.chromium.components.sync.protocol.EncryptedData encryptionKeybag_;
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  @java.lang.Override
  public boolean hasEncryptionKeybag() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.EncryptedData getEncryptionKeybag() {
    return encryptionKeybag_ == null ? org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance() : encryptionKeybag_;
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  private void setEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
    value.getClass();
  encryptionKeybag_ = value;
    bitField0_ |= 0x00000001;
    }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
    value.getClass();
  if (encryptionKeybag_ != null &&
        encryptionKeybag_ != org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance()) {
      encryptionKeybag_ =
        org.chromium.components.sync.protocol.EncryptedData.newBuilder(encryptionKeybag_).mergeFrom(value).buildPartial();
    } else {
      encryptionKeybag_ = value;
    }
    bitField0_ |= 0x00000001;
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  private void clearEncryptionKeybag() {  encryptionKeybag_ = null;
    bitField0_ = (bitField0_ & ~0x00000001);
  }

  public static final int KEYBAG_IS_FROZEN_FIELD_NUMBER = 2;
  private boolean keybagIsFrozen_;
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   * @return Whether the keybagIsFrozen field is set.
   */
  @java.lang.Override
  public boolean hasKeybagIsFrozen() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   * @return The keybagIsFrozen.
   */
  @java.lang.Override
  public boolean getKeybagIsFrozen() {
    return keybagIsFrozen_;
  }
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   * @param value The keybagIsFrozen to set.
   */
  private void setKeybagIsFrozen(boolean value) {
    bitField0_ |= 0x00000002;
    keybagIsFrozen_ = value;
  }
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   */
  private void clearKeybagIsFrozen() {
    bitField0_ = (bitField0_ & ~0x00000002);
    keybagIsFrozen_ = false;
  }

  public static final int ENCRYPT_BOOKMARKS_FIELD_NUMBER = 13;
  private boolean encryptBookmarks_;
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   * @return Whether the encryptBookmarks field is set.
   */
  @java.lang.Override
  public boolean hasEncryptBookmarks() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   * @return The encryptBookmarks.
   */
  @java.lang.Override
  public boolean getEncryptBookmarks() {
    return encryptBookmarks_;
  }
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   * @param value The encryptBookmarks to set.
   */
  private void setEncryptBookmarks(boolean value) {
    bitField0_ |= 0x00000004;
    encryptBookmarks_ = value;
  }
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   */
  private void clearEncryptBookmarks() {
    bitField0_ = (bitField0_ & ~0x00000004);
    encryptBookmarks_ = false;
  }

  public static final int ENCRYPT_PREFERENCES_FIELD_NUMBER = 14;
  private boolean encryptPreferences_;
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   * @return Whether the encryptPreferences field is set.
   */
  @java.lang.Override
  public boolean hasEncryptPreferences() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   * @return The encryptPreferences.
   */
  @java.lang.Override
  public boolean getEncryptPreferences() {
    return encryptPreferences_;
  }
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   * @param value The encryptPreferences to set.
   */
  private void setEncryptPreferences(boolean value) {
    bitField0_ |= 0x00000008;
    encryptPreferences_ = value;
  }
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   */
  private void clearEncryptPreferences() {
    bitField0_ = (bitField0_ & ~0x00000008);
    encryptPreferences_ = false;
  }

  public static final int ENCRYPT_AUTOFILL_PROFILE_FIELD_NUMBER = 15;
  private boolean encryptAutofillProfile_;
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   * @return Whether the encryptAutofillProfile field is set.
   */
  @java.lang.Override
  public boolean hasEncryptAutofillProfile() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   * @return The encryptAutofillProfile.
   */
  @java.lang.Override
  public boolean getEncryptAutofillProfile() {
    return encryptAutofillProfile_;
  }
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   * @param value The encryptAutofillProfile to set.
   */
  private void setEncryptAutofillProfile(boolean value) {
    bitField0_ |= 0x00000010;
    encryptAutofillProfile_ = value;
  }
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   */
  private void clearEncryptAutofillProfile() {
    bitField0_ = (bitField0_ & ~0x00000010);
    encryptAutofillProfile_ = false;
  }

  public static final int ENCRYPT_AUTOFILL_FIELD_NUMBER = 16;
  private boolean encryptAutofill_;
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   * @return Whether the encryptAutofill field is set.
   */
  @java.lang.Override
  public boolean hasEncryptAutofill() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   * @return The encryptAutofill.
   */
  @java.lang.Override
  public boolean getEncryptAutofill() {
    return encryptAutofill_;
  }
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   * @param value The encryptAutofill to set.
   */
  private void setEncryptAutofill(boolean value) {
    bitField0_ |= 0x00000020;
    encryptAutofill_ = value;
  }
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   */
  private void clearEncryptAutofill() {
    bitField0_ = (bitField0_ & ~0x00000020);
    encryptAutofill_ = false;
  }

  public static final int ENCRYPT_THEMES_FIELD_NUMBER = 17;
  private boolean encryptThemes_;
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   * @return Whether the encryptThemes field is set.
   */
  @java.lang.Override
  public boolean hasEncryptThemes() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   * @return The encryptThemes.
   */
  @java.lang.Override
  public boolean getEncryptThemes() {
    return encryptThemes_;
  }
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   * @param value The encryptThemes to set.
   */
  private void setEncryptThemes(boolean value) {
    bitField0_ |= 0x00000040;
    encryptThemes_ = value;
  }
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   */
  private void clearEncryptThemes() {
    bitField0_ = (bitField0_ & ~0x00000040);
    encryptThemes_ = false;
  }

  public static final int ENCRYPT_TYPED_URLS_FIELD_NUMBER = 18;
  private boolean encryptTypedUrls_;
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   * @return Whether the encryptTypedUrls field is set.
   */
  @java.lang.Override
  public boolean hasEncryptTypedUrls() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   * @return The encryptTypedUrls.
   */
  @java.lang.Override
  public boolean getEncryptTypedUrls() {
    return encryptTypedUrls_;
  }
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   * @param value The encryptTypedUrls to set.
   */
  private void setEncryptTypedUrls(boolean value) {
    bitField0_ |= 0x00000080;
    encryptTypedUrls_ = value;
  }
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   */
  private void clearEncryptTypedUrls() {
    bitField0_ = (bitField0_ & ~0x00000080);
    encryptTypedUrls_ = false;
  }

  public static final int ENCRYPT_EXTENSIONS_FIELD_NUMBER = 19;
  private boolean encryptExtensions_;
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   * @return Whether the encryptExtensions field is set.
   */
  @java.lang.Override
  public boolean hasEncryptExtensions() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   * @return The encryptExtensions.
   */
  @java.lang.Override
  public boolean getEncryptExtensions() {
    return encryptExtensions_;
  }
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   * @param value The encryptExtensions to set.
   */
  private void setEncryptExtensions(boolean value) {
    bitField0_ |= 0x00000100;
    encryptExtensions_ = value;
  }
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   */
  private void clearEncryptExtensions() {
    bitField0_ = (bitField0_ & ~0x00000100);
    encryptExtensions_ = false;
  }

  public static final int ENCRYPT_SESSIONS_FIELD_NUMBER = 20;
  private boolean encryptSessions_;
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   * @return Whether the encryptSessions field is set.
   */
  @java.lang.Override
  public boolean hasEncryptSessions() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   * @return The encryptSessions.
   */
  @java.lang.Override
  public boolean getEncryptSessions() {
    return encryptSessions_;
  }
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   * @param value The encryptSessions to set.
   */
  private void setEncryptSessions(boolean value) {
    bitField0_ |= 0x00000200;
    encryptSessions_ = value;
  }
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   */
  private void clearEncryptSessions() {
    bitField0_ = (bitField0_ & ~0x00000200);
    encryptSessions_ = false;
  }

  public static final int ENCRYPT_APPS_FIELD_NUMBER = 21;
  private boolean encryptApps_;
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   * @return Whether the encryptApps field is set.
   */
  @java.lang.Override
  public boolean hasEncryptApps() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   * @return The encryptApps.
   */
  @java.lang.Override
  public boolean getEncryptApps() {
    return encryptApps_;
  }
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   * @param value The encryptApps to set.
   */
  private void setEncryptApps(boolean value) {
    bitField0_ |= 0x00000400;
    encryptApps_ = value;
  }
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   */
  private void clearEncryptApps() {
    bitField0_ = (bitField0_ & ~0x00000400);
    encryptApps_ = false;
  }

  public static final int ENCRYPT_SEARCH_ENGINES_FIELD_NUMBER = 22;
  private boolean encryptSearchEngines_;
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   * @return Whether the encryptSearchEngines field is set.
   */
  @java.lang.Override
  public boolean hasEncryptSearchEngines() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   * @return The encryptSearchEngines.
   */
  @java.lang.Override
  public boolean getEncryptSearchEngines() {
    return encryptSearchEngines_;
  }
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   * @param value The encryptSearchEngines to set.
   */
  private void setEncryptSearchEngines(boolean value) {
    bitField0_ |= 0x00000800;
    encryptSearchEngines_ = value;
  }
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   */
  private void clearEncryptSearchEngines() {
    bitField0_ = (bitField0_ & ~0x00000800);
    encryptSearchEngines_ = false;
  }

  public static final int ENCRYPT_EVERYTHING_FIELD_NUMBER = 24;
  private boolean encryptEverything_;
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   * @return Whether the encryptEverything field is set.
   */
  @java.lang.Override
  public boolean hasEncryptEverything() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   * @return The encryptEverything.
   */
  @java.lang.Override
  public boolean getEncryptEverything() {
    return encryptEverything_;
  }
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   * @param value The encryptEverything to set.
   */
  private void setEncryptEverything(boolean value) {
    bitField0_ |= 0x00001000;
    encryptEverything_ = value;
  }
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   */
  private void clearEncryptEverything() {
    bitField0_ = (bitField0_ & ~0x00001000);
    encryptEverything_ = false;
  }

  public static final int ENCRYPT_EXTENSION_SETTINGS_FIELD_NUMBER = 25;
  private boolean encryptExtensionSettings_;
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   * @return Whether the encryptExtensionSettings field is set.
   */
  @java.lang.Override
  public boolean hasEncryptExtensionSettings() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   * @return The encryptExtensionSettings.
   */
  @java.lang.Override
  public boolean getEncryptExtensionSettings() {
    return encryptExtensionSettings_;
  }
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   * @param value The encryptExtensionSettings to set.
   */
  private void setEncryptExtensionSettings(boolean value) {
    bitField0_ |= 0x00002000;
    encryptExtensionSettings_ = value;
  }
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   */
  private void clearEncryptExtensionSettings() {
    bitField0_ = (bitField0_ & ~0x00002000);
    encryptExtensionSettings_ = false;
  }

  public static final int ENCRYPT_APP_NOTIFICATIONS_FIELD_NUMBER = 26;
  private boolean encryptAppNotifications_;
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   * @return Whether the encryptAppNotifications field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasEncryptAppNotifications() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   * @return The encryptAppNotifications.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean getEncryptAppNotifications() {
    return encryptAppNotifications_;
  }
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   * @param value The encryptAppNotifications to set.
   */
  private void setEncryptAppNotifications(boolean value) {
    bitField0_ |= 0x00004000;
    encryptAppNotifications_ = value;
  }
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   */
  private void clearEncryptAppNotifications() {
    bitField0_ = (bitField0_ & ~0x00004000);
    encryptAppNotifications_ = false;
  }

  public static final int ENCRYPT_APP_SETTINGS_FIELD_NUMBER = 27;
  private boolean encryptAppSettings_;
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   * @return Whether the encryptAppSettings field is set.
   */
  @java.lang.Override
  public boolean hasEncryptAppSettings() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   * @return The encryptAppSettings.
   */
  @java.lang.Override
  public boolean getEncryptAppSettings() {
    return encryptAppSettings_;
  }
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   * @param value The encryptAppSettings to set.
   */
  private void setEncryptAppSettings(boolean value) {
    bitField0_ |= 0x00008000;
    encryptAppSettings_ = value;
  }
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   */
  private void clearEncryptAppSettings() {
    bitField0_ = (bitField0_ & ~0x00008000);
    encryptAppSettings_ = false;
  }

  public static final int SYNC_TAB_FAVICONS_FIELD_NUMBER = 29;
  private boolean syncTabFavicons_;
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   * @return Whether the syncTabFavicons field is set.
   */
  @java.lang.Override
  public boolean hasSyncTabFavicons() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   * @return The syncTabFavicons.
   */
  @java.lang.Override
  public boolean getSyncTabFavicons() {
    return syncTabFavicons_;
  }
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   * @param value The syncTabFavicons to set.
   */
  private void setSyncTabFavicons(boolean value) {
    bitField0_ |= 0x00010000;
    syncTabFavicons_ = value;
  }
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   */
  private void clearSyncTabFavicons() {
    bitField0_ = (bitField0_ & ~0x00010000);
    syncTabFavicons_ = false;
  }

  public static final int PASSPHRASE_TYPE_FIELD_NUMBER = 30;
  private int passphraseType_;
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   * @return Whether the passphraseType field is set.
   */
  @java.lang.Override
  public boolean hasPassphraseType() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   * @return The passphraseType.
   */
  @java.lang.Override
  public int getPassphraseType() {
    return passphraseType_;
  }
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   * @param value The passphraseType to set.
   */
  private void setPassphraseType(int value) {
    bitField0_ |= 0x00020000;
    passphraseType_ = value;
  }
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   */
  private void clearPassphraseType() {
    bitField0_ = (bitField0_ & ~0x00020000);
    passphraseType_ = 1;
  }

  public static final int KEYSTORE_DECRYPTOR_TOKEN_FIELD_NUMBER = 31;
  private org.chromium.components.sync.protocol.EncryptedData keystoreDecryptorToken_;
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  @java.lang.Override
  public boolean hasKeystoreDecryptorToken() {
    return ((bitField0_ & 0x00040000) != 0);
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.EncryptedData getKeystoreDecryptorToken() {
    return keystoreDecryptorToken_ == null ? org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance() : keystoreDecryptorToken_;
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  private void setKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
    value.getClass();
  keystoreDecryptorToken_ = value;
    bitField0_ |= 0x00040000;
    }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
    value.getClass();
  if (keystoreDecryptorToken_ != null &&
        keystoreDecryptorToken_ != org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance()) {
      keystoreDecryptorToken_ =
        org.chromium.components.sync.protocol.EncryptedData.newBuilder(keystoreDecryptorToken_).mergeFrom(value).buildPartial();
    } else {
      keystoreDecryptorToken_ = value;
    }
    bitField0_ |= 0x00040000;
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  private void clearKeystoreDecryptorToken() {  keystoreDecryptorToken_ = null;
    bitField0_ = (bitField0_ & ~0x00040000);
  }

  public static final int KEYSTORE_MIGRATION_TIME_FIELD_NUMBER = 32;
  private long keystoreMigrationTime_;
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   * @return Whether the keystoreMigrationTime field is set.
   */
  @java.lang.Override
  public boolean hasKeystoreMigrationTime() {
    return ((bitField0_ & 0x00080000) != 0);
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   * @return The keystoreMigrationTime.
   */
  @java.lang.Override
  public long getKeystoreMigrationTime() {
    return keystoreMigrationTime_;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   * @param value The keystoreMigrationTime to set.
   */
  private void setKeystoreMigrationTime(long value) {
    bitField0_ |= 0x00080000;
    keystoreMigrationTime_ = value;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   */
  private void clearKeystoreMigrationTime() {
    bitField0_ = (bitField0_ & ~0x00080000);
    keystoreMigrationTime_ = 0L;
  }

  public static final int CUSTOM_PASSPHRASE_TIME_FIELD_NUMBER = 33;
  private long customPassphraseTime_;
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   * @return Whether the customPassphraseTime field is set.
   */
  @java.lang.Override
  public boolean hasCustomPassphraseTime() {
    return ((bitField0_ & 0x00100000) != 0);
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   * @return The customPassphraseTime.
   */
  @java.lang.Override
  public long getCustomPassphraseTime() {
    return customPassphraseTime_;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   * @param value The customPassphraseTime to set.
   */
  private void setCustomPassphraseTime(long value) {
    bitField0_ |= 0x00100000;
    customPassphraseTime_ = value;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   */
  private void clearCustomPassphraseTime() {
    bitField0_ = (bitField0_ & ~0x00100000);
    customPassphraseTime_ = 0L;
  }

  public static final int ENCRYPT_DICTIONARY_FIELD_NUMBER = 34;
  private boolean encryptDictionary_;
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   * @return Whether the encryptDictionary field is set.
   */
  @java.lang.Override
  public boolean hasEncryptDictionary() {
    return ((bitField0_ & 0x00200000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   * @return The encryptDictionary.
   */
  @java.lang.Override
  public boolean getEncryptDictionary() {
    return encryptDictionary_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   * @param value The encryptDictionary to set.
   */
  private void setEncryptDictionary(boolean value) {
    bitField0_ |= 0x00200000;
    encryptDictionary_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   */
  private void clearEncryptDictionary() {
    bitField0_ = (bitField0_ & ~0x00200000);
    encryptDictionary_ = false;
  }

  public static final int ENCRYPT_FAVICON_IMAGES_FIELD_NUMBER = 35;
  private boolean encryptFaviconImages_;
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   * @return Whether the encryptFaviconImages field is set.
   */
  @java.lang.Override
  public boolean hasEncryptFaviconImages() {
    return ((bitField0_ & 0x00400000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   * @return The encryptFaviconImages.
   */
  @java.lang.Override
  public boolean getEncryptFaviconImages() {
    return encryptFaviconImages_;
  }
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   * @param value The encryptFaviconImages to set.
   */
  private void setEncryptFaviconImages(boolean value) {
    bitField0_ |= 0x00400000;
    encryptFaviconImages_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   */
  private void clearEncryptFaviconImages() {
    bitField0_ = (bitField0_ & ~0x00400000);
    encryptFaviconImages_ = false;
  }

  public static final int ENCRYPT_FAVICON_TRACKING_FIELD_NUMBER = 36;
  private boolean encryptFaviconTracking_;
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   * @return Whether the encryptFaviconTracking field is set.
   */
  @java.lang.Override
  public boolean hasEncryptFaviconTracking() {
    return ((bitField0_ & 0x00800000) != 0);
  }
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   * @return The encryptFaviconTracking.
   */
  @java.lang.Override
  public boolean getEncryptFaviconTracking() {
    return encryptFaviconTracking_;
  }
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   * @param value The encryptFaviconTracking to set.
   */
  private void setEncryptFaviconTracking(boolean value) {
    bitField0_ |= 0x00800000;
    encryptFaviconTracking_ = value;
  }
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   */
  private void clearEncryptFaviconTracking() {
    bitField0_ = (bitField0_ & ~0x00800000);
    encryptFaviconTracking_ = false;
  }

  public static final int ENCRYPT_APP_LIST_FIELD_NUMBER = 38;
  private boolean encryptAppList_;
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   * @return Whether the encryptAppList field is set.
   */
  @java.lang.Override
  public boolean hasEncryptAppList() {
    return ((bitField0_ & 0x01000000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   * @return The encryptAppList.
   */
  @java.lang.Override
  public boolean getEncryptAppList() {
    return encryptAppList_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   * @param value The encryptAppList to set.
   */
  private void setEncryptAppList(boolean value) {
    bitField0_ |= 0x01000000;
    encryptAppList_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   */
  private void clearEncryptAppList() {
    bitField0_ = (bitField0_ & ~0x01000000);
    encryptAppList_ = false;
  }

  public static final int ENCRYPT_AUTOFILL_WALLET_METADATA_FIELD_NUMBER = 39;
  private boolean encryptAutofillWalletMetadata_;
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   * @return Whether the encryptAutofillWalletMetadata field is set.
   */
  @java.lang.Override
  public boolean hasEncryptAutofillWalletMetadata() {
    return ((bitField0_ & 0x02000000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   * @return The encryptAutofillWalletMetadata.
   */
  @java.lang.Override
  public boolean getEncryptAutofillWalletMetadata() {
    return encryptAutofillWalletMetadata_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   * @param value The encryptAutofillWalletMetadata to set.
   */
  private void setEncryptAutofillWalletMetadata(boolean value) {
    bitField0_ |= 0x02000000;
    encryptAutofillWalletMetadata_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   */
  private void clearEncryptAutofillWalletMetadata() {
    bitField0_ = (bitField0_ & ~0x02000000);
    encryptAutofillWalletMetadata_ = false;
  }

  public static final int SERVER_ONLY_WAS_MISSING_KEYSTORE_MIGRATION_TIME_FIELD_NUMBER = 40;
  private boolean serverOnlyWasMissingKeystoreMigrationTime_;
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   * @return Whether the serverOnlyWasMissingKeystoreMigrationTime field is set.
   */
  @java.lang.Override
  public boolean hasServerOnlyWasMissingKeystoreMigrationTime() {
    return ((bitField0_ & 0x04000000) != 0);
  }
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   * @return The serverOnlyWasMissingKeystoreMigrationTime.
   */
  @java.lang.Override
  public boolean getServerOnlyWasMissingKeystoreMigrationTime() {
    return serverOnlyWasMissingKeystoreMigrationTime_;
  }
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   * @param value The serverOnlyWasMissingKeystoreMigrationTime to set.
   */
  private void setServerOnlyWasMissingKeystoreMigrationTime(boolean value) {
    bitField0_ |= 0x04000000;
    serverOnlyWasMissingKeystoreMigrationTime_ = value;
  }
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   */
  private void clearServerOnlyWasMissingKeystoreMigrationTime() {
    bitField0_ = (bitField0_ & ~0x04000000);
    serverOnlyWasMissingKeystoreMigrationTime_ = false;
  }

  public static final int ENCRYPT_ARC_PACKAGE_FIELD_NUMBER = 41;
  private boolean encryptArcPackage_;
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   * @return Whether the encryptArcPackage field is set.
   */
  @java.lang.Override
  public boolean hasEncryptArcPackage() {
    return ((bitField0_ & 0x08000000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   * @return The encryptArcPackage.
   */
  @java.lang.Override
  public boolean getEncryptArcPackage() {
    return encryptArcPackage_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   * @param value The encryptArcPackage to set.
   */
  private void setEncryptArcPackage(boolean value) {
    bitField0_ |= 0x08000000;
    encryptArcPackage_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   */
  private void clearEncryptArcPackage() {
    bitField0_ = (bitField0_ & ~0x08000000);
    encryptArcPackage_ = false;
  }

  public static final int ENCRYPT_PRINTERS_FIELD_NUMBER = 42;
  private boolean encryptPrinters_;
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   * @return Whether the encryptPrinters field is set.
   */
  @java.lang.Override
  public boolean hasEncryptPrinters() {
    return ((bitField0_ & 0x10000000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   * @return The encryptPrinters.
   */
  @java.lang.Override
  public boolean getEncryptPrinters() {
    return encryptPrinters_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   * @param value The encryptPrinters to set.
   */
  private void setEncryptPrinters(boolean value) {
    bitField0_ |= 0x10000000;
    encryptPrinters_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   */
  private void clearEncryptPrinters() {
    bitField0_ = (bitField0_ & ~0x10000000);
    encryptPrinters_ = false;
  }

  public static final int ENCRYPT_READING_LIST_FIELD_NUMBER = 43;
  private boolean encryptReadingList_;
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   * @return Whether the encryptReadingList field is set.
   */
  @java.lang.Override
  public boolean hasEncryptReadingList() {
    return ((bitField0_ & 0x20000000) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   * @return The encryptReadingList.
   */
  @java.lang.Override
  public boolean getEncryptReadingList() {
    return encryptReadingList_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   * @param value The encryptReadingList to set.
   */
  private void setEncryptReadingList(boolean value) {
    bitField0_ |= 0x20000000;
    encryptReadingList_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   */
  private void clearEncryptReadingList() {
    bitField0_ = (bitField0_ & ~0x20000000);
    encryptReadingList_ = false;
  }

  public static final int CUSTOM_PASSPHRASE_KEY_DERIVATION_METHOD_FIELD_NUMBER = 45;
  private int customPassphraseKeyDerivationMethod_;
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   * @return Whether the customPassphraseKeyDerivationMethod field is set.
   */
  @java.lang.Override
  public boolean hasCustomPassphraseKeyDerivationMethod() {
    return ((bitField0_ & 0x40000000) != 0);
  }
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   * @return The customPassphraseKeyDerivationMethod.
   */
  @java.lang.Override
  public int getCustomPassphraseKeyDerivationMethod() {
    return customPassphraseKeyDerivationMethod_;
  }
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   * @param value The customPassphraseKeyDerivationMethod to set.
   */
  private void setCustomPassphraseKeyDerivationMethod(int value) {
    bitField0_ |= 0x40000000;
    customPassphraseKeyDerivationMethod_ = value;
  }
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   */
  private void clearCustomPassphraseKeyDerivationMethod() {
    bitField0_ = (bitField0_ & ~0x40000000);
    customPassphraseKeyDerivationMethod_ = 0;
  }

  public static final int CUSTOM_PASSPHRASE_KEY_DERIVATION_SALT_FIELD_NUMBER = 46;
  private java.lang.String customPassphraseKeyDerivationSalt_;
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   * @return Whether the customPassphraseKeyDerivationSalt field is set.
   */
  @java.lang.Override
  public boolean hasCustomPassphraseKeyDerivationSalt() {
    return ((bitField0_ & 0x80000000) != 0);
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   * @return The customPassphraseKeyDerivationSalt.
   */
  @java.lang.Override
  public java.lang.String getCustomPassphraseKeyDerivationSalt() {
    return customPassphraseKeyDerivationSalt_;
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   * @return The bytes for customPassphraseKeyDerivationSalt.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getCustomPassphraseKeyDerivationSaltBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(customPassphraseKeyDerivationSalt_);
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   * @param value The customPassphraseKeyDerivationSalt to set.
   */
  private void setCustomPassphraseKeyDerivationSalt(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x80000000;
    customPassphraseKeyDerivationSalt_ = value;
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  private void clearCustomPassphraseKeyDerivationSalt() {
    bitField0_ = (bitField0_ & ~0x80000000);
    customPassphraseKeyDerivationSalt_ = getDefaultInstance().getCustomPassphraseKeyDerivationSalt();
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   * @param value The bytes for customPassphraseKeyDerivationSalt to set.
   */
  private void setCustomPassphraseKeyDerivationSaltBytes(
      com.google.protobuf.ByteString value) {
    customPassphraseKeyDerivationSalt_ = value.toStringUtf8();
    bitField0_ |= 0x80000000;
  }

  public static final int ENCRYPT_SEND_TAB_TO_SELF_FIELD_NUMBER = 47;
  private boolean encryptSendTabToSelf_;
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   * @return Whether the encryptSendTabToSelf field is set.
   */
  @java.lang.Override
  public boolean hasEncryptSendTabToSelf() {
    return ((bitField1_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   * @return The encryptSendTabToSelf.
   */
  @java.lang.Override
  public boolean getEncryptSendTabToSelf() {
    return encryptSendTabToSelf_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   * @param value The encryptSendTabToSelf to set.
   */
  private void setEncryptSendTabToSelf(boolean value) {
    bitField1_ |= 0x00000001;
    encryptSendTabToSelf_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   */
  private void clearEncryptSendTabToSelf() {
    bitField1_ = (bitField1_ & ~0x00000001);
    encryptSendTabToSelf_ = false;
  }

  public static final int ENCRYPT_WEB_APPS_FIELD_NUMBER = 48;
  private boolean encryptWebApps_;
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   * @return Whether the encryptWebApps field is set.
   */
  @java.lang.Override
  public boolean hasEncryptWebApps() {
    return ((bitField1_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   * @return The encryptWebApps.
   */
  @java.lang.Override
  public boolean getEncryptWebApps() {
    return encryptWebApps_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   * @param value The encryptWebApps to set.
   */
  private void setEncryptWebApps(boolean value) {
    bitField1_ |= 0x00000002;
    encryptWebApps_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   */
  private void clearEncryptWebApps() {
    bitField1_ = (bitField1_ & ~0x00000002);
    encryptWebApps_ = false;
  }

  public static final int ENCRYPT_OS_PREFERENCES_FIELD_NUMBER = 49;
  private boolean encryptOsPreferences_;
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   * @return Whether the encryptOsPreferences field is set.
   */
  @java.lang.Override
  public boolean hasEncryptOsPreferences() {
    return ((bitField1_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   * @return The encryptOsPreferences.
   */
  @java.lang.Override
  public boolean getEncryptOsPreferences() {
    return encryptOsPreferences_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   * @param value The encryptOsPreferences to set.
   */
  private void setEncryptOsPreferences(boolean value) {
    bitField1_ |= 0x00000004;
    encryptOsPreferences_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   */
  private void clearEncryptOsPreferences() {
    bitField1_ = (bitField1_ & ~0x00000004);
    encryptOsPreferences_ = false;
  }

  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.NigoriSpecifics prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * Properties of nigori sync object.
   * </pre>
   *
   * Protobuf type {@code sync_pb.NigoriSpecifics}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.NigoriSpecifics, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.NigoriSpecifics)
      org.chromium.components.sync.protocol.NigoriSpecificsOrBuilder {
    // Construct using org.chromium.components.sync.protocol.NigoriSpecifics.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    @java.lang.Override
    public boolean hasEncryptionKeybag() {
      return instance.hasEncryptionKeybag();
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.EncryptedData getEncryptionKeybag() {
      return instance.getEncryptionKeybag();
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder setEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.setEncryptionKeybag(value);
      return this;
      }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder setEncryptionKeybag(
        org.chromium.components.sync.protocol.EncryptedData.Builder builderForValue) {
      copyOnWrite();
      instance.setEncryptionKeybag(builderForValue.build());
      return this;
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder mergeEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.mergeEncryptionKeybag(value);
      return this;
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder clearEncryptionKeybag() {  copyOnWrite();
      instance.clearEncryptionKeybag();
      return this;
    }

    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     * @return Whether the keybagIsFrozen field is set.
     */
    @java.lang.Override
    public boolean hasKeybagIsFrozen() {
      return instance.hasKeybagIsFrozen();
    }
    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     * @return The keybagIsFrozen.
     */
    @java.lang.Override
    public boolean getKeybagIsFrozen() {
      return instance.getKeybagIsFrozen();
    }
    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     * @param value The keybagIsFrozen to set.
     * @return This builder for chaining.
     */
    public Builder setKeybagIsFrozen(boolean value) {
      copyOnWrite();
      instance.setKeybagIsFrozen(value);
      return this;
    }
    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearKeybagIsFrozen() {
      copyOnWrite();
      instance.clearKeybagIsFrozen();
      return this;
    }

    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     * @return Whether the encryptBookmarks field is set.
     */
    @java.lang.Override
    public boolean hasEncryptBookmarks() {
      return instance.hasEncryptBookmarks();
    }
    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     * @return The encryptBookmarks.
     */
    @java.lang.Override
    public boolean getEncryptBookmarks() {
      return instance.getEncryptBookmarks();
    }
    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     * @param value The encryptBookmarks to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptBookmarks(boolean value) {
      copyOnWrite();
      instance.setEncryptBookmarks(value);
      return this;
    }
    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptBookmarks() {
      copyOnWrite();
      instance.clearEncryptBookmarks();
      return this;
    }

    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     * @return Whether the encryptPreferences field is set.
     */
    @java.lang.Override
    public boolean hasEncryptPreferences() {
      return instance.hasEncryptPreferences();
    }
    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     * @return The encryptPreferences.
     */
    @java.lang.Override
    public boolean getEncryptPreferences() {
      return instance.getEncryptPreferences();
    }
    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     * @param value The encryptPreferences to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptPreferences(boolean value) {
      copyOnWrite();
      instance.setEncryptPreferences(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptPreferences() {
      copyOnWrite();
      instance.clearEncryptPreferences();
      return this;
    }

    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     * @return Whether the encryptAutofillProfile field is set.
     */
    @java.lang.Override
    public boolean hasEncryptAutofillProfile() {
      return instance.hasEncryptAutofillProfile();
    }
    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     * @return The encryptAutofillProfile.
     */
    @java.lang.Override
    public boolean getEncryptAutofillProfile() {
      return instance.getEncryptAutofillProfile();
    }
    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     * @param value The encryptAutofillProfile to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptAutofillProfile(boolean value) {
      copyOnWrite();
      instance.setEncryptAutofillProfile(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptAutofillProfile() {
      copyOnWrite();
      instance.clearEncryptAutofillProfile();
      return this;
    }

    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     * @return Whether the encryptAutofill field is set.
     */
    @java.lang.Override
    public boolean hasEncryptAutofill() {
      return instance.hasEncryptAutofill();
    }
    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     * @return The encryptAutofill.
     */
    @java.lang.Override
    public boolean getEncryptAutofill() {
      return instance.getEncryptAutofill();
    }
    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     * @param value The encryptAutofill to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptAutofill(boolean value) {
      copyOnWrite();
      instance.setEncryptAutofill(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptAutofill() {
      copyOnWrite();
      instance.clearEncryptAutofill();
      return this;
    }

    /**
     * <code>optional bool encrypt_themes = 17;</code>
     * @return Whether the encryptThemes field is set.
     */
    @java.lang.Override
    public boolean hasEncryptThemes() {
      return instance.hasEncryptThemes();
    }
    /**
     * <code>optional bool encrypt_themes = 17;</code>
     * @return The encryptThemes.
     */
    @java.lang.Override
    public boolean getEncryptThemes() {
      return instance.getEncryptThemes();
    }
    /**
     * <code>optional bool encrypt_themes = 17;</code>
     * @param value The encryptThemes to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptThemes(boolean value) {
      copyOnWrite();
      instance.setEncryptThemes(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_themes = 17;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptThemes() {
      copyOnWrite();
      instance.clearEncryptThemes();
      return this;
    }

    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     * @return Whether the encryptTypedUrls field is set.
     */
    @java.lang.Override
    public boolean hasEncryptTypedUrls() {
      return instance.hasEncryptTypedUrls();
    }
    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     * @return The encryptTypedUrls.
     */
    @java.lang.Override
    public boolean getEncryptTypedUrls() {
      return instance.getEncryptTypedUrls();
    }
    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     * @param value The encryptTypedUrls to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptTypedUrls(boolean value) {
      copyOnWrite();
      instance.setEncryptTypedUrls(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptTypedUrls() {
      copyOnWrite();
      instance.clearEncryptTypedUrls();
      return this;
    }

    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     * @return Whether the encryptExtensions field is set.
     */
    @java.lang.Override
    public boolean hasEncryptExtensions() {
      return instance.hasEncryptExtensions();
    }
    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     * @return The encryptExtensions.
     */
    @java.lang.Override
    public boolean getEncryptExtensions() {
      return instance.getEncryptExtensions();
    }
    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     * @param value The encryptExtensions to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptExtensions(boolean value) {
      copyOnWrite();
      instance.setEncryptExtensions(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptExtensions() {
      copyOnWrite();
      instance.clearEncryptExtensions();
      return this;
    }

    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     * @return Whether the encryptSessions field is set.
     */
    @java.lang.Override
    public boolean hasEncryptSessions() {
      return instance.hasEncryptSessions();
    }
    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     * @return The encryptSessions.
     */
    @java.lang.Override
    public boolean getEncryptSessions() {
      return instance.getEncryptSessions();
    }
    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     * @param value The encryptSessions to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptSessions(boolean value) {
      copyOnWrite();
      instance.setEncryptSessions(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptSessions() {
      copyOnWrite();
      instance.clearEncryptSessions();
      return this;
    }

    /**
     * <code>optional bool encrypt_apps = 21;</code>
     * @return Whether the encryptApps field is set.
     */
    @java.lang.Override
    public boolean hasEncryptApps() {
      return instance.hasEncryptApps();
    }
    /**
     * <code>optional bool encrypt_apps = 21;</code>
     * @return The encryptApps.
     */
    @java.lang.Override
    public boolean getEncryptApps() {
      return instance.getEncryptApps();
    }
    /**
     * <code>optional bool encrypt_apps = 21;</code>
     * @param value The encryptApps to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptApps(boolean value) {
      copyOnWrite();
      instance.setEncryptApps(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_apps = 21;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptApps() {
      copyOnWrite();
      instance.clearEncryptApps();
      return this;
    }

    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     * @return Whether the encryptSearchEngines field is set.
     */
    @java.lang.Override
    public boolean hasEncryptSearchEngines() {
      return instance.hasEncryptSearchEngines();
    }
    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     * @return The encryptSearchEngines.
     */
    @java.lang.Override
    public boolean getEncryptSearchEngines() {
      return instance.getEncryptSearchEngines();
    }
    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     * @param value The encryptSearchEngines to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptSearchEngines(boolean value) {
      copyOnWrite();
      instance.setEncryptSearchEngines(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptSearchEngines() {
      copyOnWrite();
      instance.clearEncryptSearchEngines();
      return this;
    }

    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     * @return Whether the encryptEverything field is set.
     */
    @java.lang.Override
    public boolean hasEncryptEverything() {
      return instance.hasEncryptEverything();
    }
    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     * @return The encryptEverything.
     */
    @java.lang.Override
    public boolean getEncryptEverything() {
      return instance.getEncryptEverything();
    }
    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     * @param value The encryptEverything to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptEverything(boolean value) {
      copyOnWrite();
      instance.setEncryptEverything(value);
      return this;
    }
    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptEverything() {
      copyOnWrite();
      instance.clearEncryptEverything();
      return this;
    }

    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     * @return Whether the encryptExtensionSettings field is set.
     */
    @java.lang.Override
    public boolean hasEncryptExtensionSettings() {
      return instance.hasEncryptExtensionSettings();
    }
    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     * @return The encryptExtensionSettings.
     */
    @java.lang.Override
    public boolean getEncryptExtensionSettings() {
      return instance.getEncryptExtensionSettings();
    }
    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     * @param value The encryptExtensionSettings to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptExtensionSettings(boolean value) {
      copyOnWrite();
      instance.setEncryptExtensionSettings(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptExtensionSettings() {
      copyOnWrite();
      instance.clearEncryptExtensionSettings();
      return this;
    }

    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     * @return Whether the encryptAppNotifications field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasEncryptAppNotifications() {
      return instance.hasEncryptAppNotifications();
    }
    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     * @return The encryptAppNotifications.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getEncryptAppNotifications() {
      return instance.getEncryptAppNotifications();
    }
    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     * @param value The encryptAppNotifications to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setEncryptAppNotifications(boolean value) {
      copyOnWrite();
      instance.setEncryptAppNotifications(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearEncryptAppNotifications() {
      copyOnWrite();
      instance.clearEncryptAppNotifications();
      return this;
    }

    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     * @return Whether the encryptAppSettings field is set.
     */
    @java.lang.Override
    public boolean hasEncryptAppSettings() {
      return instance.hasEncryptAppSettings();
    }
    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     * @return The encryptAppSettings.
     */
    @java.lang.Override
    public boolean getEncryptAppSettings() {
      return instance.getEncryptAppSettings();
    }
    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     * @param value The encryptAppSettings to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptAppSettings(boolean value) {
      copyOnWrite();
      instance.setEncryptAppSettings(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptAppSettings() {
      copyOnWrite();
      instance.clearEncryptAppSettings();
      return this;
    }

    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     * @return Whether the syncTabFavicons field is set.
     */
    @java.lang.Override
    public boolean hasSyncTabFavicons() {
      return instance.hasSyncTabFavicons();
    }
    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     * @return The syncTabFavicons.
     */
    @java.lang.Override
    public boolean getSyncTabFavicons() {
      return instance.getSyncTabFavicons();
    }
    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     * @param value The syncTabFavicons to set.
     * @return This builder for chaining.
     */
    public Builder setSyncTabFavicons(boolean value) {
      copyOnWrite();
      instance.setSyncTabFavicons(value);
      return this;
    }
    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     * @return This builder for chaining.
     */
    public Builder clearSyncTabFavicons() {
      copyOnWrite();
      instance.clearSyncTabFavicons();
      return this;
    }

    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     * @return Whether the passphraseType field is set.
     */
    @java.lang.Override
    public boolean hasPassphraseType() {
      return instance.hasPassphraseType();
    }
    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     * @return The passphraseType.
     */
    @java.lang.Override
    public int getPassphraseType() {
      return instance.getPassphraseType();
    }
    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     * @param value The passphraseType to set.
     * @return This builder for chaining.
     */
    public Builder setPassphraseType(int value) {
      copyOnWrite();
      instance.setPassphraseType(value);
      return this;
    }
    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     * @return This builder for chaining.
     */
    public Builder clearPassphraseType() {
      copyOnWrite();
      instance.clearPassphraseType();
      return this;
    }

    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    @java.lang.Override
    public boolean hasKeystoreDecryptorToken() {
      return instance.hasKeystoreDecryptorToken();
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.EncryptedData getKeystoreDecryptorToken() {
      return instance.getKeystoreDecryptorToken();
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder setKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.setKeystoreDecryptorToken(value);
      return this;
      }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder setKeystoreDecryptorToken(
        org.chromium.components.sync.protocol.EncryptedData.Builder builderForValue) {
      copyOnWrite();
      instance.setKeystoreDecryptorToken(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder mergeKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.mergeKeystoreDecryptorToken(value);
      return this;
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder clearKeystoreDecryptorToken() {  copyOnWrite();
      instance.clearKeystoreDecryptorToken();
      return this;
    }

    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     * @return Whether the keystoreMigrationTime field is set.
     */
    @java.lang.Override
    public boolean hasKeystoreMigrationTime() {
      return instance.hasKeystoreMigrationTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     * @return The keystoreMigrationTime.
     */
    @java.lang.Override
    public long getKeystoreMigrationTime() {
      return instance.getKeystoreMigrationTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     * @param value The keystoreMigrationTime to set.
     * @return This builder for chaining.
     */
    public Builder setKeystoreMigrationTime(long value) {
      copyOnWrite();
      instance.setKeystoreMigrationTime(value);
      return this;
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     * @return This builder for chaining.
     */
    public Builder clearKeystoreMigrationTime() {
      copyOnWrite();
      instance.clearKeystoreMigrationTime();
      return this;
    }

    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     * @return Whether the customPassphraseTime field is set.
     */
    @java.lang.Override
    public boolean hasCustomPassphraseTime() {
      return instance.hasCustomPassphraseTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     * @return The customPassphraseTime.
     */
    @java.lang.Override
    public long getCustomPassphraseTime() {
      return instance.getCustomPassphraseTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     * @param value The customPassphraseTime to set.
     * @return This builder for chaining.
     */
    public Builder setCustomPassphraseTime(long value) {
      copyOnWrite();
      instance.setCustomPassphraseTime(value);
      return this;
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     * @return This builder for chaining.
     */
    public Builder clearCustomPassphraseTime() {
      copyOnWrite();
      instance.clearCustomPassphraseTime();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     * @return Whether the encryptDictionary field is set.
     */
    @java.lang.Override
    public boolean hasEncryptDictionary() {
      return instance.hasEncryptDictionary();
    }
    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     * @return The encryptDictionary.
     */
    @java.lang.Override
    public boolean getEncryptDictionary() {
      return instance.getEncryptDictionary();
    }
    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     * @param value The encryptDictionary to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptDictionary(boolean value) {
      copyOnWrite();
      instance.setEncryptDictionary(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptDictionary() {
      copyOnWrite();
      instance.clearEncryptDictionary();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     * @return Whether the encryptFaviconImages field is set.
     */
    @java.lang.Override
    public boolean hasEncryptFaviconImages() {
      return instance.hasEncryptFaviconImages();
    }
    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     * @return The encryptFaviconImages.
     */
    @java.lang.Override
    public boolean getEncryptFaviconImages() {
      return instance.getEncryptFaviconImages();
    }
    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     * @param value The encryptFaviconImages to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptFaviconImages(boolean value) {
      copyOnWrite();
      instance.setEncryptFaviconImages(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptFaviconImages() {
      copyOnWrite();
      instance.clearEncryptFaviconImages();
      return this;
    }

    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     * @return Whether the encryptFaviconTracking field is set.
     */
    @java.lang.Override
    public boolean hasEncryptFaviconTracking() {
      return instance.hasEncryptFaviconTracking();
    }
    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     * @return The encryptFaviconTracking.
     */
    @java.lang.Override
    public boolean getEncryptFaviconTracking() {
      return instance.getEncryptFaviconTracking();
    }
    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     * @param value The encryptFaviconTracking to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptFaviconTracking(boolean value) {
      copyOnWrite();
      instance.setEncryptFaviconTracking(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptFaviconTracking() {
      copyOnWrite();
      instance.clearEncryptFaviconTracking();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     * @return Whether the encryptAppList field is set.
     */
    @java.lang.Override
    public boolean hasEncryptAppList() {
      return instance.hasEncryptAppList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     * @return The encryptAppList.
     */
    @java.lang.Override
    public boolean getEncryptAppList() {
      return instance.getEncryptAppList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     * @param value The encryptAppList to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptAppList(boolean value) {
      copyOnWrite();
      instance.setEncryptAppList(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptAppList() {
      copyOnWrite();
      instance.clearEncryptAppList();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     * @return Whether the encryptAutofillWalletMetadata field is set.
     */
    @java.lang.Override
    public boolean hasEncryptAutofillWalletMetadata() {
      return instance.hasEncryptAutofillWalletMetadata();
    }
    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     * @return The encryptAutofillWalletMetadata.
     */
    @java.lang.Override
    public boolean getEncryptAutofillWalletMetadata() {
      return instance.getEncryptAutofillWalletMetadata();
    }
    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     * @param value The encryptAutofillWalletMetadata to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptAutofillWalletMetadata(boolean value) {
      copyOnWrite();
      instance.setEncryptAutofillWalletMetadata(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptAutofillWalletMetadata() {
      copyOnWrite();
      instance.clearEncryptAutofillWalletMetadata();
      return this;
    }

    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     * @return Whether the serverOnlyWasMissingKeystoreMigrationTime field is set.
     */
    @java.lang.Override
    public boolean hasServerOnlyWasMissingKeystoreMigrationTime() {
      return instance.hasServerOnlyWasMissingKeystoreMigrationTime();
    }
    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     * @return The serverOnlyWasMissingKeystoreMigrationTime.
     */
    @java.lang.Override
    public boolean getServerOnlyWasMissingKeystoreMigrationTime() {
      return instance.getServerOnlyWasMissingKeystoreMigrationTime();
    }
    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     * @param value The serverOnlyWasMissingKeystoreMigrationTime to set.
     * @return This builder for chaining.
     */
    public Builder setServerOnlyWasMissingKeystoreMigrationTime(boolean value) {
      copyOnWrite();
      instance.setServerOnlyWasMissingKeystoreMigrationTime(value);
      return this;
    }
    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     * @return This builder for chaining.
     */
    public Builder clearServerOnlyWasMissingKeystoreMigrationTime() {
      copyOnWrite();
      instance.clearServerOnlyWasMissingKeystoreMigrationTime();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     * @return Whether the encryptArcPackage field is set.
     */
    @java.lang.Override
    public boolean hasEncryptArcPackage() {
      return instance.hasEncryptArcPackage();
    }
    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     * @return The encryptArcPackage.
     */
    @java.lang.Override
    public boolean getEncryptArcPackage() {
      return instance.getEncryptArcPackage();
    }
    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     * @param value The encryptArcPackage to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptArcPackage(boolean value) {
      copyOnWrite();
      instance.setEncryptArcPackage(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptArcPackage() {
      copyOnWrite();
      instance.clearEncryptArcPackage();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     * @return Whether the encryptPrinters field is set.
     */
    @java.lang.Override
    public boolean hasEncryptPrinters() {
      return instance.hasEncryptPrinters();
    }
    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     * @return The encryptPrinters.
     */
    @java.lang.Override
    public boolean getEncryptPrinters() {
      return instance.getEncryptPrinters();
    }
    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     * @param value The encryptPrinters to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptPrinters(boolean value) {
      copyOnWrite();
      instance.setEncryptPrinters(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptPrinters() {
      copyOnWrite();
      instance.clearEncryptPrinters();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     * @return Whether the encryptReadingList field is set.
     */
    @java.lang.Override
    public boolean hasEncryptReadingList() {
      return instance.hasEncryptReadingList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     * @return The encryptReadingList.
     */
    @java.lang.Override
    public boolean getEncryptReadingList() {
      return instance.getEncryptReadingList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     * @param value The encryptReadingList to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptReadingList(boolean value) {
      copyOnWrite();
      instance.setEncryptReadingList(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptReadingList() {
      copyOnWrite();
      instance.clearEncryptReadingList();
      return this;
    }

    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     * @return Whether the customPassphraseKeyDerivationMethod field is set.
     */
    @java.lang.Override
    public boolean hasCustomPassphraseKeyDerivationMethod() {
      return instance.hasCustomPassphraseKeyDerivationMethod();
    }
    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     * @return The customPassphraseKeyDerivationMethod.
     */
    @java.lang.Override
    public int getCustomPassphraseKeyDerivationMethod() {
      return instance.getCustomPassphraseKeyDerivationMethod();
    }
    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     * @param value The customPassphraseKeyDerivationMethod to set.
     * @return This builder for chaining.
     */
    public Builder setCustomPassphraseKeyDerivationMethod(int value) {
      copyOnWrite();
      instance.setCustomPassphraseKeyDerivationMethod(value);
      return this;
    }
    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     * @return This builder for chaining.
     */
    public Builder clearCustomPassphraseKeyDerivationMethod() {
      copyOnWrite();
      instance.clearCustomPassphraseKeyDerivationMethod();
      return this;
    }

    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     * @return Whether the customPassphraseKeyDerivationSalt field is set.
     */
    @java.lang.Override
    public boolean hasCustomPassphraseKeyDerivationSalt() {
      return instance.hasCustomPassphraseKeyDerivationSalt();
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     * @return The customPassphraseKeyDerivationSalt.
     */
    @java.lang.Override
    public java.lang.String getCustomPassphraseKeyDerivationSalt() {
      return instance.getCustomPassphraseKeyDerivationSalt();
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     * @return The bytes for customPassphraseKeyDerivationSalt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCustomPassphraseKeyDerivationSaltBytes() {
      return instance.getCustomPassphraseKeyDerivationSaltBytes();
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     * @param value The customPassphraseKeyDerivationSalt to set.
     * @return This builder for chaining.
     */
    public Builder setCustomPassphraseKeyDerivationSalt(
        java.lang.String value) {
      copyOnWrite();
      instance.setCustomPassphraseKeyDerivationSalt(value);
      return this;
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     * @return This builder for chaining.
     */
    public Builder clearCustomPassphraseKeyDerivationSalt() {
      copyOnWrite();
      instance.clearCustomPassphraseKeyDerivationSalt();
      return this;
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     * @param value The bytes for customPassphraseKeyDerivationSalt to set.
     * @return This builder for chaining.
     */
    public Builder setCustomPassphraseKeyDerivationSaltBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setCustomPassphraseKeyDerivationSaltBytes(value);
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     * @return Whether the encryptSendTabToSelf field is set.
     */
    @java.lang.Override
    public boolean hasEncryptSendTabToSelf() {
      return instance.hasEncryptSendTabToSelf();
    }
    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     * @return The encryptSendTabToSelf.
     */
    @java.lang.Override
    public boolean getEncryptSendTabToSelf() {
      return instance.getEncryptSendTabToSelf();
    }
    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     * @param value The encryptSendTabToSelf to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptSendTabToSelf(boolean value) {
      copyOnWrite();
      instance.setEncryptSendTabToSelf(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptSendTabToSelf() {
      copyOnWrite();
      instance.clearEncryptSendTabToSelf();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     * @return Whether the encryptWebApps field is set.
     */
    @java.lang.Override
    public boolean hasEncryptWebApps() {
      return instance.hasEncryptWebApps();
    }
    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     * @return The encryptWebApps.
     */
    @java.lang.Override
    public boolean getEncryptWebApps() {
      return instance.getEncryptWebApps();
    }
    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     * @param value The encryptWebApps to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptWebApps(boolean value) {
      copyOnWrite();
      instance.setEncryptWebApps(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptWebApps() {
      copyOnWrite();
      instance.clearEncryptWebApps();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     * @return Whether the encryptOsPreferences field is set.
     */
    @java.lang.Override
    public boolean hasEncryptOsPreferences() {
      return instance.hasEncryptOsPreferences();
    }
    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     * @return The encryptOsPreferences.
     */
    @java.lang.Override
    public boolean getEncryptOsPreferences() {
      return instance.getEncryptOsPreferences();
    }
    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     * @param value The encryptOsPreferences to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptOsPreferences(boolean value) {
      copyOnWrite();
      instance.setEncryptOsPreferences(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptOsPreferences() {
      copyOnWrite();
      instance.clearEncryptOsPreferences();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.NigoriSpecifics)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.NigoriSpecifics();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "bitField1_",
            "encryptionKeybag_",
            "keybagIsFrozen_",
            "encryptBookmarks_",
            "encryptPreferences_",
            "encryptAutofillProfile_",
            "encryptAutofill_",
            "encryptThemes_",
            "encryptTypedUrls_",
            "encryptExtensions_",
            "encryptSessions_",
            "encryptApps_",
            "encryptSearchEngines_",
            "encryptEverything_",
            "encryptExtensionSettings_",
            "encryptAppNotifications_",
            "encryptAppSettings_",
            "syncTabFavicons_",
            "passphraseType_",
            "keystoreDecryptorToken_",
            "keystoreMigrationTime_",
            "customPassphraseTime_",
            "encryptDictionary_",
            "encryptFaviconImages_",
            "encryptFaviconTracking_",
            "encryptAppList_",
            "encryptAutofillWalletMetadata_",
            "serverOnlyWasMissingKeystoreMigrationTime_",
            "encryptArcPackage_",
            "encryptPrinters_",
            "encryptReadingList_",
            "customPassphraseKeyDerivationMethod_",
            "customPassphraseKeyDerivationSalt_",
            "encryptSendTabToSelf_",
            "encryptWebApps_",
            "encryptOsPreferences_",
          };
          java.lang.String info =
              "\u0001#\u0000\u0002\u00011#\u0000\u0000\u0000\u0001\u1009\u0000\u0002\u1007\u0001" +
              "\r\u1007\u0002\u000e\u1007\u0003\u000f\u1007\u0004\u0010\u1007\u0005\u0011\u1007" +
              "\u0006\u0012\u1007\u0007\u0013\u1007\b\u0014\u1007\t\u0015\u1007\n\u0016\u1007\u000b" +
              "\u0018\u1007\f\u0019\u1007\r\u001a\u1007\u000e\u001b\u1007\u000f\u001d\u1007\u0010" +
              "\u001e\u1004\u0011\u001f\u1009\u0012 \u1002\u0013!\u1002\u0014\"\u1007\u0015#\u1007" +
              "\u0016$\u1007\u0017&\u1007\u0018\'\u1007\u0019(\u1007\u001a)\u1007\u001b*\u1007\u001c" +
              "+\u1007\u001d-\u1004\u001e.\u1008\u001f/\u1007 0\u1007!1\u1007\"";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.components.sync.protocol.NigoriSpecifics> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.components.sync.protocol.NigoriSpecifics.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.NigoriSpecifics>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics)
  private static final org.chromium.components.sync.protocol.NigoriSpecifics DEFAULT_INSTANCE;
  static {
    NigoriSpecifics defaultInstance = new NigoriSpecifics();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      NigoriSpecifics.class, defaultInstance);
  }

  public static org.chromium.components.sync.protocol.NigoriSpecifics getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<NigoriSpecifics> PARSER;

  public static com.google.protobuf.Parser<NigoriSpecifics> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

