// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.GetUpdatesResponse}
 */
public  final class GetUpdatesResponse extends
    com.google.protobuf.GeneratedMessageLite<
        GetUpdatesResponse, GetUpdatesResponse.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.GetUpdatesResponse)
    GetUpdatesResponseOrBuilder {
  private GetUpdatesResponse() {
    entries_ = emptyProtobufList();
    newProgressMarker_ = emptyProtobufList();
    encryptionKeys_ = emptyProtobufList();
    contextMutations_ = emptyProtobufList();
  }
  private int bitField0_;
  public static final int ENTRIES_FIELD_NUMBER = 1;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.SyncEntity> entries_;
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.components.sync.protocol.SyncEntity> getEntriesList() {
    return entries_;
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.SyncEntityOrBuilder> 
      getEntriesOrBuilderList() {
    return entries_;
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  @java.lang.Override
  public int getEntriesCount() {
    return entries_.size();
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.SyncEntity getEntries(int index) {
    return entries_.get(index);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public org.chromium.components.sync.protocol.SyncEntityOrBuilder getEntriesOrBuilder(
      int index) {
    return entries_.get(index);
  }
  private void ensureEntriesIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.SyncEntity> tmp = entries_;
    if (!tmp.isModifiable()) {
      entries_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void setEntries(
      int index, org.chromium.components.sync.protocol.SyncEntity value) {
    value.getClass();
  ensureEntriesIsMutable();
    entries_.set(index, value);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addEntries(org.chromium.components.sync.protocol.SyncEntity value) {
    value.getClass();
  ensureEntriesIsMutable();
    entries_.add(value);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addEntries(
      int index, org.chromium.components.sync.protocol.SyncEntity value) {
    value.getClass();
  ensureEntriesIsMutable();
    entries_.add(index, value);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addAllEntries(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.SyncEntity> values) {
    ensureEntriesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, entries_);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void clearEntries() {
    entries_ = emptyProtobufList();
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void removeEntries(int index) {
    ensureEntriesIsMutable();
    entries_.remove(index);
  }

  public static final int CHANGES_REMAINING_FIELD_NUMBER = 4;
  private long changesRemaining_;
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   * @return Whether the changesRemaining field is set.
   */
  @java.lang.Override
  public boolean hasChangesRemaining() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   * @return The changesRemaining.
   */
  @java.lang.Override
  public long getChangesRemaining() {
    return changesRemaining_;
  }
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   * @param value The changesRemaining to set.
   */
  private void setChangesRemaining(long value) {
    bitField0_ |= 0x00000001;
    changesRemaining_ = value;
  }
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   */
  private void clearChangesRemaining() {
    bitField0_ = (bitField0_ & ~0x00000001);
    changesRemaining_ = 0L;
  }

  public static final int NEW_PROGRESS_MARKER_FIELD_NUMBER = 5;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.DataTypeProgressMarker> newProgressMarker_;
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.components.sync.protocol.DataTypeProgressMarker> getNewProgressMarkerList() {
    return newProgressMarker_;
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.DataTypeProgressMarkerOrBuilder> 
      getNewProgressMarkerOrBuilderList() {
    return newProgressMarker_;
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  @java.lang.Override
  public int getNewProgressMarkerCount() {
    return newProgressMarker_.size();
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.DataTypeProgressMarker getNewProgressMarker(int index) {
    return newProgressMarker_.get(index);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public org.chromium.components.sync.protocol.DataTypeProgressMarkerOrBuilder getNewProgressMarkerOrBuilder(
      int index) {
    return newProgressMarker_.get(index);
  }
  private void ensureNewProgressMarkerIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.DataTypeProgressMarker> tmp = newProgressMarker_;
    if (!tmp.isModifiable()) {
      newProgressMarker_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void setNewProgressMarker(
      int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
    value.getClass();
  ensureNewProgressMarkerIsMutable();
    newProgressMarker_.set(index, value);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addNewProgressMarker(org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
    value.getClass();
  ensureNewProgressMarkerIsMutable();
    newProgressMarker_.add(value);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addNewProgressMarker(
      int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
    value.getClass();
  ensureNewProgressMarkerIsMutable();
    newProgressMarker_.add(index, value);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addAllNewProgressMarker(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeProgressMarker> values) {
    ensureNewProgressMarkerIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, newProgressMarker_);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void clearNewProgressMarker() {
    newProgressMarker_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void removeNewProgressMarker(int index) {
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.remove(index);
  }

  public static final int ENCRYPTION_KEYS_FIELD_NUMBER = 6;
  private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> encryptionKeys_;
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   * @return A list containing the encryptionKeys.
   */
  @java.lang.Override
  public java.util.List<com.google.protobuf.ByteString>
      getEncryptionKeysList() {
    return encryptionKeys_;
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   * @return The count of encryptionKeys.
   */
  @java.lang.Override
  public int getEncryptionKeysCount() {
    return encryptionKeys_.size();
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   * @param index The index of the element to return.
   * @return The encryptionKeys at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getEncryptionKeys(int index) {
    return encryptionKeys_.get(index);
  }
  private void ensureEncryptionKeysIsMutable() {
    com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = encryptionKeys_;
    if (!tmp.isModifiable()) {
      encryptionKeys_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   * @param index The index to set the value at.
   * @param value The encryptionKeys to set.
   */
  private void setEncryptionKeys(
      int index, com.google.protobuf.ByteString value) {
    value.getClass();
  ensureEncryptionKeysIsMutable();
    encryptionKeys_.set(index, value);
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   * @param value The encryptionKeys to add.
   */
  private void addEncryptionKeys(com.google.protobuf.ByteString value) {
    value.getClass();
  ensureEncryptionKeysIsMutable();
    encryptionKeys_.add(value);
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   * @param values The encryptionKeys to add.
   */
  private void addAllEncryptionKeys(
      java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
    ensureEncryptionKeysIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, encryptionKeys_);
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  private void clearEncryptionKeys() {
    encryptionKeys_ = emptyProtobufList();
  }

  public static final int CONTEXT_MUTATIONS_FIELD_NUMBER = 7;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.DataTypeContext> contextMutations_;
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.components.sync.protocol.DataTypeContext> getContextMutationsList() {
    return contextMutations_;
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.DataTypeContextOrBuilder> 
      getContextMutationsOrBuilderList() {
    return contextMutations_;
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  @java.lang.Override
  public int getContextMutationsCount() {
    return contextMutations_.size();
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.DataTypeContext getContextMutations(int index) {
    return contextMutations_.get(index);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public org.chromium.components.sync.protocol.DataTypeContextOrBuilder getContextMutationsOrBuilder(
      int index) {
    return contextMutations_.get(index);
  }
  private void ensureContextMutationsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.DataTypeContext> tmp = contextMutations_;
    if (!tmp.isModifiable()) {
      contextMutations_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void setContextMutations(
      int index, org.chromium.components.sync.protocol.DataTypeContext value) {
    value.getClass();
  ensureContextMutationsIsMutable();
    contextMutations_.set(index, value);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addContextMutations(org.chromium.components.sync.protocol.DataTypeContext value) {
    value.getClass();
  ensureContextMutationsIsMutable();
    contextMutations_.add(value);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addContextMutations(
      int index, org.chromium.components.sync.protocol.DataTypeContext value) {
    value.getClass();
  ensureContextMutationsIsMutable();
    contextMutations_.add(index, value);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addAllContextMutations(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeContext> values) {
    ensureContextMutationsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, contextMutations_);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void clearContextMutations() {
    contextMutations_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void removeContextMutations(int index) {
    ensureContextMutationsIsMutable();
    contextMutations_.remove(index);
  }

  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.GetUpdatesResponse prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.GetUpdatesResponse}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.GetUpdatesResponse, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.GetUpdatesResponse)
      org.chromium.components.sync.protocol.GetUpdatesResponseOrBuilder {
    // Construct using org.chromium.components.sync.protocol.GetUpdatesResponse.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.sync.protocol.SyncEntity> getEntriesList() {
      return java.util.Collections.unmodifiableList(
          instance.getEntriesList());
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    @java.lang.Override
    public int getEntriesCount() {
      return instance.getEntriesCount();
    }/**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.SyncEntity getEntries(int index) {
      return instance.getEntries(index);
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder setEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity value) {
      copyOnWrite();
      instance.setEntries(index, value);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder setEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
      copyOnWrite();
      instance.setEntries(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(org.chromium.components.sync.protocol.SyncEntity value) {
      copyOnWrite();
      instance.addEntries(value);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity value) {
      copyOnWrite();
      instance.addEntries(index, value);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(
        org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
      copyOnWrite();
      instance.addEntries(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
      copyOnWrite();
      instance.addEntries(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addAllEntries(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.SyncEntity> values) {
      copyOnWrite();
      instance.addAllEntries(values);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder clearEntries() {
      copyOnWrite();
      instance.clearEntries();
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder removeEntries(int index) {
      copyOnWrite();
      instance.removeEntries(index);
      return this;
    }

    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     * @return Whether the changesRemaining field is set.
     */
    @java.lang.Override
    public boolean hasChangesRemaining() {
      return instance.hasChangesRemaining();
    }
    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     * @return The changesRemaining.
     */
    @java.lang.Override
    public long getChangesRemaining() {
      return instance.getChangesRemaining();
    }
    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     * @param value The changesRemaining to set.
     * @return This builder for chaining.
     */
    public Builder setChangesRemaining(long value) {
      copyOnWrite();
      instance.setChangesRemaining(value);
      return this;
    }
    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearChangesRemaining() {
      copyOnWrite();
      instance.clearChangesRemaining();
      return this;
    }

    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.sync.protocol.DataTypeProgressMarker> getNewProgressMarkerList() {
      return java.util.Collections.unmodifiableList(
          instance.getNewProgressMarkerList());
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    @java.lang.Override
    public int getNewProgressMarkerCount() {
      return instance.getNewProgressMarkerCount();
    }/**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.DataTypeProgressMarker getNewProgressMarker(int index) {
      return instance.getNewProgressMarker(index);
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder setNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
      copyOnWrite();
      instance.setNewProgressMarker(index, value);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder setNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
      copyOnWrite();
      instance.setNewProgressMarker(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
      copyOnWrite();
      instance.addNewProgressMarker(value);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
      copyOnWrite();
      instance.addNewProgressMarker(index, value);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(
        org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
      copyOnWrite();
      instance.addNewProgressMarker(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
      copyOnWrite();
      instance.addNewProgressMarker(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addAllNewProgressMarker(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeProgressMarker> values) {
      copyOnWrite();
      instance.addAllNewProgressMarker(values);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder clearNewProgressMarker() {
      copyOnWrite();
      instance.clearNewProgressMarker();
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder removeNewProgressMarker(int index) {
      copyOnWrite();
      instance.removeNewProgressMarker(index);
      return this;
    }

    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @return A list containing the encryptionKeys.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getEncryptionKeysList() {
      return java.util.Collections.unmodifiableList(
          instance.getEncryptionKeysList());
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @return The count of encryptionKeys.
     */
    @java.lang.Override
    public int getEncryptionKeysCount() {
      return instance.getEncryptionKeysCount();
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @param index The index of the element to return.
     * @return The encryptionKeys at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getEncryptionKeys(int index) {
      return instance.getEncryptionKeys(index);
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @param value The encryptionKeys to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptionKeys(
        int index, com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEncryptionKeys(index, value);
      return this;
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @param value The encryptionKeys to add.
     * @return This builder for chaining.
     */
    public Builder addEncryptionKeys(com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addEncryptionKeys(value);
      return this;
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @param values The encryptionKeys to add.
     * @return This builder for chaining.
     */
    public Builder addAllEncryptionKeys(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      copyOnWrite();
      instance.addAllEncryptionKeys(values);
      return this;
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearEncryptionKeys() {
      copyOnWrite();
      instance.clearEncryptionKeys();
      return this;
    }

    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.sync.protocol.DataTypeContext> getContextMutationsList() {
      return java.util.Collections.unmodifiableList(
          instance.getContextMutationsList());
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    @java.lang.Override
    public int getContextMutationsCount() {
      return instance.getContextMutationsCount();
    }/**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.DataTypeContext getContextMutations(int index) {
      return instance.getContextMutations(index);
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder setContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext value) {
      copyOnWrite();
      instance.setContextMutations(index, value);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder setContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
      copyOnWrite();
      instance.setContextMutations(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(org.chromium.components.sync.protocol.DataTypeContext value) {
      copyOnWrite();
      instance.addContextMutations(value);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext value) {
      copyOnWrite();
      instance.addContextMutations(index, value);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(
        org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
      copyOnWrite();
      instance.addContextMutations(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
      copyOnWrite();
      instance.addContextMutations(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addAllContextMutations(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeContext> values) {
      copyOnWrite();
      instance.addAllContextMutations(values);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder clearContextMutations() {
      copyOnWrite();
      instance.clearContextMutations();
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder removeContextMutations(int index) {
      copyOnWrite();
      instance.removeContextMutations(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.GetUpdatesResponse)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.GetUpdatesResponse();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "entries_",
            org.chromium.components.sync.protocol.SyncEntity.class,
            "changesRemaining_",
            "newProgressMarker_",
            org.chromium.components.sync.protocol.DataTypeProgressMarker.class,
            "encryptionKeys_",
            "contextMutations_",
            org.chromium.components.sync.protocol.DataTypeContext.class,
          };
          java.lang.String info =
              "\u0001\u0005\u0000\u0001\u0001\u0007\u0005\u0000\u0004\u0000\u0001\u001b\u0004\u1002" +
              "\u0000\u0005\u001b\u0006\u001c\u0007\u001b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.components.sync.protocol.GetUpdatesResponse> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.components.sync.protocol.GetUpdatesResponse.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.GetUpdatesResponse>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesResponse)
  private static final org.chromium.components.sync.protocol.GetUpdatesResponse DEFAULT_INSTANCE;
  static {
    GetUpdatesResponse defaultInstance = new GetUpdatesResponse();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      GetUpdatesResponse.class, defaultInstance);
  }

  public static org.chromium.components.sync.protocol.GetUpdatesResponse getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<GetUpdatesResponse> PARSER;

  public static com.google.protobuf.Parser<GetUpdatesResponse> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

