// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/entity_metadata.proto

package org.chromium.components.sync.protocol;

/**
 * <pre>
 * Sync proto to store entity metadata in model type storage.
 * </pre>
 *
 * Protobuf type {@code sync_pb.EntityMetadata}
 */
public  final class EntityMetadata extends
    com.google.protobuf.GeneratedMessageLite<
        EntityMetadata, EntityMetadata.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.EntityMetadata)
    EntityMetadataOrBuilder {
  private EntityMetadata() {
    clientTagHash_ = "";
    serverId_ = "";
    serverVersion_ = -1L;
    specificsHash_ = "";
    baseSpecificsHash_ = "";
  }
  private int bitField0_;
  public static final int CLIENT_TAG_HASH_FIELD_NUMBER = 1;
  private java.lang.String clientTagHash_;
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   * @return Whether the clientTagHash field is set.
   */
  @java.lang.Override
  public boolean hasClientTagHash() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   * @return The clientTagHash.
   */
  @java.lang.Override
  public java.lang.String getClientTagHash() {
    return clientTagHash_;
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   * @return The bytes for clientTagHash.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getClientTagHashBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(clientTagHash_);
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   * @param value The clientTagHash to set.
   */
  private void setClientTagHash(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000001;
    clientTagHash_ = value;
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  private void clearClientTagHash() {
    bitField0_ = (bitField0_ & ~0x00000001);
    clientTagHash_ = getDefaultInstance().getClientTagHash();
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   * @param value The bytes for clientTagHash to set.
   */
  private void setClientTagHashBytes(
      com.google.protobuf.ByteString value) {
    clientTagHash_ = value.toStringUtf8();
    bitField0_ |= 0x00000001;
  }

  public static final int SERVER_ID_FIELD_NUMBER = 2;
  private java.lang.String serverId_;
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   * @return Whether the serverId field is set.
   */
  @java.lang.Override
  public boolean hasServerId() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   * @return The serverId.
   */
  @java.lang.Override
  public java.lang.String getServerId() {
    return serverId_;
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   * @return The bytes for serverId.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getServerIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(serverId_);
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   * @param value The serverId to set.
   */
  private void setServerId(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000002;
    serverId_ = value;
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  private void clearServerId() {
    bitField0_ = (bitField0_ & ~0x00000002);
    serverId_ = getDefaultInstance().getServerId();
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   * @param value The bytes for serverId to set.
   */
  private void setServerIdBytes(
      com.google.protobuf.ByteString value) {
    serverId_ = value.toStringUtf8();
    bitField0_ |= 0x00000002;
  }

  public static final int IS_DELETED_FIELD_NUMBER = 3;
  private boolean isDeleted_;
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   * @return Whether the isDeleted field is set.
   */
  @java.lang.Override
  public boolean hasIsDeleted() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   * @return The isDeleted.
   */
  @java.lang.Override
  public boolean getIsDeleted() {
    return isDeleted_;
  }
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   * @param value The isDeleted to set.
   */
  private void setIsDeleted(boolean value) {
    bitField0_ |= 0x00000004;
    isDeleted_ = value;
  }
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   */
  private void clearIsDeleted() {
    bitField0_ = (bitField0_ & ~0x00000004);
    isDeleted_ = false;
  }

  public static final int SEQUENCE_NUMBER_FIELD_NUMBER = 4;
  private long sequenceNumber_;
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   * @return Whether the sequenceNumber field is set.
   */
  @java.lang.Override
  public boolean hasSequenceNumber() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   * @return The sequenceNumber.
   */
  @java.lang.Override
  public long getSequenceNumber() {
    return sequenceNumber_;
  }
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   * @param value The sequenceNumber to set.
   */
  private void setSequenceNumber(long value) {
    bitField0_ |= 0x00000008;
    sequenceNumber_ = value;
  }
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   */
  private void clearSequenceNumber() {
    bitField0_ = (bitField0_ & ~0x00000008);
    sequenceNumber_ = 0L;
  }

  public static final int ACKED_SEQUENCE_NUMBER_FIELD_NUMBER = 5;
  private long ackedSequenceNumber_;
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   * @return Whether the ackedSequenceNumber field is set.
   */
  @java.lang.Override
  public boolean hasAckedSequenceNumber() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   * @return The ackedSequenceNumber.
   */
  @java.lang.Override
  public long getAckedSequenceNumber() {
    return ackedSequenceNumber_;
  }
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   * @param value The ackedSequenceNumber to set.
   */
  private void setAckedSequenceNumber(long value) {
    bitField0_ |= 0x00000010;
    ackedSequenceNumber_ = value;
  }
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   */
  private void clearAckedSequenceNumber() {
    bitField0_ = (bitField0_ & ~0x00000010);
    ackedSequenceNumber_ = 0L;
  }

  public static final int SERVER_VERSION_FIELD_NUMBER = 6;
  private long serverVersion_;
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   * @return Whether the serverVersion field is set.
   */
  @java.lang.Override
  public boolean hasServerVersion() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   * @return The serverVersion.
   */
  @java.lang.Override
  public long getServerVersion() {
    return serverVersion_;
  }
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   * @param value The serverVersion to set.
   */
  private void setServerVersion(long value) {
    bitField0_ |= 0x00000020;
    serverVersion_ = value;
  }
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   */
  private void clearServerVersion() {
    bitField0_ = (bitField0_ & ~0x00000020);
    serverVersion_ = -1L;
  }

  public static final int CREATION_TIME_FIELD_NUMBER = 7;
  private long creationTime_;
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   * @return Whether the creationTime field is set.
   */
  @java.lang.Override
  public boolean hasCreationTime() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   * @return The creationTime.
   */
  @java.lang.Override
  public long getCreationTime() {
    return creationTime_;
  }
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   * @param value The creationTime to set.
   */
  private void setCreationTime(long value) {
    bitField0_ |= 0x00000040;
    creationTime_ = value;
  }
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   */
  private void clearCreationTime() {
    bitField0_ = (bitField0_ & ~0x00000040);
    creationTime_ = 0L;
  }

  public static final int MODIFICATION_TIME_FIELD_NUMBER = 8;
  private long modificationTime_;
  /**
   * <code>optional int64 modification_time = 8;</code>
   * @return Whether the modificationTime field is set.
   */
  @java.lang.Override
  public boolean hasModificationTime() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <code>optional int64 modification_time = 8;</code>
   * @return The modificationTime.
   */
  @java.lang.Override
  public long getModificationTime() {
    return modificationTime_;
  }
  /**
   * <code>optional int64 modification_time = 8;</code>
   * @param value The modificationTime to set.
   */
  private void setModificationTime(long value) {
    bitField0_ |= 0x00000080;
    modificationTime_ = value;
  }
  /**
   * <code>optional int64 modification_time = 8;</code>
   */
  private void clearModificationTime() {
    bitField0_ = (bitField0_ & ~0x00000080);
    modificationTime_ = 0L;
  }

  public static final int SPECIFICS_HASH_FIELD_NUMBER = 9;
  private java.lang.String specificsHash_;
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   * @return Whether the specificsHash field is set.
   */
  @java.lang.Override
  public boolean hasSpecificsHash() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   * @return The specificsHash.
   */
  @java.lang.Override
  public java.lang.String getSpecificsHash() {
    return specificsHash_;
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   * @return The bytes for specificsHash.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSpecificsHashBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(specificsHash_);
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   * @param value The specificsHash to set.
   */
  private void setSpecificsHash(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000100;
    specificsHash_ = value;
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  private void clearSpecificsHash() {
    bitField0_ = (bitField0_ & ~0x00000100);
    specificsHash_ = getDefaultInstance().getSpecificsHash();
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   * @param value The bytes for specificsHash to set.
   */
  private void setSpecificsHashBytes(
      com.google.protobuf.ByteString value) {
    specificsHash_ = value.toStringUtf8();
    bitField0_ |= 0x00000100;
  }

  public static final int BASE_SPECIFICS_HASH_FIELD_NUMBER = 10;
  private java.lang.String baseSpecificsHash_;
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   * @return Whether the baseSpecificsHash field is set.
   */
  @java.lang.Override
  public boolean hasBaseSpecificsHash() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   * @return The baseSpecificsHash.
   */
  @java.lang.Override
  public java.lang.String getBaseSpecificsHash() {
    return baseSpecificsHash_;
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   * @return The bytes for baseSpecificsHash.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getBaseSpecificsHashBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(baseSpecificsHash_);
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   * @param value The baseSpecificsHash to set.
   */
  private void setBaseSpecificsHash(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000200;
    baseSpecificsHash_ = value;
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  private void clearBaseSpecificsHash() {
    bitField0_ = (bitField0_ & ~0x00000200);
    baseSpecificsHash_ = getDefaultInstance().getBaseSpecificsHash();
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   * @param value The bytes for baseSpecificsHash to set.
   */
  private void setBaseSpecificsHashBytes(
      com.google.protobuf.ByteString value) {
    baseSpecificsHash_ = value.toStringUtf8();
    bitField0_ |= 0x00000200;
  }

  public static final int UNIQUE_POSITION_FIELD_NUMBER = 11;
  private org.chromium.components.sync.protocol.UniquePosition uniquePosition_;
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  @java.lang.Override
  public boolean hasUniquePosition() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
    return uniquePosition_ == null ? org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance() : uniquePosition_;
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  private void setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    value.getClass();
  uniquePosition_ = value;
    bitField0_ |= 0x00000400;
    }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    value.getClass();
  if (uniquePosition_ != null &&
        uniquePosition_ != org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance()) {
      uniquePosition_ =
        org.chromium.components.sync.protocol.UniquePosition.newBuilder(uniquePosition_).mergeFrom(value).buildPartial();
    } else {
      uniquePosition_ = value;
    }
    bitField0_ |= 0x00000400;
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  private void clearUniquePosition() {  uniquePosition_ = null;
    bitField0_ = (bitField0_ & ~0x00000400);
  }

  public static final int BOOKMARK_FAVICON_HASH_FIELD_NUMBER = 12;
  private int bookmarkFaviconHash_;
  /**
   * <pre>
   * Used only for bookmarks. It's analogous to |specifics_hash| but it
   * exclusively hashes the content of the favicon image, as represented in
   * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
   * </pre>
   *
   * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
   * @return Whether the bookmarkFaviconHash field is set.
   */
  @java.lang.Override
  public boolean hasBookmarkFaviconHash() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   * <pre>
   * Used only for bookmarks. It's analogous to |specifics_hash| but it
   * exclusively hashes the content of the favicon image, as represented in
   * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
   * </pre>
   *
   * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
   * @return The bookmarkFaviconHash.
   */
  @java.lang.Override
  public int getBookmarkFaviconHash() {
    return bookmarkFaviconHash_;
  }
  /**
   * <pre>
   * Used only for bookmarks. It's analogous to |specifics_hash| but it
   * exclusively hashes the content of the favicon image, as represented in
   * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
   * </pre>
   *
   * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
   * @param value The bookmarkFaviconHash to set.
   */
  private void setBookmarkFaviconHash(int value) {
    bitField0_ |= 0x00000800;
    bookmarkFaviconHash_ = value;
  }
  /**
   * <pre>
   * Used only for bookmarks. It's analogous to |specifics_hash| but it
   * exclusively hashes the content of the favicon image, as represented in
   * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
   * </pre>
   *
   * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
   */
  private void clearBookmarkFaviconHash() {
    bitField0_ = (bitField0_ & ~0x00000800);
    bookmarkFaviconHash_ = 0;
  }

  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.EntityMetadata prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * Sync proto to store entity metadata in model type storage.
   * </pre>
   *
   * Protobuf type {@code sync_pb.EntityMetadata}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.EntityMetadata, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.EntityMetadata)
      org.chromium.components.sync.protocol.EntityMetadataOrBuilder {
    // Construct using org.chromium.components.sync.protocol.EntityMetadata.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     * @return Whether the clientTagHash field is set.
     */
    @java.lang.Override
    public boolean hasClientTagHash() {
      return instance.hasClientTagHash();
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     * @return The clientTagHash.
     */
    @java.lang.Override
    public java.lang.String getClientTagHash() {
      return instance.getClientTagHash();
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     * @return The bytes for clientTagHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClientTagHashBytes() {
      return instance.getClientTagHashBytes();
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     * @param value The clientTagHash to set.
     * @return This builder for chaining.
     */
    public Builder setClientTagHash(
        java.lang.String value) {
      copyOnWrite();
      instance.setClientTagHash(value);
      return this;
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearClientTagHash() {
      copyOnWrite();
      instance.clearClientTagHash();
      return this;
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     * @param value The bytes for clientTagHash to set.
     * @return This builder for chaining.
     */
    public Builder setClientTagHashBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setClientTagHashBytes(value);
      return this;
    }

    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     * @return Whether the serverId field is set.
     */
    @java.lang.Override
    public boolean hasServerId() {
      return instance.hasServerId();
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     * @return The serverId.
     */
    @java.lang.Override
    public java.lang.String getServerId() {
      return instance.getServerId();
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     * @return The bytes for serverId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServerIdBytes() {
      return instance.getServerIdBytes();
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     * @param value The serverId to set.
     * @return This builder for chaining.
     */
    public Builder setServerId(
        java.lang.String value) {
      copyOnWrite();
      instance.setServerId(value);
      return this;
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearServerId() {
      copyOnWrite();
      instance.clearServerId();
      return this;
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     * @param value The bytes for serverId to set.
     * @return This builder for chaining.
     */
    public Builder setServerIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setServerIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     * @return Whether the isDeleted field is set.
     */
    @java.lang.Override
    public boolean hasIsDeleted() {
      return instance.hasIsDeleted();
    }
    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     * @return The isDeleted.
     */
    @java.lang.Override
    public boolean getIsDeleted() {
      return instance.getIsDeleted();
    }
    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     * @param value The isDeleted to set.
     * @return This builder for chaining.
     */
    public Builder setIsDeleted(boolean value) {
      copyOnWrite();
      instance.setIsDeleted(value);
      return this;
    }
    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearIsDeleted() {
      copyOnWrite();
      instance.clearIsDeleted();
      return this;
    }

    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     * @return Whether the sequenceNumber field is set.
     */
    @java.lang.Override
    public boolean hasSequenceNumber() {
      return instance.hasSequenceNumber();
    }
    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     * @return The sequenceNumber.
     */
    @java.lang.Override
    public long getSequenceNumber() {
      return instance.getSequenceNumber();
    }
    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     * @param value The sequenceNumber to set.
     * @return This builder for chaining.
     */
    public Builder setSequenceNumber(long value) {
      copyOnWrite();
      instance.setSequenceNumber(value);
      return this;
    }
    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearSequenceNumber() {
      copyOnWrite();
      instance.clearSequenceNumber();
      return this;
    }

    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     * @return Whether the ackedSequenceNumber field is set.
     */
    @java.lang.Override
    public boolean hasAckedSequenceNumber() {
      return instance.hasAckedSequenceNumber();
    }
    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     * @return The ackedSequenceNumber.
     */
    @java.lang.Override
    public long getAckedSequenceNumber() {
      return instance.getAckedSequenceNumber();
    }
    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     * @param value The ackedSequenceNumber to set.
     * @return This builder for chaining.
     */
    public Builder setAckedSequenceNumber(long value) {
      copyOnWrite();
      instance.setAckedSequenceNumber(value);
      return this;
    }
    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearAckedSequenceNumber() {
      copyOnWrite();
      instance.clearAckedSequenceNumber();
      return this;
    }

    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     * @return Whether the serverVersion field is set.
     */
    @java.lang.Override
    public boolean hasServerVersion() {
      return instance.hasServerVersion();
    }
    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     * @return The serverVersion.
     */
    @java.lang.Override
    public long getServerVersion() {
      return instance.getServerVersion();
    }
    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     * @param value The serverVersion to set.
     * @return This builder for chaining.
     */
    public Builder setServerVersion(long value) {
      copyOnWrite();
      instance.setServerVersion(value);
      return this;
    }
    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     * @return This builder for chaining.
     */
    public Builder clearServerVersion() {
      copyOnWrite();
      instance.clearServerVersion();
      return this;
    }

    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     * @return Whether the creationTime field is set.
     */
    @java.lang.Override
    public boolean hasCreationTime() {
      return instance.hasCreationTime();
    }
    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     * @return The creationTime.
     */
    @java.lang.Override
    public long getCreationTime() {
      return instance.getCreationTime();
    }
    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     * @param value The creationTime to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTime(long value) {
      copyOnWrite();
      instance.setCreationTime(value);
      return this;
    }
    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearCreationTime() {
      copyOnWrite();
      instance.clearCreationTime();
      return this;
    }

    /**
     * <code>optional int64 modification_time = 8;</code>
     * @return Whether the modificationTime field is set.
     */
    @java.lang.Override
    public boolean hasModificationTime() {
      return instance.hasModificationTime();
    }
    /**
     * <code>optional int64 modification_time = 8;</code>
     * @return The modificationTime.
     */
    @java.lang.Override
    public long getModificationTime() {
      return instance.getModificationTime();
    }
    /**
     * <code>optional int64 modification_time = 8;</code>
     * @param value The modificationTime to set.
     * @return This builder for chaining.
     */
    public Builder setModificationTime(long value) {
      copyOnWrite();
      instance.setModificationTime(value);
      return this;
    }
    /**
     * <code>optional int64 modification_time = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearModificationTime() {
      copyOnWrite();
      instance.clearModificationTime();
      return this;
    }

    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     * @return Whether the specificsHash field is set.
     */
    @java.lang.Override
    public boolean hasSpecificsHash() {
      return instance.hasSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     * @return The specificsHash.
     */
    @java.lang.Override
    public java.lang.String getSpecificsHash() {
      return instance.getSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     * @return The bytes for specificsHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSpecificsHashBytes() {
      return instance.getSpecificsHashBytes();
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     * @param value The specificsHash to set.
     * @return This builder for chaining.
     */
    public Builder setSpecificsHash(
        java.lang.String value) {
      copyOnWrite();
      instance.setSpecificsHash(value);
      return this;
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearSpecificsHash() {
      copyOnWrite();
      instance.clearSpecificsHash();
      return this;
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     * @param value The bytes for specificsHash to set.
     * @return This builder for chaining.
     */
    public Builder setSpecificsHashBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSpecificsHashBytes(value);
      return this;
    }

    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     * @return Whether the baseSpecificsHash field is set.
     */
    @java.lang.Override
    public boolean hasBaseSpecificsHash() {
      return instance.hasBaseSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     * @return The baseSpecificsHash.
     */
    @java.lang.Override
    public java.lang.String getBaseSpecificsHash() {
      return instance.getBaseSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     * @return The bytes for baseSpecificsHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBaseSpecificsHashBytes() {
      return instance.getBaseSpecificsHashBytes();
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     * @param value The baseSpecificsHash to set.
     * @return This builder for chaining.
     */
    public Builder setBaseSpecificsHash(
        java.lang.String value) {
      copyOnWrite();
      instance.setBaseSpecificsHash(value);
      return this;
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearBaseSpecificsHash() {
      copyOnWrite();
      instance.clearBaseSpecificsHash();
      return this;
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     * @param value The bytes for baseSpecificsHash to set.
     * @return This builder for chaining.
     */
    public Builder setBaseSpecificsHashBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setBaseSpecificsHashBytes(value);
      return this;
    }

    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    @java.lang.Override
    public boolean hasUniquePosition() {
      return instance.hasUniquePosition();
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
      return instance.getUniquePosition();
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.setUniquePosition(value);
      return this;
      }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder setUniquePosition(
        org.chromium.components.sync.protocol.UniquePosition.Builder builderForValue) {
      copyOnWrite();
      instance.setUniquePosition(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.mergeUniquePosition(value);
      return this;
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder clearUniquePosition() {  copyOnWrite();
      instance.clearUniquePosition();
      return this;
    }

    /**
     * <pre>
     * Used only for bookmarks. It's analogous to |specifics_hash| but it
     * exclusively hashes the content of the favicon image, as represented in
     * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
     * </pre>
     *
     * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
     * @return Whether the bookmarkFaviconHash field is set.
     */
    @java.lang.Override
    public boolean hasBookmarkFaviconHash() {
      return instance.hasBookmarkFaviconHash();
    }
    /**
     * <pre>
     * Used only for bookmarks. It's analogous to |specifics_hash| but it
     * exclusively hashes the content of the favicon image, as represented in
     * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
     * </pre>
     *
     * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
     * @return The bookmarkFaviconHash.
     */
    @java.lang.Override
    public int getBookmarkFaviconHash() {
      return instance.getBookmarkFaviconHash();
    }
    /**
     * <pre>
     * Used only for bookmarks. It's analogous to |specifics_hash| but it
     * exclusively hashes the content of the favicon image, as represented in
     * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
     * </pre>
     *
     * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
     * @param value The bookmarkFaviconHash to set.
     * @return This builder for chaining.
     */
    public Builder setBookmarkFaviconHash(int value) {
      copyOnWrite();
      instance.setBookmarkFaviconHash(value);
      return this;
    }
    /**
     * <pre>
     * Used only for bookmarks. It's analogous to |specifics_hash| but it
     * exclusively hashes the content of the favicon image, as represented in
     * proto field BookmarkSpecifics.favicon, using base::PersistentHash().
     * </pre>
     *
     * <code>optional fixed32 bookmark_favicon_hash = 12;</code>
     * @return This builder for chaining.
     */
    public Builder clearBookmarkFaviconHash() {
      copyOnWrite();
      instance.clearBookmarkFaviconHash();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.EntityMetadata)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.EntityMetadata();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "clientTagHash_",
            "serverId_",
            "isDeleted_",
            "sequenceNumber_",
            "ackedSequenceNumber_",
            "serverVersion_",
            "creationTime_",
            "modificationTime_",
            "specificsHash_",
            "baseSpecificsHash_",
            "uniquePosition_",
            "bookmarkFaviconHash_",
          };
          java.lang.String info =
              "\u0001\f\u0000\u0001\u0001\f\f\u0000\u0000\u0000\u0001\u1008\u0000\u0002\u1008\u0001" +
              "\u0003\u1007\u0002\u0004\u1002\u0003\u0005\u1002\u0004\u0006\u1002\u0005\u0007\u1002" +
              "\u0006\b\u1002\u0007\t\u1008\b\n\u1008\t\u000b\u1009\n\f\u1006\u000b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.components.sync.protocol.EntityMetadata> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.components.sync.protocol.EntityMetadata.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.EntityMetadata>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.EntityMetadata)
  private static final org.chromium.components.sync.protocol.EntityMetadata DEFAULT_INSTANCE;
  static {
    EntityMetadata defaultInstance = new EntityMetadata();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      EntityMetadata.class, defaultInstance);
  }

  public static org.chromium.components.sync.protocol.EntityMetadata getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<EntityMetadata> PARSER;

  public static com.google.protobuf.Parser<EntityMetadata> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

