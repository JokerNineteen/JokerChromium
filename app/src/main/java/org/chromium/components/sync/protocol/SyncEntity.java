// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.SyncEntity}
 */
public  final class SyncEntity extends
    com.google.protobuf.GeneratedMessageLite<
        SyncEntity, SyncEntity.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.SyncEntity)
    SyncEntityOrBuilder {
  private SyncEntity() {
    idString_ = "";
    parentIdString_ = "";
    name_ = "";
    nonUniqueName_ = "";
    serverDefinedUniqueTag_ = "";
    insertAfterItemId_ = "";
    originatorCacheGuid_ = "";
    originatorClientItemId_ = "";
    clientDefinedUniqueTag_ = "";
    ordinalInParent_ = com.google.protobuf.ByteString.EMPTY;
  }
  private int bitField0_;
  public static final int ID_STRING_FIELD_NUMBER = 1;
  private java.lang.String idString_;
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   * @return Whether the idString field is set.
   */
  @java.lang.Override
  public boolean hasIdString() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   * @return The idString.
   */
  @java.lang.Override
  public java.lang.String getIdString() {
    return idString_;
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   * @return The bytes for idString.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getIdStringBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(idString_);
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   * @param value The idString to set.
   */
  private void setIdString(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000001;
    idString_ = value;
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  private void clearIdString() {
    bitField0_ = (bitField0_ & ~0x00000001);
    idString_ = getDefaultInstance().getIdString();
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   * @param value The bytes for idString to set.
   */
  private void setIdStringBytes(
      com.google.protobuf.ByteString value) {
    idString_ = value.toStringUtf8();
    bitField0_ |= 0x00000001;
  }

  public static final int PARENT_ID_STRING_FIELD_NUMBER = 2;
  private java.lang.String parentIdString_;
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   * @return Whether the parentIdString field is set.
   */
  @java.lang.Override
  public boolean hasParentIdString() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   * @return The parentIdString.
   */
  @java.lang.Override
  public java.lang.String getParentIdString() {
    return parentIdString_;
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   * @return The bytes for parentIdString.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getParentIdStringBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(parentIdString_);
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   * @param value The parentIdString to set.
   */
  private void setParentIdString(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000002;
    parentIdString_ = value;
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  private void clearParentIdString() {
    bitField0_ = (bitField0_ & ~0x00000002);
    parentIdString_ = getDefaultInstance().getParentIdString();
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   * @param value The bytes for parentIdString to set.
   */
  private void setParentIdStringBytes(
      com.google.protobuf.ByteString value) {
    parentIdString_ = value.toStringUtf8();
    bitField0_ |= 0x00000002;
  }

  public static final int VERSION_FIELD_NUMBER = 4;
  private long version_;
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   * @return Whether the version field is set.
   */
  @java.lang.Override
  public boolean hasVersion() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   * @return The version.
   */
  @java.lang.Override
  public long getVersion() {
    return version_;
  }
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   * @param value The version to set.
   */
  private void setVersion(long value) {
    bitField0_ |= 0x00000004;
    version_ = value;
  }
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   */
  private void clearVersion() {
    bitField0_ = (bitField0_ & ~0x00000004);
    version_ = 0L;
  }

  public static final int MTIME_FIELD_NUMBER = 5;
  private long mtime_;
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   * @return Whether the mtime field is set.
   */
  @java.lang.Override
  public boolean hasMtime() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   * @return The mtime.
   */
  @java.lang.Override
  public long getMtime() {
    return mtime_;
  }
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   * @param value The mtime to set.
   */
  private void setMtime(long value) {
    bitField0_ |= 0x00000008;
    mtime_ = value;
  }
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   */
  private void clearMtime() {
    bitField0_ = (bitField0_ & ~0x00000008);
    mtime_ = 0L;
  }

  public static final int CTIME_FIELD_NUMBER = 6;
  private long ctime_;
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   * @return Whether the ctime field is set.
   */
  @java.lang.Override
  public boolean hasCtime() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   * @return The ctime.
   */
  @java.lang.Override
  public long getCtime() {
    return ctime_;
  }
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   * @param value The ctime to set.
   */
  private void setCtime(long value) {
    bitField0_ |= 0x00000010;
    ctime_ = value;
  }
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   */
  private void clearCtime() {
    bitField0_ = (bitField0_ & ~0x00000010);
    ctime_ = 0L;
  }

  public static final int NAME_FIELD_NUMBER = 7;
  private java.lang.String name_;
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   * @return Whether the name field is set.
   */
  @java.lang.Override
  public boolean hasName() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    return name_;
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(name_);
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   * @param value The name to set.
   */
  private void setName(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000020;
    name_ = value;
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  private void clearName() {
    bitField0_ = (bitField0_ & ~0x00000020);
    name_ = getDefaultInstance().getName();
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   * @param value The bytes for name to set.
   */
  private void setNameBytes(
      com.google.protobuf.ByteString value) {
    name_ = value.toStringUtf8();
    bitField0_ |= 0x00000020;
  }

  public static final int NON_UNIQUE_NAME_FIELD_NUMBER = 8;
  private java.lang.String nonUniqueName_;
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   * @return Whether the nonUniqueName field is set.
   */
  @java.lang.Override
  public boolean hasNonUniqueName() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   * @return The nonUniqueName.
   */
  @java.lang.Override
  public java.lang.String getNonUniqueName() {
    return nonUniqueName_;
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   * @return The bytes for nonUniqueName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNonUniqueNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(nonUniqueName_);
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   * @param value The nonUniqueName to set.
   */
  private void setNonUniqueName(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000040;
    nonUniqueName_ = value;
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  private void clearNonUniqueName() {
    bitField0_ = (bitField0_ & ~0x00000040);
    nonUniqueName_ = getDefaultInstance().getNonUniqueName();
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   * @param value The bytes for nonUniqueName to set.
   */
  private void setNonUniqueNameBytes(
      com.google.protobuf.ByteString value) {
    nonUniqueName_ = value.toStringUtf8();
    bitField0_ |= 0x00000040;
  }

  public static final int SERVER_DEFINED_UNIQUE_TAG_FIELD_NUMBER = 10;
  private java.lang.String serverDefinedUniqueTag_;
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   * @return Whether the serverDefinedUniqueTag field is set.
   */
  @java.lang.Override
  public boolean hasServerDefinedUniqueTag() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   * @return The serverDefinedUniqueTag.
   */
  @java.lang.Override
  public java.lang.String getServerDefinedUniqueTag() {
    return serverDefinedUniqueTag_;
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   * @return The bytes for serverDefinedUniqueTag.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getServerDefinedUniqueTagBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(serverDefinedUniqueTag_);
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   * @param value The serverDefinedUniqueTag to set.
   */
  private void setServerDefinedUniqueTag(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000080;
    serverDefinedUniqueTag_ = value;
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  private void clearServerDefinedUniqueTag() {
    bitField0_ = (bitField0_ & ~0x00000080);
    serverDefinedUniqueTag_ = getDefaultInstance().getServerDefinedUniqueTag();
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   * @param value The bytes for serverDefinedUniqueTag to set.
   */
  private void setServerDefinedUniqueTagBytes(
      com.google.protobuf.ByteString value) {
    serverDefinedUniqueTag_ = value.toStringUtf8();
    bitField0_ |= 0x00000080;
  }

  public static final int POSITION_IN_PARENT_FIELD_NUMBER = 15;
  private long positionInParent_;
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   * @return Whether the positionInParent field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasPositionInParent() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   * @return The positionInParent.
   */
  @java.lang.Override
  @java.lang.Deprecated public long getPositionInParent() {
    return positionInParent_;
  }
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   * @param value The positionInParent to set.
   */
  private void setPositionInParent(long value) {
    bitField0_ |= 0x00000100;
    positionInParent_ = value;
  }
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   */
  private void clearPositionInParent() {
    bitField0_ = (bitField0_ & ~0x00000100);
    positionInParent_ = 0L;
  }

  public static final int INSERT_AFTER_ITEM_ID_FIELD_NUMBER = 16;
  private java.lang.String insertAfterItemId_;
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   * @return Whether the insertAfterItemId field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasInsertAfterItemId() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   * @return The insertAfterItemId.
   */
  @java.lang.Override
  @java.lang.Deprecated public java.lang.String getInsertAfterItemId() {
    return insertAfterItemId_;
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   * @return The bytes for insertAfterItemId.
   */
  @java.lang.Override
  @java.lang.Deprecated public com.google.protobuf.ByteString
      getInsertAfterItemIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(insertAfterItemId_);
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   * @param value The insertAfterItemId to set.
   */
  private void setInsertAfterItemId(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000200;
    insertAfterItemId_ = value;
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  private void clearInsertAfterItemId() {
    bitField0_ = (bitField0_ & ~0x00000200);
    insertAfterItemId_ = getDefaultInstance().getInsertAfterItemId();
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   * @param value The bytes for insertAfterItemId to set.
   */
  private void setInsertAfterItemIdBytes(
      com.google.protobuf.ByteString value) {
    insertAfterItemId_ = value.toStringUtf8();
    bitField0_ |= 0x00000200;
  }

  public static final int DELETED_FIELD_NUMBER = 18;
  private boolean deleted_;
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   * @return Whether the deleted field is set.
   */
  @java.lang.Override
  public boolean hasDeleted() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   * @return The deleted.
   */
  @java.lang.Override
  public boolean getDeleted() {
    return deleted_;
  }
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   * @param value The deleted to set.
   */
  private void setDeleted(boolean value) {
    bitField0_ |= 0x00000400;
    deleted_ = value;
  }
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   */
  private void clearDeleted() {
    bitField0_ = (bitField0_ & ~0x00000400);
    deleted_ = false;
  }

  public static final int ORIGINATOR_CACHE_GUID_FIELD_NUMBER = 19;
  private java.lang.String originatorCacheGuid_;
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   * @return Whether the originatorCacheGuid field is set.
   */
  @java.lang.Override
  public boolean hasOriginatorCacheGuid() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   * @return The originatorCacheGuid.
   */
  @java.lang.Override
  public java.lang.String getOriginatorCacheGuid() {
    return originatorCacheGuid_;
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   * @return The bytes for originatorCacheGuid.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getOriginatorCacheGuidBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(originatorCacheGuid_);
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   * @param value The originatorCacheGuid to set.
   */
  private void setOriginatorCacheGuid(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000800;
    originatorCacheGuid_ = value;
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  private void clearOriginatorCacheGuid() {
    bitField0_ = (bitField0_ & ~0x00000800);
    originatorCacheGuid_ = getDefaultInstance().getOriginatorCacheGuid();
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   * @param value The bytes for originatorCacheGuid to set.
   */
  private void setOriginatorCacheGuidBytes(
      com.google.protobuf.ByteString value) {
    originatorCacheGuid_ = value.toStringUtf8();
    bitField0_ |= 0x00000800;
  }

  public static final int ORIGINATOR_CLIENT_ITEM_ID_FIELD_NUMBER = 20;
  private java.lang.String originatorClientItemId_;
  /**
   * <pre>
   * Item ID as generated by the client that initially created this entity. Used
   * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
   * There are three generation of bookmarks that have populated this field
   * differently, depending on which version of the browser created the
   * bookmark:
   * 1. For bookmarks created before M44 (2015), the field got populated with an
   *    ID that is locally unique, but not globally unique (usually a negative
   *    number).
   * 2. For bookmarks created between M45 and M51, both inclusive, the field got
   *    populated with a globally unique GUID in uppercase form.
   * 3. For bookmarks created with M52 or above, the field gets populated with
   *    a globally unique GUID in lowercase form.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   * @return Whether the originatorClientItemId field is set.
   */
  @java.lang.Override
  public boolean hasOriginatorClientItemId() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   * <pre>
   * Item ID as generated by the client that initially created this entity. Used
   * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
   * There are three generation of bookmarks that have populated this field
   * differently, depending on which version of the browser created the
   * bookmark:
   * 1. For bookmarks created before M44 (2015), the field got populated with an
   *    ID that is locally unique, but not globally unique (usually a negative
   *    number).
   * 2. For bookmarks created between M45 and M51, both inclusive, the field got
   *    populated with a globally unique GUID in uppercase form.
   * 3. For bookmarks created with M52 or above, the field gets populated with
   *    a globally unique GUID in lowercase form.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   * @return The originatorClientItemId.
   */
  @java.lang.Override
  public java.lang.String getOriginatorClientItemId() {
    return originatorClientItemId_;
  }
  /**
   * <pre>
   * Item ID as generated by the client that initially created this entity. Used
   * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
   * There are three generation of bookmarks that have populated this field
   * differently, depending on which version of the browser created the
   * bookmark:
   * 1. For bookmarks created before M44 (2015), the field got populated with an
   *    ID that is locally unique, but not globally unique (usually a negative
   *    number).
   * 2. For bookmarks created between M45 and M51, both inclusive, the field got
   *    populated with a globally unique GUID in uppercase form.
   * 3. For bookmarks created with M52 or above, the field gets populated with
   *    a globally unique GUID in lowercase form.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   * @return The bytes for originatorClientItemId.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getOriginatorClientItemIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(originatorClientItemId_);
  }
  /**
   * <pre>
   * Item ID as generated by the client that initially created this entity. Used
   * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
   * There are three generation of bookmarks that have populated this field
   * differently, depending on which version of the browser created the
   * bookmark:
   * 1. For bookmarks created before M44 (2015), the field got populated with an
   *    ID that is locally unique, but not globally unique (usually a negative
   *    number).
   * 2. For bookmarks created between M45 and M51, both inclusive, the field got
   *    populated with a globally unique GUID in uppercase form.
   * 3. For bookmarks created with M52 or above, the field gets populated with
   *    a globally unique GUID in lowercase form.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   * @param value The originatorClientItemId to set.
   */
  private void setOriginatorClientItemId(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00001000;
    originatorClientItemId_ = value;
  }
  /**
   * <pre>
   * Item ID as generated by the client that initially created this entity. Used
   * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
   * There are three generation of bookmarks that have populated this field
   * differently, depending on which version of the browser created the
   * bookmark:
   * 1. For bookmarks created before M44 (2015), the field got populated with an
   *    ID that is locally unique, but not globally unique (usually a negative
   *    number).
   * 2. For bookmarks created between M45 and M51, both inclusive, the field got
   *    populated with a globally unique GUID in uppercase form.
   * 3. For bookmarks created with M52 or above, the field gets populated with
   *    a globally unique GUID in lowercase form.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  private void clearOriginatorClientItemId() {
    bitField0_ = (bitField0_ & ~0x00001000);
    originatorClientItemId_ = getDefaultInstance().getOriginatorClientItemId();
  }
  /**
   * <pre>
   * Item ID as generated by the client that initially created this entity. Used
   * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
   * There are three generation of bookmarks that have populated this field
   * differently, depending on which version of the browser created the
   * bookmark:
   * 1. For bookmarks created before M44 (2015), the field got populated with an
   *    ID that is locally unique, but not globally unique (usually a negative
   *    number).
   * 2. For bookmarks created between M45 and M51, both inclusive, the field got
   *    populated with a globally unique GUID in uppercase form.
   * 3. For bookmarks created with M52 or above, the field gets populated with
   *    a globally unique GUID in lowercase form.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   * @param value The bytes for originatorClientItemId to set.
   */
  private void setOriginatorClientItemIdBytes(
      com.google.protobuf.ByteString value) {
    originatorClientItemId_ = value.toStringUtf8();
    bitField0_ |= 0x00001000;
  }

  public static final int SPECIFICS_FIELD_NUMBER = 21;
  private org.chromium.components.sync.protocol.EntitySpecifics specifics_;
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  @java.lang.Override
  public boolean hasSpecifics() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.EntitySpecifics getSpecifics() {
    return specifics_ == null ? org.chromium.components.sync.protocol.EntitySpecifics.getDefaultInstance() : specifics_;
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  private void setSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
    value.getClass();
  specifics_ = value;
    bitField0_ |= 0x00002000;
    }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
    value.getClass();
  if (specifics_ != null &&
        specifics_ != org.chromium.components.sync.protocol.EntitySpecifics.getDefaultInstance()) {
      specifics_ =
        org.chromium.components.sync.protocol.EntitySpecifics.newBuilder(specifics_).mergeFrom(value).buildPartial();
    } else {
      specifics_ = value;
    }
    bitField0_ |= 0x00002000;
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  private void clearSpecifics() {  specifics_ = null;
    bitField0_ = (bitField0_ & ~0x00002000);
  }

  public static final int FOLDER_FIELD_NUMBER = 22;
  private boolean folder_;
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   * @return Whether the folder field is set.
   */
  @java.lang.Override
  public boolean hasFolder() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   * @return The folder.
   */
  @java.lang.Override
  public boolean getFolder() {
    return folder_;
  }
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   * @param value The folder to set.
   */
  private void setFolder(boolean value) {
    bitField0_ |= 0x00004000;
    folder_ = value;
  }
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   */
  private void clearFolder() {
    bitField0_ = (bitField0_ & ~0x00004000);
    folder_ = false;
  }

  public static final int CLIENT_DEFINED_UNIQUE_TAG_FIELD_NUMBER = 23;
  private java.lang.String clientDefinedUniqueTag_;
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   * @return Whether the clientDefinedUniqueTag field is set.
   */
  @java.lang.Override
  public boolean hasClientDefinedUniqueTag() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   * @return The clientDefinedUniqueTag.
   */
  @java.lang.Override
  public java.lang.String getClientDefinedUniqueTag() {
    return clientDefinedUniqueTag_;
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   * @return The bytes for clientDefinedUniqueTag.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getClientDefinedUniqueTagBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(clientDefinedUniqueTag_);
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   * @param value The clientDefinedUniqueTag to set.
   */
  private void setClientDefinedUniqueTag(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00008000;
    clientDefinedUniqueTag_ = value;
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  private void clearClientDefinedUniqueTag() {
    bitField0_ = (bitField0_ & ~0x00008000);
    clientDefinedUniqueTag_ = getDefaultInstance().getClientDefinedUniqueTag();
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   * @param value The bytes for clientDefinedUniqueTag to set.
   */
  private void setClientDefinedUniqueTagBytes(
      com.google.protobuf.ByteString value) {
    clientDefinedUniqueTag_ = value.toStringUtf8();
    bitField0_ |= 0x00008000;
  }

  public static final int ORDINAL_IN_PARENT_FIELD_NUMBER = 24;
  private com.google.protobuf.ByteString ordinalInParent_;
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   * @return Whether the ordinalInParent field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasOrdinalInParent() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   * @return The ordinalInParent.
   */
  @java.lang.Override
  @java.lang.Deprecated public com.google.protobuf.ByteString getOrdinalInParent() {
    return ordinalInParent_;
  }
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   * @param value The ordinalInParent to set.
   */
  private void setOrdinalInParent(com.google.protobuf.ByteString value) {
    value.getClass();
  bitField0_ |= 0x00010000;
    ordinalInParent_ = value;
  }
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   */
  private void clearOrdinalInParent() {
    bitField0_ = (bitField0_ & ~0x00010000);
    ordinalInParent_ = getDefaultInstance().getOrdinalInParent();
  }

  public static final int UNIQUE_POSITION_FIELD_NUMBER = 25;
  private org.chromium.components.sync.protocol.UniquePosition uniquePosition_;
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  @java.lang.Override
  public boolean hasUniquePosition() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
    return uniquePosition_ == null ? org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance() : uniquePosition_;
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  private void setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    value.getClass();
  uniquePosition_ = value;
    bitField0_ |= 0x00020000;
    }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    value.getClass();
  if (uniquePosition_ != null &&
        uniquePosition_ != org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance()) {
      uniquePosition_ =
        org.chromium.components.sync.protocol.UniquePosition.newBuilder(uniquePosition_).mergeFrom(value).buildPartial();
    } else {
      uniquePosition_ = value;
    }
    bitField0_ |= 0x00020000;
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  private void clearUniquePosition() {  uniquePosition_ = null;
    bitField0_ = (bitField0_ & ~0x00020000);
  }

  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.SyncEntity prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.SyncEntity}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.SyncEntity, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.SyncEntity)
      org.chromium.components.sync.protocol.SyncEntityOrBuilder {
    // Construct using org.chromium.components.sync.protocol.SyncEntity.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     * @return Whether the idString field is set.
     */
    @java.lang.Override
    public boolean hasIdString() {
      return instance.hasIdString();
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     * @return The idString.
     */
    @java.lang.Override
    public java.lang.String getIdString() {
      return instance.getIdString();
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     * @return The bytes for idString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdStringBytes() {
      return instance.getIdStringBytes();
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     * @param value The idString to set.
     * @return This builder for chaining.
     */
    public Builder setIdString(
        java.lang.String value) {
      copyOnWrite();
      instance.setIdString(value);
      return this;
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearIdString() {
      copyOnWrite();
      instance.clearIdString();
      return this;
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     * @param value The bytes for idString to set.
     * @return This builder for chaining.
     */
    public Builder setIdStringBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setIdStringBytes(value);
      return this;
    }

    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     * @return Whether the parentIdString field is set.
     */
    @java.lang.Override
    public boolean hasParentIdString() {
      return instance.hasParentIdString();
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     * @return The parentIdString.
     */
    @java.lang.Override
    public java.lang.String getParentIdString() {
      return instance.getParentIdString();
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     * @return The bytes for parentIdString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getParentIdStringBytes() {
      return instance.getParentIdStringBytes();
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     * @param value The parentIdString to set.
     * @return This builder for chaining.
     */
    public Builder setParentIdString(
        java.lang.String value) {
      copyOnWrite();
      instance.setParentIdString(value);
      return this;
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearParentIdString() {
      copyOnWrite();
      instance.clearParentIdString();
      return this;
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     * @param value The bytes for parentIdString to set.
     * @return This builder for chaining.
     */
    public Builder setParentIdStringBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setParentIdStringBytes(value);
      return this;
    }

    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return instance.hasVersion();
    }
    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     * @return The version.
     */
    @java.lang.Override
    public long getVersion() {
      return instance.getVersion();
    }
    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     * @param value The version to set.
     * @return This builder for chaining.
     */
    public Builder setVersion(long value) {
      copyOnWrite();
      instance.setVersion(value);
      return this;
    }
    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearVersion() {
      copyOnWrite();
      instance.clearVersion();
      return this;
    }

    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     * @return Whether the mtime field is set.
     */
    @java.lang.Override
    public boolean hasMtime() {
      return instance.hasMtime();
    }
    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     * @return The mtime.
     */
    @java.lang.Override
    public long getMtime() {
      return instance.getMtime();
    }
    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     * @param value The mtime to set.
     * @return This builder for chaining.
     */
    public Builder setMtime(long value) {
      copyOnWrite();
      instance.setMtime(value);
      return this;
    }
    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearMtime() {
      copyOnWrite();
      instance.clearMtime();
      return this;
    }

    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     * @return Whether the ctime field is set.
     */
    @java.lang.Override
    public boolean hasCtime() {
      return instance.hasCtime();
    }
    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     * @return The ctime.
     */
    @java.lang.Override
    public long getCtime() {
      return instance.getCtime();
    }
    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     * @param value The ctime to set.
     * @return This builder for chaining.
     */
    public Builder setCtime(long value) {
      copyOnWrite();
      instance.setCtime(value);
      return this;
    }
    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearCtime() {
      copyOnWrite();
      instance.clearCtime();
      return this;
    }

    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return instance.hasName();
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return instance.getName();
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return instance.getNameBytes();
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(
        java.lang.String value) {
      copyOnWrite();
      instance.setName(value);
      return this;
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearName() {
      copyOnWrite();
      instance.clearName();
      return this;
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     * @return Whether the nonUniqueName field is set.
     */
    @java.lang.Override
    public boolean hasNonUniqueName() {
      return instance.hasNonUniqueName();
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     * @return The nonUniqueName.
     */
    @java.lang.Override
    public java.lang.String getNonUniqueName() {
      return instance.getNonUniqueName();
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     * @return The bytes for nonUniqueName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNonUniqueNameBytes() {
      return instance.getNonUniqueNameBytes();
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     * @param value The nonUniqueName to set.
     * @return This builder for chaining.
     */
    public Builder setNonUniqueName(
        java.lang.String value) {
      copyOnWrite();
      instance.setNonUniqueName(value);
      return this;
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearNonUniqueName() {
      copyOnWrite();
      instance.clearNonUniqueName();
      return this;
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     * @param value The bytes for nonUniqueName to set.
     * @return This builder for chaining.
     */
    public Builder setNonUniqueNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNonUniqueNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     * @return Whether the serverDefinedUniqueTag field is set.
     */
    @java.lang.Override
    public boolean hasServerDefinedUniqueTag() {
      return instance.hasServerDefinedUniqueTag();
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     * @return The serverDefinedUniqueTag.
     */
    @java.lang.Override
    public java.lang.String getServerDefinedUniqueTag() {
      return instance.getServerDefinedUniqueTag();
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     * @return The bytes for serverDefinedUniqueTag.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServerDefinedUniqueTagBytes() {
      return instance.getServerDefinedUniqueTagBytes();
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     * @param value The serverDefinedUniqueTag to set.
     * @return This builder for chaining.
     */
    public Builder setServerDefinedUniqueTag(
        java.lang.String value) {
      copyOnWrite();
      instance.setServerDefinedUniqueTag(value);
      return this;
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearServerDefinedUniqueTag() {
      copyOnWrite();
      instance.clearServerDefinedUniqueTag();
      return this;
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     * @param value The bytes for serverDefinedUniqueTag to set.
     * @return This builder for chaining.
     */
    public Builder setServerDefinedUniqueTagBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setServerDefinedUniqueTagBytes(value);
      return this;
    }

    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     * @return Whether the positionInParent field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasPositionInParent() {
      return instance.hasPositionInParent();
    }
    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     * @return The positionInParent.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getPositionInParent() {
      return instance.getPositionInParent();
    }
    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     * @param value The positionInParent to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setPositionInParent(long value) {
      copyOnWrite();
      instance.setPositionInParent(value);
      return this;
    }
    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearPositionInParent() {
      copyOnWrite();
      instance.clearPositionInParent();
      return this;
    }

    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     * @return Whether the insertAfterItemId field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasInsertAfterItemId() {
      return instance.hasInsertAfterItemId();
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     * @return The insertAfterItemId.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getInsertAfterItemId() {
      return instance.getInsertAfterItemId();
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     * @return The bytes for insertAfterItemId.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getInsertAfterItemIdBytes() {
      return instance.getInsertAfterItemIdBytes();
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     * @param value The insertAfterItemId to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setInsertAfterItemId(
        java.lang.String value) {
      copyOnWrite();
      instance.setInsertAfterItemId(value);
      return this;
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearInsertAfterItemId() {
      copyOnWrite();
      instance.clearInsertAfterItemId();
      return this;
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     * @param value The bytes for insertAfterItemId to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setInsertAfterItemIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setInsertAfterItemIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     * @return Whether the deleted field is set.
     */
    @java.lang.Override
    public boolean hasDeleted() {
      return instance.hasDeleted();
    }
    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     * @return The deleted.
     */
    @java.lang.Override
    public boolean getDeleted() {
      return instance.getDeleted();
    }
    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     * @param value The deleted to set.
     * @return This builder for chaining.
     */
    public Builder setDeleted(boolean value) {
      copyOnWrite();
      instance.setDeleted(value);
      return this;
    }
    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     * @return This builder for chaining.
     */
    public Builder clearDeleted() {
      copyOnWrite();
      instance.clearDeleted();
      return this;
    }

    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     * @return Whether the originatorCacheGuid field is set.
     */
    @java.lang.Override
    public boolean hasOriginatorCacheGuid() {
      return instance.hasOriginatorCacheGuid();
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     * @return The originatorCacheGuid.
     */
    @java.lang.Override
    public java.lang.String getOriginatorCacheGuid() {
      return instance.getOriginatorCacheGuid();
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     * @return The bytes for originatorCacheGuid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOriginatorCacheGuidBytes() {
      return instance.getOriginatorCacheGuidBytes();
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     * @param value The originatorCacheGuid to set.
     * @return This builder for chaining.
     */
    public Builder setOriginatorCacheGuid(
        java.lang.String value) {
      copyOnWrite();
      instance.setOriginatorCacheGuid(value);
      return this;
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearOriginatorCacheGuid() {
      copyOnWrite();
      instance.clearOriginatorCacheGuid();
      return this;
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     * @param value The bytes for originatorCacheGuid to set.
     * @return This builder for chaining.
     */
    public Builder setOriginatorCacheGuidBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOriginatorCacheGuidBytes(value);
      return this;
    }

    /**
     * <pre>
     * Item ID as generated by the client that initially created this entity. Used
     * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
     * There are three generation of bookmarks that have populated this field
     * differently, depending on which version of the browser created the
     * bookmark:
     * 1. For bookmarks created before M44 (2015), the field got populated with an
     *    ID that is locally unique, but not globally unique (usually a negative
     *    number).
     * 2. For bookmarks created between M45 and M51, both inclusive, the field got
     *    populated with a globally unique GUID in uppercase form.
     * 3. For bookmarks created with M52 or above, the field gets populated with
     *    a globally unique GUID in lowercase form.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     * @return Whether the originatorClientItemId field is set.
     */
    @java.lang.Override
    public boolean hasOriginatorClientItemId() {
      return instance.hasOriginatorClientItemId();
    }
    /**
     * <pre>
     * Item ID as generated by the client that initially created this entity. Used
     * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
     * There are three generation of bookmarks that have populated this field
     * differently, depending on which version of the browser created the
     * bookmark:
     * 1. For bookmarks created before M44 (2015), the field got populated with an
     *    ID that is locally unique, but not globally unique (usually a negative
     *    number).
     * 2. For bookmarks created between M45 and M51, both inclusive, the field got
     *    populated with a globally unique GUID in uppercase form.
     * 3. For bookmarks created with M52 or above, the field gets populated with
     *    a globally unique GUID in lowercase form.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     * @return The originatorClientItemId.
     */
    @java.lang.Override
    public java.lang.String getOriginatorClientItemId() {
      return instance.getOriginatorClientItemId();
    }
    /**
     * <pre>
     * Item ID as generated by the client that initially created this entity. Used
     * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
     * There are three generation of bookmarks that have populated this field
     * differently, depending on which version of the browser created the
     * bookmark:
     * 1. For bookmarks created before M44 (2015), the field got populated with an
     *    ID that is locally unique, but not globally unique (usually a negative
     *    number).
     * 2. For bookmarks created between M45 and M51, both inclusive, the field got
     *    populated with a globally unique GUID in uppercase form.
     * 3. For bookmarks created with M52 or above, the field gets populated with
     *    a globally unique GUID in lowercase form.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     * @return The bytes for originatorClientItemId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOriginatorClientItemIdBytes() {
      return instance.getOriginatorClientItemIdBytes();
    }
    /**
     * <pre>
     * Item ID as generated by the client that initially created this entity. Used
     * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
     * There are three generation of bookmarks that have populated this field
     * differently, depending on which version of the browser created the
     * bookmark:
     * 1. For bookmarks created before M44 (2015), the field got populated with an
     *    ID that is locally unique, but not globally unique (usually a negative
     *    number).
     * 2. For bookmarks created between M45 and M51, both inclusive, the field got
     *    populated with a globally unique GUID in uppercase form.
     * 3. For bookmarks created with M52 or above, the field gets populated with
     *    a globally unique GUID in lowercase form.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     * @param value The originatorClientItemId to set.
     * @return This builder for chaining.
     */
    public Builder setOriginatorClientItemId(
        java.lang.String value) {
      copyOnWrite();
      instance.setOriginatorClientItemId(value);
      return this;
    }
    /**
     * <pre>
     * Item ID as generated by the client that initially created this entity. Used
     * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
     * There are three generation of bookmarks that have populated this field
     * differently, depending on which version of the browser created the
     * bookmark:
     * 1. For bookmarks created before M44 (2015), the field got populated with an
     *    ID that is locally unique, but not globally unique (usually a negative
     *    number).
     * 2. For bookmarks created between M45 and M51, both inclusive, the field got
     *    populated with a globally unique GUID in uppercase form.
     * 3. For bookmarks created with M52 or above, the field gets populated with
     *    a globally unique GUID in lowercase form.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     * @return This builder for chaining.
     */
    public Builder clearOriginatorClientItemId() {
      copyOnWrite();
      instance.clearOriginatorClientItemId();
      return this;
    }
    /**
     * <pre>
     * Item ID as generated by the client that initially created this entity. Used
     * exclusively for bookmarks (other datatypes use client_defined_unique_tag).
     * There are three generation of bookmarks that have populated this field
     * differently, depending on which version of the browser created the
     * bookmark:
     * 1. For bookmarks created before M44 (2015), the field got populated with an
     *    ID that is locally unique, but not globally unique (usually a negative
     *    number).
     * 2. For bookmarks created between M45 and M51, both inclusive, the field got
     *    populated with a globally unique GUID in uppercase form.
     * 3. For bookmarks created with M52 or above, the field gets populated with
     *    a globally unique GUID in lowercase form.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     * @param value The bytes for originatorClientItemId to set.
     * @return This builder for chaining.
     */
    public Builder setOriginatorClientItemIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOriginatorClientItemIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    @java.lang.Override
    public boolean hasSpecifics() {
      return instance.hasSpecifics();
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.EntitySpecifics getSpecifics() {
      return instance.getSpecifics();
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder setSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
      copyOnWrite();
      instance.setSpecifics(value);
      return this;
      }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder setSpecifics(
        org.chromium.components.sync.protocol.EntitySpecifics.Builder builderForValue) {
      copyOnWrite();
      instance.setSpecifics(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder mergeSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
      copyOnWrite();
      instance.mergeSpecifics(value);
      return this;
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder clearSpecifics() {  copyOnWrite();
      instance.clearSpecifics();
      return this;
    }

    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     * @return Whether the folder field is set.
     */
    @java.lang.Override
    public boolean hasFolder() {
      return instance.hasFolder();
    }
    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     * @return The folder.
     */
    @java.lang.Override
    public boolean getFolder() {
      return instance.getFolder();
    }
    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     * @param value The folder to set.
     * @return This builder for chaining.
     */
    public Builder setFolder(boolean value) {
      copyOnWrite();
      instance.setFolder(value);
      return this;
    }
    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     * @return This builder for chaining.
     */
    public Builder clearFolder() {
      copyOnWrite();
      instance.clearFolder();
      return this;
    }

    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     * @return Whether the clientDefinedUniqueTag field is set.
     */
    @java.lang.Override
    public boolean hasClientDefinedUniqueTag() {
      return instance.hasClientDefinedUniqueTag();
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     * @return The clientDefinedUniqueTag.
     */
    @java.lang.Override
    public java.lang.String getClientDefinedUniqueTag() {
      return instance.getClientDefinedUniqueTag();
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     * @return The bytes for clientDefinedUniqueTag.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClientDefinedUniqueTagBytes() {
      return instance.getClientDefinedUniqueTagBytes();
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     * @param value The clientDefinedUniqueTag to set.
     * @return This builder for chaining.
     */
    public Builder setClientDefinedUniqueTag(
        java.lang.String value) {
      copyOnWrite();
      instance.setClientDefinedUniqueTag(value);
      return this;
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     * @return This builder for chaining.
     */
    public Builder clearClientDefinedUniqueTag() {
      copyOnWrite();
      instance.clearClientDefinedUniqueTag();
      return this;
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     * @param value The bytes for clientDefinedUniqueTag to set.
     * @return This builder for chaining.
     */
    public Builder setClientDefinedUniqueTagBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setClientDefinedUniqueTagBytes(value);
      return this;
    }

    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     * @return Whether the ordinalInParent field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasOrdinalInParent() {
      return instance.hasOrdinalInParent();
    }
    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     * @return The ordinalInParent.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString getOrdinalInParent() {
      return instance.getOrdinalInParent();
    }
    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     * @param value The ordinalInParent to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setOrdinalInParent(com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOrdinalInParent(value);
      return this;
    }
    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearOrdinalInParent() {
      copyOnWrite();
      instance.clearOrdinalInParent();
      return this;
    }

    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    @java.lang.Override
    public boolean hasUniquePosition() {
      return instance.hasUniquePosition();
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
      return instance.getUniquePosition();
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.setUniquePosition(value);
      return this;
      }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder setUniquePosition(
        org.chromium.components.sync.protocol.UniquePosition.Builder builderForValue) {
      copyOnWrite();
      instance.setUniquePosition(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.mergeUniquePosition(value);
      return this;
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder clearUniquePosition() {  copyOnWrite();
      instance.clearUniquePosition();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.SyncEntity)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.SyncEntity();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "idString_",
            "parentIdString_",
            "version_",
            "mtime_",
            "ctime_",
            "name_",
            "nonUniqueName_",
            "serverDefinedUniqueTag_",
            "positionInParent_",
            "insertAfterItemId_",
            "deleted_",
            "originatorCacheGuid_",
            "originatorClientItemId_",
            "specifics_",
            "folder_",
            "clientDefinedUniqueTag_",
            "ordinalInParent_",
            "uniquePosition_",
          };
          java.lang.String info =
              "\u0001\u0012\u0000\u0001\u0001\u0019\u0012\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
              "\u1008\u0001\u0004\u1002\u0002\u0005\u1002\u0003\u0006\u1002\u0004\u0007\u1008\u0005" +
              "\b\u1008\u0006\n\u1008\u0007\u000f\u1002\b\u0010\u1008\t\u0012\u1007\n\u0013\u1008" +
              "\u000b\u0014\u1008\f\u0015\u1009\r\u0016\u1007\u000e\u0017\u1008\u000f\u0018\u100a" +
              "\u0010\u0019\u1009\u0011";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.components.sync.protocol.SyncEntity> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.components.sync.protocol.SyncEntity.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.SyncEntity>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.SyncEntity)
  private static final org.chromium.components.sync.protocol.SyncEntity DEFAULT_INSTANCE;
  static {
    SyncEntity defaultInstance = new SyncEntity();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      SyncEntity.class, defaultInstance);
  }

  public static org.chromium.components.sync.protocol.SyncEntity getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<SyncEntity> PARSER;

  public static com.google.protobuf.Parser<SyncEntity> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

