// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/session_specifics.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.TabNavigation}
 */
public  final class TabNavigation extends
    com.google.protobuf.GeneratedMessageLite<
        TabNavigation, TabNavigation.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.TabNavigation)
    TabNavigationOrBuilder {
  private TabNavigation() {
    virtualUrl_ = "";
    referrer_ = "";
    title_ = "";
    redirectType_ = 1;
    searchTerms_ = "";
    faviconUrl_ = "";
    blockedState_ = 1;
    contentPackCategories_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    navigationRedirect_ = emptyProtobufList();
    lastNavigationRedirectUrl_ = "";
    correctReferrerPolicy_ = 1;
    ancestorTaskId_ = emptyLongList();
    pageLanguage_ = "";
  }
  /**
   * Protobuf enum {@code sync_pb.TabNavigation.BlockedState}
   */
  public enum BlockedState
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>STATE_ALLOWED = 1;</code>
     */
    STATE_ALLOWED(1),
    /**
     * <code>STATE_BLOCKED = 2;</code>
     */
    STATE_BLOCKED(2),
    ;

    /**
     * <code>STATE_ALLOWED = 1;</code>
     */
    public static final int STATE_ALLOWED_VALUE = 1;
    /**
     * <code>STATE_BLOCKED = 2;</code>
     */
    public static final int STATE_BLOCKED_VALUE = 2;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static BlockedState valueOf(int value) {
      return forNumber(value);
    }

    public static BlockedState forNumber(int value) {
      switch (value) {
        case 1: return STATE_ALLOWED;
        case 2: return STATE_BLOCKED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<BlockedState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        BlockedState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<BlockedState>() {
            @java.lang.Override
            public BlockedState findValueByNumber(int number) {
              return BlockedState.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return BlockedStateVerifier.INSTANCE;
    }

    private static final class BlockedStateVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new BlockedStateVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return BlockedState.forNumber(number) != null;
            }
          };

    private final int value;

    private BlockedState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.TabNavigation.BlockedState)
  }

  /**
   * Protobuf enum {@code sync_pb.TabNavigation.PasswordState}
   */
  public enum PasswordState
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>PASSWORD_STATE_UNKNOWN = 0;</code>
     */
    PASSWORD_STATE_UNKNOWN(0),
    /**
     * <code>NO_PASSWORD_FIELD = 1;</code>
     */
    NO_PASSWORD_FIELD(1),
    /**
     * <code>HAS_PASSWORD_FIELD = 2;</code>
     */
    HAS_PASSWORD_FIELD(2),
    ;

    /**
     * <code>PASSWORD_STATE_UNKNOWN = 0;</code>
     */
    public static final int PASSWORD_STATE_UNKNOWN_VALUE = 0;
    /**
     * <code>NO_PASSWORD_FIELD = 1;</code>
     */
    public static final int NO_PASSWORD_FIELD_VALUE = 1;
    /**
     * <code>HAS_PASSWORD_FIELD = 2;</code>
     */
    public static final int HAS_PASSWORD_FIELD_VALUE = 2;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PasswordState valueOf(int value) {
      return forNumber(value);
    }

    public static PasswordState forNumber(int value) {
      switch (value) {
        case 0: return PASSWORD_STATE_UNKNOWN;
        case 1: return NO_PASSWORD_FIELD;
        case 2: return HAS_PASSWORD_FIELD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PasswordState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PasswordState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PasswordState>() {
            @java.lang.Override
            public PasswordState findValueByNumber(int number) {
              return PasswordState.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return PasswordStateVerifier.INSTANCE;
    }

    private static final class PasswordStateVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PasswordStateVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return PasswordState.forNumber(number) != null;
            }
          };

    private final int value;

    private PasswordState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.TabNavigation.PasswordState)
  }

  private int bitField0_;
  public static final int VIRTUAL_URL_FIELD_NUMBER = 2;
  private java.lang.String virtualUrl_;
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   * @return Whether the virtualUrl field is set.
   */
  @java.lang.Override
  public boolean hasVirtualUrl() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   * @return The virtualUrl.
   */
  @java.lang.Override
  public java.lang.String getVirtualUrl() {
    return virtualUrl_;
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   * @return The bytes for virtualUrl.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getVirtualUrlBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(virtualUrl_);
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   * @param value The virtualUrl to set.
   */
  private void setVirtualUrl(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000001;
    virtualUrl_ = value;
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  private void clearVirtualUrl() {
    bitField0_ = (bitField0_ & ~0x00000001);
    virtualUrl_ = getDefaultInstance().getVirtualUrl();
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   * @param value The bytes for virtualUrl to set.
   */
  private void setVirtualUrlBytes(
      com.google.protobuf.ByteString value) {
    virtualUrl_ = value.toStringUtf8();
    bitField0_ |= 0x00000001;
  }

  public static final int REFERRER_FIELD_NUMBER = 3;
  private java.lang.String referrer_;
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   * @return Whether the referrer field is set.
   */
  @java.lang.Override
  public boolean hasReferrer() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   * @return The referrer.
   */
  @java.lang.Override
  public java.lang.String getReferrer() {
    return referrer_;
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   * @return The bytes for referrer.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getReferrerBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(referrer_);
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   * @param value The referrer to set.
   */
  private void setReferrer(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000002;
    referrer_ = value;
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  private void clearReferrer() {
    bitField0_ = (bitField0_ & ~0x00000002);
    referrer_ = getDefaultInstance().getReferrer();
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   * @param value The bytes for referrer to set.
   */
  private void setReferrerBytes(
      com.google.protobuf.ByteString value) {
    referrer_ = value.toStringUtf8();
    bitField0_ |= 0x00000002;
  }

  public static final int TITLE_FIELD_NUMBER = 4;
  private java.lang.String title_;
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   * @return Whether the title field is set.
   */
  @java.lang.Override
  public boolean hasTitle() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   * @return The title.
   */
  @java.lang.Override
  public java.lang.String getTitle() {
    return title_;
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   * @return The bytes for title.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getTitleBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(title_);
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   * @param value The title to set.
   */
  private void setTitle(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00000004;
    title_ = value;
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  private void clearTitle() {
    bitField0_ = (bitField0_ & ~0x00000004);
    title_ = getDefaultInstance().getTitle();
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   * @param value The bytes for title to set.
   */
  private void setTitleBytes(
      com.google.protobuf.ByteString value) {
    title_ = value.toStringUtf8();
    bitField0_ |= 0x00000004;
  }

  public static final int PAGE_TRANSITION_FIELD_NUMBER = 6;
  private int pageTransition_;
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   * @return Whether the pageTransition field is set.
   */
  @java.lang.Override
  public boolean hasPageTransition() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   * @return The pageTransition.
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.SyncEnums.PageTransition getPageTransition() {
    org.chromium.components.sync.protocol.SyncEnums.PageTransition result = org.chromium.components.sync.protocol.SyncEnums.PageTransition.forNumber(pageTransition_);
    return result == null ? org.chromium.components.sync.protocol.SyncEnums.PageTransition.LINK : result;
  }
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   * @param value The pageTransition to set.
   */
  private void setPageTransition(org.chromium.components.sync.protocol.SyncEnums.PageTransition value) {
    pageTransition_ = value.getNumber();
    bitField0_ |= 0x00000008;
  }
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   */
  private void clearPageTransition() {
    bitField0_ = (bitField0_ & ~0x00000008);
    pageTransition_ = 0;
  }

  public static final int REDIRECT_TYPE_FIELD_NUMBER = 7;
  private int redirectType_;
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   * @return Whether the redirectType field is set.
   */
  @java.lang.Override
  public boolean hasRedirectType() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   * @return The redirectType.
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType getRedirectType() {
    org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType result = org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType.forNumber(redirectType_);
    return result == null ? org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType.CLIENT_REDIRECT : result;
  }
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   * @param value The redirectType to set.
   */
  private void setRedirectType(org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType value) {
    redirectType_ = value.getNumber();
    bitField0_ |= 0x00000010;
  }
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   */
  private void clearRedirectType() {
    bitField0_ = (bitField0_ & ~0x00000010);
    redirectType_ = 1;
  }

  public static final int UNIQUE_ID_FIELD_NUMBER = 8;
  private int uniqueId_;
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   * @return Whether the uniqueId field is set.
   */
  @java.lang.Override
  public boolean hasUniqueId() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   * @return The uniqueId.
   */
  @java.lang.Override
  public int getUniqueId() {
    return uniqueId_;
  }
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   * @param value The uniqueId to set.
   */
  private void setUniqueId(int value) {
    bitField0_ |= 0x00000020;
    uniqueId_ = value;
  }
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   */
  private void clearUniqueId() {
    bitField0_ = (bitField0_ & ~0x00000020);
    uniqueId_ = 0;
  }

  public static final int TIMESTAMP_MSEC_FIELD_NUMBER = 9;
  private long timestampMsec_;
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   * @return Whether the timestampMsec field is set.
   */
  @java.lang.Override
  public boolean hasTimestampMsec() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   * @return The timestampMsec.
   */
  @java.lang.Override
  public long getTimestampMsec() {
    return timestampMsec_;
  }
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   * @param value The timestampMsec to set.
   */
  private void setTimestampMsec(long value) {
    bitField0_ |= 0x00000040;
    timestampMsec_ = value;
  }
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   */
  private void clearTimestampMsec() {
    bitField0_ = (bitField0_ & ~0x00000040);
    timestampMsec_ = 0L;
  }

  public static final int NAVIGATION_FORWARD_BACK_FIELD_NUMBER = 10;
  private boolean navigationForwardBack_;
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   * @return Whether the navigationForwardBack field is set.
   */
  @java.lang.Override
  public boolean hasNavigationForwardBack() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   * @return The navigationForwardBack.
   */
  @java.lang.Override
  public boolean getNavigationForwardBack() {
    return navigationForwardBack_;
  }
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   * @param value The navigationForwardBack to set.
   */
  private void setNavigationForwardBack(boolean value) {
    bitField0_ |= 0x00000080;
    navigationForwardBack_ = value;
  }
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   */
  private void clearNavigationForwardBack() {
    bitField0_ = (bitField0_ & ~0x00000080);
    navigationForwardBack_ = false;
  }

  public static final int NAVIGATION_FROM_ADDRESS_BAR_FIELD_NUMBER = 11;
  private boolean navigationFromAddressBar_;
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   * @return Whether the navigationFromAddressBar field is set.
   */
  @java.lang.Override
  public boolean hasNavigationFromAddressBar() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   * @return The navigationFromAddressBar.
   */
  @java.lang.Override
  public boolean getNavigationFromAddressBar() {
    return navigationFromAddressBar_;
  }
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   * @param value The navigationFromAddressBar to set.
   */
  private void setNavigationFromAddressBar(boolean value) {
    bitField0_ |= 0x00000100;
    navigationFromAddressBar_ = value;
  }
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   */
  private void clearNavigationFromAddressBar() {
    bitField0_ = (bitField0_ & ~0x00000100);
    navigationFromAddressBar_ = false;
  }

  public static final int NAVIGATION_HOME_PAGE_FIELD_NUMBER = 12;
  private boolean navigationHomePage_;
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   * @return Whether the navigationHomePage field is set.
   */
  @java.lang.Override
  public boolean hasNavigationHomePage() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   * @return The navigationHomePage.
   */
  @java.lang.Override
  public boolean getNavigationHomePage() {
    return navigationHomePage_;
  }
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   * @param value The navigationHomePage to set.
   */
  private void setNavigationHomePage(boolean value) {
    bitField0_ |= 0x00000200;
    navigationHomePage_ = value;
  }
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   */
  private void clearNavigationHomePage() {
    bitField0_ = (bitField0_ & ~0x00000200);
    navigationHomePage_ = false;
  }

  public static final int NAVIGATION_CHAIN_START_FIELD_NUMBER = 13;
  private boolean navigationChainStart_;
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   * @return Whether the navigationChainStart field is set.
   */
  @java.lang.Override
  public boolean hasNavigationChainStart() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   * @return The navigationChainStart.
   */
  @java.lang.Override
  public boolean getNavigationChainStart() {
    return navigationChainStart_;
  }
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   * @param value The navigationChainStart to set.
   */
  private void setNavigationChainStart(boolean value) {
    bitField0_ |= 0x00000400;
    navigationChainStart_ = value;
  }
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   */
  private void clearNavigationChainStart() {
    bitField0_ = (bitField0_ & ~0x00000400);
    navigationChainStart_ = false;
  }

  public static final int NAVIGATION_CHAIN_END_FIELD_NUMBER = 14;
  private boolean navigationChainEnd_;
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   * @return Whether the navigationChainEnd field is set.
   */
  @java.lang.Override
  public boolean hasNavigationChainEnd() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   * @return The navigationChainEnd.
   */
  @java.lang.Override
  public boolean getNavigationChainEnd() {
    return navigationChainEnd_;
  }
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   * @param value The navigationChainEnd to set.
   */
  private void setNavigationChainEnd(boolean value) {
    bitField0_ |= 0x00000800;
    navigationChainEnd_ = value;
  }
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   */
  private void clearNavigationChainEnd() {
    bitField0_ = (bitField0_ & ~0x00000800);
    navigationChainEnd_ = false;
  }

  public static final int GLOBAL_ID_FIELD_NUMBER = 15;
  private long globalId_;
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   * @return Whether the globalId field is set.
   */
  @java.lang.Override
  public boolean hasGlobalId() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   * @return The globalId.
   */
  @java.lang.Override
  public long getGlobalId() {
    return globalId_;
  }
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   * @param value The globalId to set.
   */
  private void setGlobalId(long value) {
    bitField0_ |= 0x00001000;
    globalId_ = value;
  }
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   */
  private void clearGlobalId() {
    bitField0_ = (bitField0_ & ~0x00001000);
    globalId_ = 0L;
  }

  public static final int SEARCH_TERMS_FIELD_NUMBER = 16;
  private java.lang.String searchTerms_;
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   * @return Whether the searchTerms field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasSearchTerms() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   * @return The searchTerms.
   */
  @java.lang.Override
  @java.lang.Deprecated public java.lang.String getSearchTerms() {
    return searchTerms_;
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   * @return The bytes for searchTerms.
   */
  @java.lang.Override
  @java.lang.Deprecated public com.google.protobuf.ByteString
      getSearchTermsBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(searchTerms_);
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   * @param value The searchTerms to set.
   */
  private void setSearchTerms(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00002000;
    searchTerms_ = value;
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  private void clearSearchTerms() {
    bitField0_ = (bitField0_ & ~0x00002000);
    searchTerms_ = getDefaultInstance().getSearchTerms();
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   * @param value The bytes for searchTerms to set.
   */
  private void setSearchTermsBytes(
      com.google.protobuf.ByteString value) {
    searchTerms_ = value.toStringUtf8();
    bitField0_ |= 0x00002000;
  }

  public static final int FAVICON_URL_FIELD_NUMBER = 17;
  private java.lang.String faviconUrl_;
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   * @return Whether the faviconUrl field is set.
   */
  @java.lang.Override
  public boolean hasFaviconUrl() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   * @return The faviconUrl.
   */
  @java.lang.Override
  public java.lang.String getFaviconUrl() {
    return faviconUrl_;
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   * @return The bytes for faviconUrl.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getFaviconUrlBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(faviconUrl_);
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   * @param value The faviconUrl to set.
   */
  private void setFaviconUrl(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00004000;
    faviconUrl_ = value;
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  private void clearFaviconUrl() {
    bitField0_ = (bitField0_ & ~0x00004000);
    faviconUrl_ = getDefaultInstance().getFaviconUrl();
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   * @param value The bytes for faviconUrl to set.
   */
  private void setFaviconUrlBytes(
      com.google.protobuf.ByteString value) {
    faviconUrl_ = value.toStringUtf8();
    bitField0_ |= 0x00004000;
  }

  public static final int BLOCKED_STATE_FIELD_NUMBER = 18;
  private int blockedState_;
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   * @return Whether the blockedState field is set.
   */
  @java.lang.Override
  public boolean hasBlockedState() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   * @return The blockedState.
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.TabNavigation.BlockedState getBlockedState() {
    org.chromium.components.sync.protocol.TabNavigation.BlockedState result = org.chromium.components.sync.protocol.TabNavigation.BlockedState.forNumber(blockedState_);
    return result == null ? org.chromium.components.sync.protocol.TabNavigation.BlockedState.STATE_ALLOWED : result;
  }
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   * @param value The blockedState to set.
   */
  private void setBlockedState(org.chromium.components.sync.protocol.TabNavigation.BlockedState value) {
    blockedState_ = value.getNumber();
    bitField0_ |= 0x00008000;
  }
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   */
  private void clearBlockedState() {
    bitField0_ = (bitField0_ & ~0x00008000);
    blockedState_ = 1;
  }

  public static final int CONTENT_PACK_CATEGORIES_FIELD_NUMBER = 19;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> contentPackCategories_;
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @return A list containing the contentPackCategories.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getContentPackCategoriesList() {
    return contentPackCategories_;
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @return The count of contentPackCategories.
   */
  @java.lang.Override
  public int getContentPackCategoriesCount() {
    return contentPackCategories_.size();
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @param index The index of the element to return.
   * @return The contentPackCategories at the given index.
   */
  @java.lang.Override
  public java.lang.String getContentPackCategories(int index) {
    return contentPackCategories_.get(index);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @param index The index of the value to return.
   * @return The bytes of the contentPackCategories at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getContentPackCategoriesBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        contentPackCategories_.get(index));
  }
  private void ensureContentPackCategoriesIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        contentPackCategories_;  if (!tmp.isModifiable()) {
      contentPackCategories_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @param index The index to set the value at.
   * @param value The contentPackCategories to set.
   */
  private void setContentPackCategories(
      int index, java.lang.String value) {
    value.getClass();
  ensureContentPackCategoriesIsMutable();
    contentPackCategories_.set(index, value);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @param value The contentPackCategories to add.
   */
  private void addContentPackCategories(
      java.lang.String value) {
    value.getClass();
  ensureContentPackCategoriesIsMutable();
    contentPackCategories_.add(value);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @param values The contentPackCategories to add.
   */
  private void addAllContentPackCategories(
      java.lang.Iterable<java.lang.String> values) {
    ensureContentPackCategoriesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, contentPackCategories_);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  private void clearContentPackCategories() {
    contentPackCategories_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   * @param value The bytes of the contentPackCategories to add.
   */
  private void addContentPackCategoriesBytes(
      com.google.protobuf.ByteString value) {
    ensureContentPackCategoriesIsMutable();
    contentPackCategories_.add(value.toStringUtf8());
  }

  public static final int HTTP_STATUS_CODE_FIELD_NUMBER = 20;
  private int httpStatusCode_;
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   * @return Whether the httpStatusCode field is set.
   */
  @java.lang.Override
  public boolean hasHttpStatusCode() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   * @return The httpStatusCode.
   */
  @java.lang.Override
  public int getHttpStatusCode() {
    return httpStatusCode_;
  }
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   * @param value The httpStatusCode to set.
   */
  private void setHttpStatusCode(int value) {
    bitField0_ |= 0x00010000;
    httpStatusCode_ = value;
  }
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   */
  private void clearHttpStatusCode() {
    bitField0_ = (bitField0_ & ~0x00010000);
    httpStatusCode_ = 0;
  }

  public static final int OBSOLETE_REFERRER_POLICY_FIELD_NUMBER = 21;
  private int obsoleteReferrerPolicy_;
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   * @return Whether the obsoleteReferrerPolicy field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasObsoleteReferrerPolicy() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   * @return The obsoleteReferrerPolicy.
   */
  @java.lang.Override
  @java.lang.Deprecated public int getObsoleteReferrerPolicy() {
    return obsoleteReferrerPolicy_;
  }
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   * @param value The obsoleteReferrerPolicy to set.
   */
  private void setObsoleteReferrerPolicy(int value) {
    bitField0_ |= 0x00020000;
    obsoleteReferrerPolicy_ = value;
  }
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   */
  private void clearObsoleteReferrerPolicy() {
    bitField0_ = (bitField0_ & ~0x00020000);
    obsoleteReferrerPolicy_ = 0;
  }

  public static final int IS_RESTORED_FIELD_NUMBER = 22;
  private boolean isRestored_;
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   * @return Whether the isRestored field is set.
   */
  @java.lang.Override
  public boolean hasIsRestored() {
    return ((bitField0_ & 0x00040000) != 0);
  }
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   * @return The isRestored.
   */
  @java.lang.Override
  public boolean getIsRestored() {
    return isRestored_;
  }
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   * @param value The isRestored to set.
   */
  private void setIsRestored(boolean value) {
    bitField0_ |= 0x00040000;
    isRestored_ = value;
  }
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   */
  private void clearIsRestored() {
    bitField0_ = (bitField0_ & ~0x00040000);
    isRestored_ = false;
  }

  public static final int NAVIGATION_REDIRECT_FIELD_NUMBER = 23;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.NavigationRedirect> navigationRedirect_;
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.components.sync.protocol.NavigationRedirect> getNavigationRedirectList() {
    return navigationRedirect_;
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.NavigationRedirectOrBuilder> 
      getNavigationRedirectOrBuilderList() {
    return navigationRedirect_;
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  @java.lang.Override
  public int getNavigationRedirectCount() {
    return navigationRedirect_.size();
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.NavigationRedirect getNavigationRedirect(int index) {
    return navigationRedirect_.get(index);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public org.chromium.components.sync.protocol.NavigationRedirectOrBuilder getNavigationRedirectOrBuilder(
      int index) {
    return navigationRedirect_.get(index);
  }
  private void ensureNavigationRedirectIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.NavigationRedirect> tmp = navigationRedirect_;
    if (!tmp.isModifiable()) {
      navigationRedirect_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void setNavigationRedirect(
      int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
    value.getClass();
  ensureNavigationRedirectIsMutable();
    navigationRedirect_.set(index, value);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addNavigationRedirect(org.chromium.components.sync.protocol.NavigationRedirect value) {
    value.getClass();
  ensureNavigationRedirectIsMutable();
    navigationRedirect_.add(value);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addNavigationRedirect(
      int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
    value.getClass();
  ensureNavigationRedirectIsMutable();
    navigationRedirect_.add(index, value);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addAllNavigationRedirect(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.NavigationRedirect> values) {
    ensureNavigationRedirectIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, navigationRedirect_);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void clearNavigationRedirect() {
    navigationRedirect_ = emptyProtobufList();
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void removeNavigationRedirect(int index) {
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.remove(index);
  }

  public static final int LAST_NAVIGATION_REDIRECT_URL_FIELD_NUMBER = 24;
  private java.lang.String lastNavigationRedirectUrl_;
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   * @return Whether the lastNavigationRedirectUrl field is set.
   */
  @java.lang.Override
  public boolean hasLastNavigationRedirectUrl() {
    return ((bitField0_ & 0x00080000) != 0);
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   * @return The lastNavigationRedirectUrl.
   */
  @java.lang.Override
  public java.lang.String getLastNavigationRedirectUrl() {
    return lastNavigationRedirectUrl_;
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   * @return The bytes for lastNavigationRedirectUrl.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getLastNavigationRedirectUrlBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(lastNavigationRedirectUrl_);
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   * @param value The lastNavigationRedirectUrl to set.
   */
  private void setLastNavigationRedirectUrl(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x00080000;
    lastNavigationRedirectUrl_ = value;
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  private void clearLastNavigationRedirectUrl() {
    bitField0_ = (bitField0_ & ~0x00080000);
    lastNavigationRedirectUrl_ = getDefaultInstance().getLastNavigationRedirectUrl();
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   * @param value The bytes for lastNavigationRedirectUrl to set.
   */
  private void setLastNavigationRedirectUrlBytes(
      com.google.protobuf.ByteString value) {
    lastNavigationRedirectUrl_ = value.toStringUtf8();
    bitField0_ |= 0x00080000;
  }

  public static final int CORRECT_REFERRER_POLICY_FIELD_NUMBER = 25;
  private int correctReferrerPolicy_;
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   * @return Whether the correctReferrerPolicy field is set.
   */
  @java.lang.Override
  public boolean hasCorrectReferrerPolicy() {
    return ((bitField0_ & 0x00100000) != 0);
  }
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   * @return The correctReferrerPolicy.
   */
  @java.lang.Override
  public int getCorrectReferrerPolicy() {
    return correctReferrerPolicy_;
  }
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   * @param value The correctReferrerPolicy to set.
   */
  private void setCorrectReferrerPolicy(int value) {
    bitField0_ |= 0x00100000;
    correctReferrerPolicy_ = value;
  }
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   */
  private void clearCorrectReferrerPolicy() {
    bitField0_ = (bitField0_ & ~0x00100000);
    correctReferrerPolicy_ = 1;
  }

  public static final int PASSWORD_STATE_FIELD_NUMBER = 26;
  private int passwordState_;
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   * @return Whether the passwordState field is set.
   */
  @java.lang.Override
  public boolean hasPasswordState() {
    return ((bitField0_ & 0x00200000) != 0);
  }
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   * @return The passwordState.
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.TabNavigation.PasswordState getPasswordState() {
    org.chromium.components.sync.protocol.TabNavigation.PasswordState result = org.chromium.components.sync.protocol.TabNavigation.PasswordState.forNumber(passwordState_);
    return result == null ? org.chromium.components.sync.protocol.TabNavigation.PasswordState.PASSWORD_STATE_UNKNOWN : result;
  }
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   * @param value The passwordState to set.
   */
  private void setPasswordState(org.chromium.components.sync.protocol.TabNavigation.PasswordState value) {
    passwordState_ = value.getNumber();
    bitField0_ |= 0x00200000;
  }
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   */
  private void clearPasswordState() {
    bitField0_ = (bitField0_ & ~0x00200000);
    passwordState_ = 0;
  }

  public static final int TASK_ID_FIELD_NUMBER = 27;
  private long taskId_;
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   * @return Whether the taskId field is set.
   */
  @java.lang.Override
  public boolean hasTaskId() {
    return ((bitField0_ & 0x00400000) != 0);
  }
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   * @return The taskId.
   */
  @java.lang.Override
  public long getTaskId() {
    return taskId_;
  }
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   * @param value The taskId to set.
   */
  private void setTaskId(long value) {
    bitField0_ |= 0x00400000;
    taskId_ = value;
  }
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   */
  private void clearTaskId() {
    bitField0_ = (bitField0_ & ~0x00400000);
    taskId_ = 0L;
  }

  public static final int ANCESTOR_TASK_ID_FIELD_NUMBER = 28;
  private com.google.protobuf.Internal.LongList ancestorTaskId_;
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   * @return A list containing the ancestorTaskId.
   */
  @java.lang.Override
  public java.util.List<java.lang.Long>
      getAncestorTaskIdList() {
    return ancestorTaskId_;
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   * @return The count of ancestorTaskId.
   */
  @java.lang.Override
  public int getAncestorTaskIdCount() {
    return ancestorTaskId_.size();
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   * @param index The index of the element to return.
   * @return The ancestorTaskId at the given index.
   */
  @java.lang.Override
  public long getAncestorTaskId(int index) {
    return ancestorTaskId_.getLong(index);
  }
  private void ensureAncestorTaskIdIsMutable() {
    com.google.protobuf.Internal.LongList tmp = ancestorTaskId_;
    if (!tmp.isModifiable()) {
      ancestorTaskId_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   * @param index The index to set the value at.
   * @param value The ancestorTaskId to set.
   */
  private void setAncestorTaskId(
      int index, long value) {
    ensureAncestorTaskIdIsMutable();
    ancestorTaskId_.setLong(index, value);
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   * @param value The ancestorTaskId to add.
   */
  private void addAncestorTaskId(long value) {
    ensureAncestorTaskIdIsMutable();
    ancestorTaskId_.addLong(value);
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   * @param values The ancestorTaskId to add.
   */
  private void addAllAncestorTaskId(
      java.lang.Iterable<? extends java.lang.Long> values) {
    ensureAncestorTaskIdIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, ancestorTaskId_);
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  private void clearAncestorTaskId() {
    ancestorTaskId_ = emptyLongList();
  }

  public static final int REPLACED_NAVIGATION_FIELD_NUMBER = 29;
  private org.chromium.components.sync.protocol.ReplacedNavigation replacedNavigation_;
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  @java.lang.Override
  public boolean hasReplacedNavigation() {
    return ((bitField0_ & 0x00800000) != 0);
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.ReplacedNavigation getReplacedNavigation() {
    return replacedNavigation_ == null ? org.chromium.components.sync.protocol.ReplacedNavigation.getDefaultInstance() : replacedNavigation_;
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  private void setReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
    value.getClass();
  replacedNavigation_ = value;
    bitField0_ |= 0x00800000;
    }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
    value.getClass();
  if (replacedNavigation_ != null &&
        replacedNavigation_ != org.chromium.components.sync.protocol.ReplacedNavigation.getDefaultInstance()) {
      replacedNavigation_ =
        org.chromium.components.sync.protocol.ReplacedNavigation.newBuilder(replacedNavigation_).mergeFrom(value).buildPartial();
    } else {
      replacedNavigation_ = value;
    }
    bitField0_ |= 0x00800000;
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  private void clearReplacedNavigation() {  replacedNavigation_ = null;
    bitField0_ = (bitField0_ & ~0x00800000);
  }

  public static final int PAGE_LANGUAGE_FIELD_NUMBER = 30;
  private java.lang.String pageLanguage_;
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   * @return Whether the pageLanguage field is set.
   */
  @java.lang.Override
  public boolean hasPageLanguage() {
    return ((bitField0_ & 0x01000000) != 0);
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   * @return The pageLanguage.
   */
  @java.lang.Override
  public java.lang.String getPageLanguage() {
    return pageLanguage_;
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   * @return The bytes for pageLanguage.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getPageLanguageBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(pageLanguage_);
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   * @param value The pageLanguage to set.
   */
  private void setPageLanguage(
      java.lang.String value) {
    value.getClass();
  bitField0_ |= 0x01000000;
    pageLanguage_ = value;
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  private void clearPageLanguage() {
    bitField0_ = (bitField0_ & ~0x01000000);
    pageLanguage_ = getDefaultInstance().getPageLanguage();
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   * @param value The bytes for pageLanguage to set.
   */
  private void setPageLanguageBytes(
      com.google.protobuf.ByteString value) {
    pageLanguage_ = value.toStringUtf8();
    bitField0_ |= 0x01000000;
  }

  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.TabNavigation prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.TabNavigation}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.TabNavigation, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.TabNavigation)
      org.chromium.components.sync.protocol.TabNavigationOrBuilder {
    // Construct using org.chromium.components.sync.protocol.TabNavigation.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     * @return Whether the virtualUrl field is set.
     */
    @java.lang.Override
    public boolean hasVirtualUrl() {
      return instance.hasVirtualUrl();
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     * @return The virtualUrl.
     */
    @java.lang.Override
    public java.lang.String getVirtualUrl() {
      return instance.getVirtualUrl();
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     * @return The bytes for virtualUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVirtualUrlBytes() {
      return instance.getVirtualUrlBytes();
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     * @param value The virtualUrl to set.
     * @return This builder for chaining.
     */
    public Builder setVirtualUrl(
        java.lang.String value) {
      copyOnWrite();
      instance.setVirtualUrl(value);
      return this;
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearVirtualUrl() {
      copyOnWrite();
      instance.clearVirtualUrl();
      return this;
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     * @param value The bytes for virtualUrl to set.
     * @return This builder for chaining.
     */
    public Builder setVirtualUrlBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setVirtualUrlBytes(value);
      return this;
    }

    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     * @return Whether the referrer field is set.
     */
    @java.lang.Override
    public boolean hasReferrer() {
      return instance.hasReferrer();
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     * @return The referrer.
     */
    @java.lang.Override
    public java.lang.String getReferrer() {
      return instance.getReferrer();
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     * @return The bytes for referrer.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReferrerBytes() {
      return instance.getReferrerBytes();
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     * @param value The referrer to set.
     * @return This builder for chaining.
     */
    public Builder setReferrer(
        java.lang.String value) {
      copyOnWrite();
      instance.setReferrer(value);
      return this;
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearReferrer() {
      copyOnWrite();
      instance.clearReferrer();
      return this;
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     * @param value The bytes for referrer to set.
     * @return This builder for chaining.
     */
    public Builder setReferrerBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setReferrerBytes(value);
      return this;
    }

    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     * @return Whether the title field is set.
     */
    @java.lang.Override
    public boolean hasTitle() {
      return instance.hasTitle();
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     * @return The title.
     */
    @java.lang.Override
    public java.lang.String getTitle() {
      return instance.getTitle();
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     * @return The bytes for title.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTitleBytes() {
      return instance.getTitleBytes();
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     * @param value The title to set.
     * @return This builder for chaining.
     */
    public Builder setTitle(
        java.lang.String value) {
      copyOnWrite();
      instance.setTitle(value);
      return this;
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearTitle() {
      copyOnWrite();
      instance.clearTitle();
      return this;
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     * @param value The bytes for title to set.
     * @return This builder for chaining.
     */
    public Builder setTitleBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setTitleBytes(value);
      return this;
    }

    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     * @return Whether the pageTransition field is set.
     */
    @java.lang.Override
    public boolean hasPageTransition() {
      return instance.hasPageTransition();
    }
    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     * @return The pageTransition.
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.SyncEnums.PageTransition getPageTransition() {
      return instance.getPageTransition();
    }
    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     * @param value The enum numeric value on the wire for pageTransition to set.
     * @return This builder for chaining.
     */
    public Builder setPageTransition(org.chromium.components.sync.protocol.SyncEnums.PageTransition value) {
      copyOnWrite();
      instance.setPageTransition(value);
      return this;
    }
    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     * @return This builder for chaining.
     */
    public Builder clearPageTransition() {
      copyOnWrite();
      instance.clearPageTransition();
      return this;
    }

    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     * @return Whether the redirectType field is set.
     */
    @java.lang.Override
    public boolean hasRedirectType() {
      return instance.hasRedirectType();
    }
    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     * @return The redirectType.
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType getRedirectType() {
      return instance.getRedirectType();
    }
    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     * @param value The enum numeric value on the wire for redirectType to set.
     * @return This builder for chaining.
     */
    public Builder setRedirectType(org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType value) {
      copyOnWrite();
      instance.setRedirectType(value);
      return this;
    }
    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearRedirectType() {
      copyOnWrite();
      instance.clearRedirectType();
      return this;
    }

    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     * @return Whether the uniqueId field is set.
     */
    @java.lang.Override
    public boolean hasUniqueId() {
      return instance.hasUniqueId();
    }
    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     * @return The uniqueId.
     */
    @java.lang.Override
    public int getUniqueId() {
      return instance.getUniqueId();
    }
    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     * @param value The uniqueId to set.
     * @return This builder for chaining.
     */
    public Builder setUniqueId(int value) {
      copyOnWrite();
      instance.setUniqueId(value);
      return this;
    }
    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearUniqueId() {
      copyOnWrite();
      instance.clearUniqueId();
      return this;
    }

    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     * @return Whether the timestampMsec field is set.
     */
    @java.lang.Override
    public boolean hasTimestampMsec() {
      return instance.hasTimestampMsec();
    }
    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     * @return The timestampMsec.
     */
    @java.lang.Override
    public long getTimestampMsec() {
      return instance.getTimestampMsec();
    }
    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     * @param value The timestampMsec to set.
     * @return This builder for chaining.
     */
    public Builder setTimestampMsec(long value) {
      copyOnWrite();
      instance.setTimestampMsec(value);
      return this;
    }
    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearTimestampMsec() {
      copyOnWrite();
      instance.clearTimestampMsec();
      return this;
    }

    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     * @return Whether the navigationForwardBack field is set.
     */
    @java.lang.Override
    public boolean hasNavigationForwardBack() {
      return instance.hasNavigationForwardBack();
    }
    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     * @return The navigationForwardBack.
     */
    @java.lang.Override
    public boolean getNavigationForwardBack() {
      return instance.getNavigationForwardBack();
    }
    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     * @param value The navigationForwardBack to set.
     * @return This builder for chaining.
     */
    public Builder setNavigationForwardBack(boolean value) {
      copyOnWrite();
      instance.setNavigationForwardBack(value);
      return this;
    }
    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearNavigationForwardBack() {
      copyOnWrite();
      instance.clearNavigationForwardBack();
      return this;
    }

    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     * @return Whether the navigationFromAddressBar field is set.
     */
    @java.lang.Override
    public boolean hasNavigationFromAddressBar() {
      return instance.hasNavigationFromAddressBar();
    }
    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     * @return The navigationFromAddressBar.
     */
    @java.lang.Override
    public boolean getNavigationFromAddressBar() {
      return instance.getNavigationFromAddressBar();
    }
    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     * @param value The navigationFromAddressBar to set.
     * @return This builder for chaining.
     */
    public Builder setNavigationFromAddressBar(boolean value) {
      copyOnWrite();
      instance.setNavigationFromAddressBar(value);
      return this;
    }
    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     * @return This builder for chaining.
     */
    public Builder clearNavigationFromAddressBar() {
      copyOnWrite();
      instance.clearNavigationFromAddressBar();
      return this;
    }

    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     * @return Whether the navigationHomePage field is set.
     */
    @java.lang.Override
    public boolean hasNavigationHomePage() {
      return instance.hasNavigationHomePage();
    }
    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     * @return The navigationHomePage.
     */
    @java.lang.Override
    public boolean getNavigationHomePage() {
      return instance.getNavigationHomePage();
    }
    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     * @param value The navigationHomePage to set.
     * @return This builder for chaining.
     */
    public Builder setNavigationHomePage(boolean value) {
      copyOnWrite();
      instance.setNavigationHomePage(value);
      return this;
    }
    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     * @return This builder for chaining.
     */
    public Builder clearNavigationHomePage() {
      copyOnWrite();
      instance.clearNavigationHomePage();
      return this;
    }

    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     * @return Whether the navigationChainStart field is set.
     */
    @java.lang.Override
    public boolean hasNavigationChainStart() {
      return instance.hasNavigationChainStart();
    }
    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     * @return The navigationChainStart.
     */
    @java.lang.Override
    public boolean getNavigationChainStart() {
      return instance.getNavigationChainStart();
    }
    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     * @param value The navigationChainStart to set.
     * @return This builder for chaining.
     */
    public Builder setNavigationChainStart(boolean value) {
      copyOnWrite();
      instance.setNavigationChainStart(value);
      return this;
    }
    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     * @return This builder for chaining.
     */
    public Builder clearNavigationChainStart() {
      copyOnWrite();
      instance.clearNavigationChainStart();
      return this;
    }

    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     * @return Whether the navigationChainEnd field is set.
     */
    @java.lang.Override
    public boolean hasNavigationChainEnd() {
      return instance.hasNavigationChainEnd();
    }
    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     * @return The navigationChainEnd.
     */
    @java.lang.Override
    public boolean getNavigationChainEnd() {
      return instance.getNavigationChainEnd();
    }
    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     * @param value The navigationChainEnd to set.
     * @return This builder for chaining.
     */
    public Builder setNavigationChainEnd(boolean value) {
      copyOnWrite();
      instance.setNavigationChainEnd(value);
      return this;
    }
    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     * @return This builder for chaining.
     */
    public Builder clearNavigationChainEnd() {
      copyOnWrite();
      instance.clearNavigationChainEnd();
      return this;
    }

    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     * @return Whether the globalId field is set.
     */
    @java.lang.Override
    public boolean hasGlobalId() {
      return instance.hasGlobalId();
    }
    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     * @return The globalId.
     */
    @java.lang.Override
    public long getGlobalId() {
      return instance.getGlobalId();
    }
    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     * @param value The globalId to set.
     * @return This builder for chaining.
     */
    public Builder setGlobalId(long value) {
      copyOnWrite();
      instance.setGlobalId(value);
      return this;
    }
    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     * @return This builder for chaining.
     */
    public Builder clearGlobalId() {
      copyOnWrite();
      instance.clearGlobalId();
      return this;
    }

    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     * @return Whether the searchTerms field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasSearchTerms() {
      return instance.hasSearchTerms();
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     * @return The searchTerms.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getSearchTerms() {
      return instance.getSearchTerms();
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     * @return The bytes for searchTerms.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getSearchTermsBytes() {
      return instance.getSearchTermsBytes();
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     * @param value The searchTerms to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setSearchTerms(
        java.lang.String value) {
      copyOnWrite();
      instance.setSearchTerms(value);
      return this;
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearSearchTerms() {
      copyOnWrite();
      instance.clearSearchTerms();
      return this;
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     * @param value The bytes for searchTerms to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setSearchTermsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSearchTermsBytes(value);
      return this;
    }

    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     * @return Whether the faviconUrl field is set.
     */
    @java.lang.Override
    public boolean hasFaviconUrl() {
      return instance.hasFaviconUrl();
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     * @return The faviconUrl.
     */
    @java.lang.Override
    public java.lang.String getFaviconUrl() {
      return instance.getFaviconUrl();
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     * @return The bytes for faviconUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFaviconUrlBytes() {
      return instance.getFaviconUrlBytes();
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     * @param value The faviconUrl to set.
     * @return This builder for chaining.
     */
    public Builder setFaviconUrl(
        java.lang.String value) {
      copyOnWrite();
      instance.setFaviconUrl(value);
      return this;
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     * @return This builder for chaining.
     */
    public Builder clearFaviconUrl() {
      copyOnWrite();
      instance.clearFaviconUrl();
      return this;
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     * @param value The bytes for faviconUrl to set.
     * @return This builder for chaining.
     */
    public Builder setFaviconUrlBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setFaviconUrlBytes(value);
      return this;
    }

    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     * @return Whether the blockedState field is set.
     */
    @java.lang.Override
    public boolean hasBlockedState() {
      return instance.hasBlockedState();
    }
    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     * @return The blockedState.
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.TabNavigation.BlockedState getBlockedState() {
      return instance.getBlockedState();
    }
    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     * @param value The enum numeric value on the wire for blockedState to set.
     * @return This builder for chaining.
     */
    public Builder setBlockedState(org.chromium.components.sync.protocol.TabNavigation.BlockedState value) {
      copyOnWrite();
      instance.setBlockedState(value);
      return this;
    }
    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     * @return This builder for chaining.
     */
    public Builder clearBlockedState() {
      copyOnWrite();
      instance.clearBlockedState();
      return this;
    }

    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @return A list containing the contentPackCategories.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getContentPackCategoriesList() {
      return java.util.Collections.unmodifiableList(
          instance.getContentPackCategoriesList());
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @return The count of contentPackCategories.
     */
    @java.lang.Override
    public int getContentPackCategoriesCount() {
      return instance.getContentPackCategoriesCount();
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @param index The index of the element to return.
     * @return The contentPackCategories at the given index.
     */
    @java.lang.Override
    public java.lang.String getContentPackCategories(int index) {
      return instance.getContentPackCategories(index);
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @param index The index of the value to return.
     * @return The bytes of the contentPackCategories at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getContentPackCategoriesBytes(int index) {
      return instance.getContentPackCategoriesBytes(index);
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @param index The index to set the value at.
     * @param value The contentPackCategories to set.
     * @return This builder for chaining.
     */
    public Builder setContentPackCategories(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setContentPackCategories(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @param value The contentPackCategories to add.
     * @return This builder for chaining.
     */
    public Builder addContentPackCategories(
        java.lang.String value) {
      copyOnWrite();
      instance.addContentPackCategories(value);
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @param values The contentPackCategories to add.
     * @return This builder for chaining.
     */
    public Builder addAllContentPackCategories(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllContentPackCategories(values);
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearContentPackCategories() {
      copyOnWrite();
      instance.clearContentPackCategories();
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     * @param value The bytes of the contentPackCategories to add.
     * @return This builder for chaining.
     */
    public Builder addContentPackCategoriesBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addContentPackCategoriesBytes(value);
      return this;
    }

    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     * @return Whether the httpStatusCode field is set.
     */
    @java.lang.Override
    public boolean hasHttpStatusCode() {
      return instance.hasHttpStatusCode();
    }
    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     * @return The httpStatusCode.
     */
    @java.lang.Override
    public int getHttpStatusCode() {
      return instance.getHttpStatusCode();
    }
    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     * @param value The httpStatusCode to set.
     * @return This builder for chaining.
     */
    public Builder setHttpStatusCode(int value) {
      copyOnWrite();
      instance.setHttpStatusCode(value);
      return this;
    }
    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     * @return This builder for chaining.
     */
    public Builder clearHttpStatusCode() {
      copyOnWrite();
      instance.clearHttpStatusCode();
      return this;
    }

    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     * @return Whether the obsoleteReferrerPolicy field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasObsoleteReferrerPolicy() {
      return instance.hasObsoleteReferrerPolicy();
    }
    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     * @return The obsoleteReferrerPolicy.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getObsoleteReferrerPolicy() {
      return instance.getObsoleteReferrerPolicy();
    }
    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     * @param value The obsoleteReferrerPolicy to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setObsoleteReferrerPolicy(int value) {
      copyOnWrite();
      instance.setObsoleteReferrerPolicy(value);
      return this;
    }
    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearObsoleteReferrerPolicy() {
      copyOnWrite();
      instance.clearObsoleteReferrerPolicy();
      return this;
    }

    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     * @return Whether the isRestored field is set.
     */
    @java.lang.Override
    public boolean hasIsRestored() {
      return instance.hasIsRestored();
    }
    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     * @return The isRestored.
     */
    @java.lang.Override
    public boolean getIsRestored() {
      return instance.getIsRestored();
    }
    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     * @param value The isRestored to set.
     * @return This builder for chaining.
     */
    public Builder setIsRestored(boolean value) {
      copyOnWrite();
      instance.setIsRestored(value);
      return this;
    }
    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     * @return This builder for chaining.
     */
    public Builder clearIsRestored() {
      copyOnWrite();
      instance.clearIsRestored();
      return this;
    }

    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.sync.protocol.NavigationRedirect> getNavigationRedirectList() {
      return java.util.Collections.unmodifiableList(
          instance.getNavigationRedirectList());
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    @java.lang.Override
    public int getNavigationRedirectCount() {
      return instance.getNavigationRedirectCount();
    }/**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.NavigationRedirect getNavigationRedirect(int index) {
      return instance.getNavigationRedirect(index);
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder setNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
      copyOnWrite();
      instance.setNavigationRedirect(index, value);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder setNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
      copyOnWrite();
      instance.setNavigationRedirect(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(org.chromium.components.sync.protocol.NavigationRedirect value) {
      copyOnWrite();
      instance.addNavigationRedirect(value);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
      copyOnWrite();
      instance.addNavigationRedirect(index, value);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(
        org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
      copyOnWrite();
      instance.addNavigationRedirect(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
      copyOnWrite();
      instance.addNavigationRedirect(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addAllNavigationRedirect(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.NavigationRedirect> values) {
      copyOnWrite();
      instance.addAllNavigationRedirect(values);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder clearNavigationRedirect() {
      copyOnWrite();
      instance.clearNavigationRedirect();
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder removeNavigationRedirect(int index) {
      copyOnWrite();
      instance.removeNavigationRedirect(index);
      return this;
    }

    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     * @return Whether the lastNavigationRedirectUrl field is set.
     */
    @java.lang.Override
    public boolean hasLastNavigationRedirectUrl() {
      return instance.hasLastNavigationRedirectUrl();
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     * @return The lastNavigationRedirectUrl.
     */
    @java.lang.Override
    public java.lang.String getLastNavigationRedirectUrl() {
      return instance.getLastNavigationRedirectUrl();
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     * @return The bytes for lastNavigationRedirectUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLastNavigationRedirectUrlBytes() {
      return instance.getLastNavigationRedirectUrlBytes();
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     * @param value The lastNavigationRedirectUrl to set.
     * @return This builder for chaining.
     */
    public Builder setLastNavigationRedirectUrl(
        java.lang.String value) {
      copyOnWrite();
      instance.setLastNavigationRedirectUrl(value);
      return this;
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     * @return This builder for chaining.
     */
    public Builder clearLastNavigationRedirectUrl() {
      copyOnWrite();
      instance.clearLastNavigationRedirectUrl();
      return this;
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     * @param value The bytes for lastNavigationRedirectUrl to set.
     * @return This builder for chaining.
     */
    public Builder setLastNavigationRedirectUrlBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLastNavigationRedirectUrlBytes(value);
      return this;
    }

    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     * @return Whether the correctReferrerPolicy field is set.
     */
    @java.lang.Override
    public boolean hasCorrectReferrerPolicy() {
      return instance.hasCorrectReferrerPolicy();
    }
    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     * @return The correctReferrerPolicy.
     */
    @java.lang.Override
    public int getCorrectReferrerPolicy() {
      return instance.getCorrectReferrerPolicy();
    }
    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     * @param value The correctReferrerPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setCorrectReferrerPolicy(int value) {
      copyOnWrite();
      instance.setCorrectReferrerPolicy(value);
      return this;
    }
    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     * @return This builder for chaining.
     */
    public Builder clearCorrectReferrerPolicy() {
      copyOnWrite();
      instance.clearCorrectReferrerPolicy();
      return this;
    }

    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     * @return Whether the passwordState field is set.
     */
    @java.lang.Override
    public boolean hasPasswordState() {
      return instance.hasPasswordState();
    }
    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     * @return The passwordState.
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.TabNavigation.PasswordState getPasswordState() {
      return instance.getPasswordState();
    }
    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     * @param value The enum numeric value on the wire for passwordState to set.
     * @return This builder for chaining.
     */
    public Builder setPasswordState(org.chromium.components.sync.protocol.TabNavigation.PasswordState value) {
      copyOnWrite();
      instance.setPasswordState(value);
      return this;
    }
    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     * @return This builder for chaining.
     */
    public Builder clearPasswordState() {
      copyOnWrite();
      instance.clearPasswordState();
      return this;
    }

    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     * @return Whether the taskId field is set.
     */
    @java.lang.Override
    public boolean hasTaskId() {
      return instance.hasTaskId();
    }
    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     * @return The taskId.
     */
    @java.lang.Override
    public long getTaskId() {
      return instance.getTaskId();
    }
    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     * @param value The taskId to set.
     * @return This builder for chaining.
     */
    public Builder setTaskId(long value) {
      copyOnWrite();
      instance.setTaskId(value);
      return this;
    }
    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     * @return This builder for chaining.
     */
    public Builder clearTaskId() {
      copyOnWrite();
      instance.clearTaskId();
      return this;
    }

    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @return A list containing the ancestorTaskId.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getAncestorTaskIdList() {
      return java.util.Collections.unmodifiableList(
          instance.getAncestorTaskIdList());
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @return The count of ancestorTaskId.
     */
    @java.lang.Override
    public int getAncestorTaskIdCount() {
      return instance.getAncestorTaskIdCount();
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @param index The index of the element to return.
     * @return The ancestorTaskId at the given index.
     */
    @java.lang.Override
    public long getAncestorTaskId(int index) {
      return instance.getAncestorTaskId(index);
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @param value The ancestorTaskId to set.
     * @return This builder for chaining.
     */
    public Builder setAncestorTaskId(
        int index, long value) {
      copyOnWrite();
      instance.setAncestorTaskId(index, value);
      return this;
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @param value The ancestorTaskId to add.
     * @return This builder for chaining.
     */
    public Builder addAncestorTaskId(long value) {
      copyOnWrite();
      instance.addAncestorTaskId(value);
      return this;
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @param values The ancestorTaskId to add.
     * @return This builder for chaining.
     */
    public Builder addAllAncestorTaskId(
        java.lang.Iterable<? extends java.lang.Long> values) {
      copyOnWrite();
      instance.addAllAncestorTaskId(values);
      return this;
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     * @return This builder for chaining.
     */
    public Builder clearAncestorTaskId() {
      copyOnWrite();
      instance.clearAncestorTaskId();
      return this;
    }

    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    @java.lang.Override
    public boolean hasReplacedNavigation() {
      return instance.hasReplacedNavigation();
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.ReplacedNavigation getReplacedNavigation() {
      return instance.getReplacedNavigation();
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder setReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
      copyOnWrite();
      instance.setReplacedNavigation(value);
      return this;
      }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder setReplacedNavigation(
        org.chromium.components.sync.protocol.ReplacedNavigation.Builder builderForValue) {
      copyOnWrite();
      instance.setReplacedNavigation(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder mergeReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
      copyOnWrite();
      instance.mergeReplacedNavigation(value);
      return this;
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder clearReplacedNavigation() {  copyOnWrite();
      instance.clearReplacedNavigation();
      return this;
    }

    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     * @return Whether the pageLanguage field is set.
     */
    @java.lang.Override
    public boolean hasPageLanguage() {
      return instance.hasPageLanguage();
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     * @return The pageLanguage.
     */
    @java.lang.Override
    public java.lang.String getPageLanguage() {
      return instance.getPageLanguage();
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     * @return The bytes for pageLanguage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPageLanguageBytes() {
      return instance.getPageLanguageBytes();
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     * @param value The pageLanguage to set.
     * @return This builder for chaining.
     */
    public Builder setPageLanguage(
        java.lang.String value) {
      copyOnWrite();
      instance.setPageLanguage(value);
      return this;
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     * @return This builder for chaining.
     */
    public Builder clearPageLanguage() {
      copyOnWrite();
      instance.clearPageLanguage();
      return this;
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     * @param value The bytes for pageLanguage to set.
     * @return This builder for chaining.
     */
    public Builder setPageLanguageBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setPageLanguageBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.TabNavigation)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.TabNavigation();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "virtualUrl_",
            "referrer_",
            "title_",
            "pageTransition_",
            org.chromium.components.sync.protocol.SyncEnums.PageTransition.internalGetVerifier(),
            "redirectType_",
            org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType.internalGetVerifier(),
            "uniqueId_",
            "timestampMsec_",
            "navigationForwardBack_",
            "navigationFromAddressBar_",
            "navigationHomePage_",
            "navigationChainStart_",
            "navigationChainEnd_",
            "globalId_",
            "searchTerms_",
            "faviconUrl_",
            "blockedState_",
            org.chromium.components.sync.protocol.TabNavigation.BlockedState.internalGetVerifier(),
            "contentPackCategories_",
            "httpStatusCode_",
            "obsoleteReferrerPolicy_",
            "isRestored_",
            "navigationRedirect_",
            org.chromium.components.sync.protocol.NavigationRedirect.class,
            "lastNavigationRedirectUrl_",
            "correctReferrerPolicy_",
            "passwordState_",
            org.chromium.components.sync.protocol.TabNavigation.PasswordState.internalGetVerifier(),
            "taskId_",
            "ancestorTaskId_",
            "replacedNavigation_",
            "pageLanguage_",
          };
          java.lang.String info =
              "\u0001\u001c\u0000\u0001\u0002\u001e\u001c\u0000\u0003\u0000\u0002\u1008\u0000\u0003" +
              "\u1008\u0001\u0004\u1008\u0002\u0006\u100c\u0003\u0007\u100c\u0004\b\u1004\u0005" +
              "\t\u1002\u0006\n\u1007\u0007\u000b\u1007\b\f\u1007\t\r\u1007\n\u000e\u1007\u000b" +
              "\u000f\u1002\f\u0010\u1008\r\u0011\u1008\u000e\u0012\u100c\u000f\u0013\u001a\u0014" +
              "\u1004\u0010\u0015\u1004\u0011\u0016\u1007\u0012\u0017\u001b\u0018\u1008\u0013\u0019" +
              "\u1004\u0014\u001a\u100c\u0015\u001b\u1002\u0016\u001c\u0014\u001d\u1009\u0017\u001e" +
              "\u1008\u0018";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.components.sync.protocol.TabNavigation> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.components.sync.protocol.TabNavigation.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.TabNavigation>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.TabNavigation)
  private static final org.chromium.components.sync.protocol.TabNavigation DEFAULT_INSTANCE;
  static {
    TabNavigation defaultInstance = new TabNavigation();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      TabNavigation.class, defaultInstance);
  }

  public static org.chromium.components.sync.protocol.TabNavigation getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<TabNavigation> PARSER;

  public static com.google.protobuf.Parser<TabNavigation> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

