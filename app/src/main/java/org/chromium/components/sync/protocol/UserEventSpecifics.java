// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/user_event_specifics.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.UserEventSpecifics}
 */
public  final class UserEventSpecifics extends
    com.google.protobuf.GeneratedMessageLite<
        UserEventSpecifics, UserEventSpecifics.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics)
    UserEventSpecificsOrBuilder {
  private UserEventSpecifics() {
  }
  public interface TestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.Test)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * <pre>
   * Used for testing and debugging EventLog system.
   * </pre>
   *
   * Protobuf type {@code sync_pb.UserEventSpecifics.Test}
   */
  public  static final class Test extends
      com.google.protobuf.GeneratedMessageLite<
          Test, Test.Builder> implements
      // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.Test)
      TestOrBuilder {
    private Test() {
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.Test prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Used for testing and debugging EventLog system.
     * </pre>
     *
     * Protobuf type {@code sync_pb.UserEventSpecifics.Test}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.sync.protocol.UserEventSpecifics.Test, Builder> implements
        // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.Test)
        org.chromium.components.sync.protocol.UserEventSpecifics.TestOrBuilder {
      // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.Test.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.Test)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.sync.protocol.UserEventSpecifics.Test();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0001\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.Test> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.Test.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.Test>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.Test)
    private static final org.chromium.components.sync.protocol.UserEventSpecifics.Test DEFAULT_INSTANCE;
    static {
      Test defaultInstance = new Test();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Test.class, defaultInstance);
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.Test getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Test> PARSER;

    public static com.google.protobuf.Parser<Test> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  @java.lang.Deprecated public interface LanguageDetectionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.LanguageDetection)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    java.util.List<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> 
        getDetectedLanguagesList();
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language getDetectedLanguages(int index);
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    int getDetectedLanguagesCount();

    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @return Whether the adoptedLanguageCode field is set.
     */
    boolean hasAdoptedLanguageCode();
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @return The adoptedLanguageCode.
     */
    java.lang.String getAdoptedLanguageCode();
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @return The bytes for adoptedLanguageCode.
     */
    com.google.protobuf.ByteString
        getAdoptedLanguageCodeBytes();
  }
  /**
   * <pre>
   * Language detection output.
   * </pre>
   *
   * Protobuf type {@code sync_pb.UserEventSpecifics.LanguageDetection}
   */
  @java.lang.Deprecated public  static final class LanguageDetection extends
      com.google.protobuf.GeneratedMessageLite<
          LanguageDetection, LanguageDetection.Builder> implements
      // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.LanguageDetection)
      LanguageDetectionOrBuilder {
    private LanguageDetection() {
      detectedLanguages_ = emptyProtobufList();
      adoptedLanguageCode_ = "";
    }
    public interface LanguageOrBuilder extends
        // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.LanguageDetection.Language)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @return Whether the languageCode field is set.
       */
      boolean hasLanguageCode();
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @return The languageCode.
       */
      java.lang.String getLanguageCode();
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @return The bytes for languageCode.
       */
      com.google.protobuf.ByteString
          getLanguageCodeBytes();

      /**
       * <pre>
       * Whether the detected language is reliable, note this is determined by
       * the CLD3.
       * </pre>
       *
       * <code>optional bool is_reliable = 2;</code>
       * @return Whether the isReliable field is set.
       */
      boolean hasIsReliable();
      /**
       * <pre>
       * Whether the detected language is reliable, note this is determined by
       * the CLD3.
       * </pre>
       *
       * <code>optional bool is_reliable = 2;</code>
       * @return The isReliable.
       */
      boolean getIsReliable();
    }
    /**
     * Protobuf type {@code sync_pb.UserEventSpecifics.LanguageDetection.Language}
     */
    public  static final class Language extends
        com.google.protobuf.GeneratedMessageLite<
            Language, Language.Builder> implements
        // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.LanguageDetection.Language)
        LanguageOrBuilder {
      private Language() {
        languageCode_ = "";
      }
      private int bitField0_;
      public static final int LANGUAGE_CODE_FIELD_NUMBER = 1;
      private java.lang.String languageCode_;
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @return Whether the languageCode field is set.
       */
      @java.lang.Override
      public boolean hasLanguageCode() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @return The languageCode.
       */
      @java.lang.Override
      public java.lang.String getLanguageCode() {
        return languageCode_;
      }
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @return The bytes for languageCode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLanguageCodeBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(languageCode_);
      }
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @param value The languageCode to set.
       */
      private void setLanguageCode(
          java.lang.String value) {
        value.getClass();
  bitField0_ |= 0x00000001;
        languageCode_ = value;
      }
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       */
      private void clearLanguageCode() {
        bitField0_ = (bitField0_ & ~0x00000001);
        languageCode_ = getDefaultInstance().getLanguageCode();
      }
      /**
       * <pre>
       * ISO 639 language code will be used.
       * </pre>
       *
       * <code>optional string language_code = 1;</code>
       * @param value The bytes for languageCode to set.
       */
      private void setLanguageCodeBytes(
          com.google.protobuf.ByteString value) {
        languageCode_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int IS_RELIABLE_FIELD_NUMBER = 2;
      private boolean isReliable_;
      /**
       * <pre>
       * Whether the detected language is reliable, note this is determined by
       * the CLD3.
       * </pre>
       *
       * <code>optional bool is_reliable = 2;</code>
       * @return Whether the isReliable field is set.
       */
      @java.lang.Override
      public boolean hasIsReliable() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether the detected language is reliable, note this is determined by
       * the CLD3.
       * </pre>
       *
       * <code>optional bool is_reliable = 2;</code>
       * @return The isReliable.
       */
      @java.lang.Override
      public boolean getIsReliable() {
        return isReliable_;
      }
      /**
       * <pre>
       * Whether the detected language is reliable, note this is determined by
       * the CLD3.
       * </pre>
       *
       * <code>optional bool is_reliable = 2;</code>
       * @param value The isReliable to set.
       */
      private void setIsReliable(boolean value) {
        bitField0_ |= 0x00000002;
        isReliable_ = value;
      }
      /**
       * <pre>
       * Whether the detected language is reliable, note this is determined by
       * the CLD3.
       * </pre>
       *
       * <code>optional bool is_reliable = 2;</code>
       */
      private void clearIsReliable() {
        bitField0_ = (bitField0_ & ~0x00000002);
        isReliable_ = false;
      }

      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code sync_pb.UserEventSpecifics.LanguageDetection.Language}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language, Builder> implements
          // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.LanguageDetection.Language)
          org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.LanguageOrBuilder {
        // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * ISO 639 language code will be used.
         * </pre>
         *
         * <code>optional string language_code = 1;</code>
         * @return Whether the languageCode field is set.
         */
        @java.lang.Override
        public boolean hasLanguageCode() {
          return instance.hasLanguageCode();
        }
        /**
         * <pre>
         * ISO 639 language code will be used.
         * </pre>
         *
         * <code>optional string language_code = 1;</code>
         * @return The languageCode.
         */
        @java.lang.Override
        public java.lang.String getLanguageCode() {
          return instance.getLanguageCode();
        }
        /**
         * <pre>
         * ISO 639 language code will be used.
         * </pre>
         *
         * <code>optional string language_code = 1;</code>
         * @return The bytes for languageCode.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getLanguageCodeBytes() {
          return instance.getLanguageCodeBytes();
        }
        /**
         * <pre>
         * ISO 639 language code will be used.
         * </pre>
         *
         * <code>optional string language_code = 1;</code>
         * @param value The languageCode to set.
         * @return This builder for chaining.
         */
        public Builder setLanguageCode(
            java.lang.String value) {
          copyOnWrite();
          instance.setLanguageCode(value);
          return this;
        }
        /**
         * <pre>
         * ISO 639 language code will be used.
         * </pre>
         *
         * <code>optional string language_code = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearLanguageCode() {
          copyOnWrite();
          instance.clearLanguageCode();
          return this;
        }
        /**
         * <pre>
         * ISO 639 language code will be used.
         * </pre>
         *
         * <code>optional string language_code = 1;</code>
         * @param value The bytes for languageCode to set.
         * @return This builder for chaining.
         */
        public Builder setLanguageCodeBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setLanguageCodeBytes(value);
          return this;
        }

        /**
         * <pre>
         * Whether the detected language is reliable, note this is determined by
         * the CLD3.
         * </pre>
         *
         * <code>optional bool is_reliable = 2;</code>
         * @return Whether the isReliable field is set.
         */
        @java.lang.Override
        public boolean hasIsReliable() {
          return instance.hasIsReliable();
        }
        /**
         * <pre>
         * Whether the detected language is reliable, note this is determined by
         * the CLD3.
         * </pre>
         *
         * <code>optional bool is_reliable = 2;</code>
         * @return The isReliable.
         */
        @java.lang.Override
        public boolean getIsReliable() {
          return instance.getIsReliable();
        }
        /**
         * <pre>
         * Whether the detected language is reliable, note this is determined by
         * the CLD3.
         * </pre>
         *
         * <code>optional bool is_reliable = 2;</code>
         * @param value The isReliable to set.
         * @return This builder for chaining.
         */
        public Builder setIsReliable(boolean value) {
          copyOnWrite();
          instance.setIsReliable(value);
          return this;
        }
        /**
         * <pre>
         * Whether the detected language is reliable, note this is determined by
         * the CLD3.
         * </pre>
         *
         * <code>optional bool is_reliable = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsReliable() {
          copyOnWrite();
          instance.clearIsReliable();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.LanguageDetection.Language)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "languageCode_",
                "isReliable_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                  "\u1007\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> parser = PARSER;
            if (parser == null) {
              synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.LanguageDetection.Language)
      private static final org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language DEFAULT_INSTANCE;
      static {
        Language defaultInstance = new Language();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Language.class, defaultInstance);
      }

      public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Language> PARSER;

      public static com.google.protobuf.Parser<Language> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int DETECTED_LANGUAGES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> detectedLanguages_;
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> getDetectedLanguagesList() {
      return detectedLanguages_;
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    public java.util.List<? extends org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.LanguageOrBuilder> 
        getDetectedLanguagesOrBuilderList() {
      return detectedLanguages_;
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    @java.lang.Override
    public int getDetectedLanguagesCount() {
      return detectedLanguages_.size();
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language getDetectedLanguages(int index) {
      return detectedLanguages_.get(index);
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    public org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.LanguageOrBuilder getDetectedLanguagesOrBuilder(
        int index) {
      return detectedLanguages_.get(index);
    }
    private void ensureDetectedLanguagesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> tmp = detectedLanguages_;
      if (!tmp.isModifiable()) {
        detectedLanguages_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    private void setDetectedLanguages(
        int index, org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language value) {
      value.getClass();
  ensureDetectedLanguagesIsMutable();
      detectedLanguages_.set(index, value);
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    private void addDetectedLanguages(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language value) {
      value.getClass();
  ensureDetectedLanguagesIsMutable();
      detectedLanguages_.add(value);
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    private void addDetectedLanguages(
        int index, org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language value) {
      value.getClass();
  ensureDetectedLanguagesIsMutable();
      detectedLanguages_.add(index, value);
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    private void addAllDetectedLanguages(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> values) {
      ensureDetectedLanguagesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, detectedLanguages_);
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    private void clearDetectedLanguages() {
      detectedLanguages_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Top n languages. Typically we just log the top language, but for page
     * that we're not confident about, we may log up to 3 top languages in
     * descending order.
     * </pre>
     *
     * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
     */
    private void removeDetectedLanguages(int index) {
      ensureDetectedLanguagesIsMutable();
      detectedLanguages_.remove(index);
    }

    public static final int ADOPTED_LANGUAGE_CODE_FIELD_NUMBER = 2;
    private java.lang.String adoptedLanguageCode_;
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @return Whether the adoptedLanguageCode field is set.
     */
    @java.lang.Override
    public boolean hasAdoptedLanguageCode() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @return The adoptedLanguageCode.
     */
    @java.lang.Override
    public java.lang.String getAdoptedLanguageCode() {
      return adoptedLanguageCode_;
    }
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @return The bytes for adoptedLanguageCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAdoptedLanguageCodeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(adoptedLanguageCode_);
    }
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @param value The adoptedLanguageCode to set.
     */
    private void setAdoptedLanguageCode(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      adoptedLanguageCode_ = value;
    }
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     */
    private void clearAdoptedLanguageCode() {
      bitField0_ = (bitField0_ & ~0x00000001);
      adoptedLanguageCode_ = getDefaultInstance().getAdoptedLanguageCode();
    }
    /**
     * <pre>
     * Adopted language code is the code of final determined language.
     * It will be stored only if it's different from the first detected
     * language.
     * </pre>
     *
     * <code>optional string adopted_language_code = 2;</code>
     * @param value The bytes for adoptedLanguageCode to set.
     */
    private void setAdoptedLanguageCodeBytes(
        com.google.protobuf.ByteString value) {
      adoptedLanguageCode_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Language detection output.
     * </pre>
     *
     * Protobuf type {@code sync_pb.UserEventSpecifics.LanguageDetection}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection, Builder> implements
        // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.LanguageDetection)
        org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetectionOrBuilder {
      // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> getDetectedLanguagesList() {
        return java.util.Collections.unmodifiableList(
            instance.getDetectedLanguagesList());
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      @java.lang.Override
      public int getDetectedLanguagesCount() {
        return instance.getDetectedLanguagesCount();
      }/**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language getDetectedLanguages(int index) {
        return instance.getDetectedLanguages(index);
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder setDetectedLanguages(
          int index, org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language value) {
        copyOnWrite();
        instance.setDetectedLanguages(index, value);
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder setDetectedLanguages(
          int index, org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language.Builder builderForValue) {
        copyOnWrite();
        instance.setDetectedLanguages(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder addDetectedLanguages(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language value) {
        copyOnWrite();
        instance.addDetectedLanguages(value);
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder addDetectedLanguages(
          int index, org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language value) {
        copyOnWrite();
        instance.addDetectedLanguages(index, value);
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder addDetectedLanguages(
          org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language.Builder builderForValue) {
        copyOnWrite();
        instance.addDetectedLanguages(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder addDetectedLanguages(
          int index, org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language.Builder builderForValue) {
        copyOnWrite();
        instance.addDetectedLanguages(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder addAllDetectedLanguages(
          java.lang.Iterable<? extends org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language> values) {
        copyOnWrite();
        instance.addAllDetectedLanguages(values);
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder clearDetectedLanguages() {
        copyOnWrite();
        instance.clearDetectedLanguages();
        return this;
      }
      /**
       * <pre>
       * Top n languages. Typically we just log the top language, but for page
       * that we're not confident about, we may log up to 3 top languages in
       * descending order.
       * </pre>
       *
       * <code>repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;</code>
       */
      public Builder removeDetectedLanguages(int index) {
        copyOnWrite();
        instance.removeDetectedLanguages(index);
        return this;
      }

      /**
       * <pre>
       * Adopted language code is the code of final determined language.
       * It will be stored only if it's different from the first detected
       * language.
       * </pre>
       *
       * <code>optional string adopted_language_code = 2;</code>
       * @return Whether the adoptedLanguageCode field is set.
       */
      @java.lang.Override
      public boolean hasAdoptedLanguageCode() {
        return instance.hasAdoptedLanguageCode();
      }
      /**
       * <pre>
       * Adopted language code is the code of final determined language.
       * It will be stored only if it's different from the first detected
       * language.
       * </pre>
       *
       * <code>optional string adopted_language_code = 2;</code>
       * @return The adoptedLanguageCode.
       */
      @java.lang.Override
      public java.lang.String getAdoptedLanguageCode() {
        return instance.getAdoptedLanguageCode();
      }
      /**
       * <pre>
       * Adopted language code is the code of final determined language.
       * It will be stored only if it's different from the first detected
       * language.
       * </pre>
       *
       * <code>optional string adopted_language_code = 2;</code>
       * @return The bytes for adoptedLanguageCode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAdoptedLanguageCodeBytes() {
        return instance.getAdoptedLanguageCodeBytes();
      }
      /**
       * <pre>
       * Adopted language code is the code of final determined language.
       * It will be stored only if it's different from the first detected
       * language.
       * </pre>
       *
       * <code>optional string adopted_language_code = 2;</code>
       * @param value The adoptedLanguageCode to set.
       * @return This builder for chaining.
       */
      public Builder setAdoptedLanguageCode(
          java.lang.String value) {
        copyOnWrite();
        instance.setAdoptedLanguageCode(value);
        return this;
      }
      /**
       * <pre>
       * Adopted language code is the code of final determined language.
       * It will be stored only if it's different from the first detected
       * language.
       * </pre>
       *
       * <code>optional string adopted_language_code = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAdoptedLanguageCode() {
        copyOnWrite();
        instance.clearAdoptedLanguageCode();
        return this;
      }
      /**
       * <pre>
       * Adopted language code is the code of final determined language.
       * It will be stored only if it's different from the first detected
       * language.
       * </pre>
       *
       * <code>optional string adopted_language_code = 2;</code>
       * @param value The bytes for adoptedLanguageCode to set.
       * @return This builder for chaining.
       */
      public Builder setAdoptedLanguageCodeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAdoptedLanguageCodeBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.LanguageDetection)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "detectedLanguages_",
              org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Language.class,
              "adoptedLanguageCode_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u001b\u0002\u1008" +
                "\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.LanguageDetection)
    private static final org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection DEFAULT_INSTANCE;
    static {
      LanguageDetection defaultInstance = new LanguageDetection();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        LanguageDetection.class, defaultInstance);
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LanguageDetection> PARSER;

    public static com.google.protobuf.Parser<LanguageDetection> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  @java.lang.Deprecated public interface TranslationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.Translation)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @return Whether the fromLanguageCode field is set.
     */
    boolean hasFromLanguageCode();
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @return The fromLanguageCode.
     */
    java.lang.String getFromLanguageCode();
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @return The bytes for fromLanguageCode.
     */
    com.google.protobuf.ByteString
        getFromLanguageCodeBytes();

    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @return Whether the toLanguageCode field is set.
     */
    boolean hasToLanguageCode();
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @return The toLanguageCode.
     */
    java.lang.String getToLanguageCode();
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @return The bytes for toLanguageCode.
     */
    com.google.protobuf.ByteString
        getToLanguageCodeBytes();

    /**
     * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
     * @return Whether the interaction field is set.
     */
    boolean hasInteraction();
    /**
     * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
     * @return The interaction.
     */
    org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction getInteraction();
  }
  /**
   * <pre>
   * User translated a page or interacted with translate suggestion.
   * </pre>
   *
   * Protobuf type {@code sync_pb.UserEventSpecifics.Translation}
   */
  @java.lang.Deprecated public  static final class Translation extends
      com.google.protobuf.GeneratedMessageLite<
          Translation, Translation.Builder> implements
      // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.Translation)
      TranslationOrBuilder {
    private Translation() {
      fromLanguageCode_ = "";
      toLanguageCode_ = "";
    }
    /**
     * Protobuf enum {@code sync_pb.UserEventSpecifics.Translation.Interaction}
     */
    public enum Interaction
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <code>ACCEPT = 1;</code>
       */
      ACCEPT(1),
      /**
       * <code>DECLINE = 2;</code>
       */
      DECLINE(2),
      /**
       * <pre>
       * This happens when user scroll or click outside the UI without
       * translation.
       * </pre>
       *
       * <code>IGNORED = 3;</code>
       */
      IGNORED(3),
      /**
       * <pre>
       * This happens when user choose to close the translation window without
       * translation.
       * </pre>
       *
       * <code>DISMISSED = 4;</code>
       */
      DISMISSED(4),
      /**
       * <pre>
       * User manually entered either language.
       * In this case, from_language_code and to_language_code will be user
       * chosen values.
       * </pre>
       *
       * <code>MANUAL = 5;</code>
       */
      MANUAL(5),
      /**
       * <pre>
       * User choose to revert the translation, in this case, from_language_code
       * and to_language_code will be previous chosen values.
       * </pre>
       *
       * <code>TRANSLATION_REVERTED = 6;</code>
       */
      TRANSLATION_REVERTED(6),
      /**
       * <pre>
       * Automatically triggered translation.
       * User sets always translate in user settings.
       * </pre>
       *
       * <code>AUTO_TRANSLATION_BY_PREF = 7;</code>
       */
      AUTO_TRANSLATION_BY_PREF(7),
      /**
       * <pre>
       * User navigated through a click from a translated page.
       * </pre>
       *
       * <code>AUTO_TRANSLATION_BY_LINK = 8;</code>
       */
      AUTO_TRANSLATION_BY_LINK(8),
      /**
       * <pre>
       * Failed to initialize the translate script, this can happen for iOS due
       * to CSPs.
       * </pre>
       *
       * <code>INITIALIZATION_ERROR = 9;</code>
       */
      INITIALIZATION_ERROR(9),
      ;

      /**
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <code>ACCEPT = 1;</code>
       */
      public static final int ACCEPT_VALUE = 1;
      /**
       * <code>DECLINE = 2;</code>
       */
      public static final int DECLINE_VALUE = 2;
      /**
       * <pre>
       * This happens when user scroll or click outside the UI without
       * translation.
       * </pre>
       *
       * <code>IGNORED = 3;</code>
       */
      public static final int IGNORED_VALUE = 3;
      /**
       * <pre>
       * This happens when user choose to close the translation window without
       * translation.
       * </pre>
       *
       * <code>DISMISSED = 4;</code>
       */
      public static final int DISMISSED_VALUE = 4;
      /**
       * <pre>
       * User manually entered either language.
       * In this case, from_language_code and to_language_code will be user
       * chosen values.
       * </pre>
       *
       * <code>MANUAL = 5;</code>
       */
      public static final int MANUAL_VALUE = 5;
      /**
       * <pre>
       * User choose to revert the translation, in this case, from_language_code
       * and to_language_code will be previous chosen values.
       * </pre>
       *
       * <code>TRANSLATION_REVERTED = 6;</code>
       */
      public static final int TRANSLATION_REVERTED_VALUE = 6;
      /**
       * <pre>
       * Automatically triggered translation.
       * User sets always translate in user settings.
       * </pre>
       *
       * <code>AUTO_TRANSLATION_BY_PREF = 7;</code>
       */
      public static final int AUTO_TRANSLATION_BY_PREF_VALUE = 7;
      /**
       * <pre>
       * User navigated through a click from a translated page.
       * </pre>
       *
       * <code>AUTO_TRANSLATION_BY_LINK = 8;</code>
       */
      public static final int AUTO_TRANSLATION_BY_LINK_VALUE = 8;
      /**
       * <pre>
       * Failed to initialize the translate script, this can happen for iOS due
       * to CSPs.
       * </pre>
       *
       * <code>INITIALIZATION_ERROR = 9;</code>
       */
      public static final int INITIALIZATION_ERROR_VALUE = 9;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Interaction valueOf(int value) {
        return forNumber(value);
      }

      public static Interaction forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return ACCEPT;
          case 2: return DECLINE;
          case 3: return IGNORED;
          case 4: return DISMISSED;
          case 5: return MANUAL;
          case 6: return TRANSLATION_REVERTED;
          case 7: return AUTO_TRANSLATION_BY_PREF;
          case 8: return AUTO_TRANSLATION_BY_LINK;
          case 9: return INITIALIZATION_ERROR;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Interaction>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Interaction> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Interaction>() {
              @java.lang.Override
              public Interaction findValueByNumber(int number) {
                return Interaction.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return InteractionVerifier.INSTANCE;
      }

      private static final class InteractionVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InteractionVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Interaction.forNumber(number) != null;
              }
            };

      private final int value;

      private Interaction(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:sync_pb.UserEventSpecifics.Translation.Interaction)
    }

    private int bitField0_;
    public static final int FROM_LANGUAGE_CODE_FIELD_NUMBER = 1;
    private java.lang.String fromLanguageCode_;
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @return Whether the fromLanguageCode field is set.
     */
    @java.lang.Override
    public boolean hasFromLanguageCode() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @return The fromLanguageCode.
     */
    @java.lang.Override
    public java.lang.String getFromLanguageCode() {
      return fromLanguageCode_;
    }
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @return The bytes for fromLanguageCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFromLanguageCodeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(fromLanguageCode_);
    }
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @param value The fromLanguageCode to set.
     */
    private void setFromLanguageCode(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      fromLanguageCode_ = value;
    }
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     */
    private void clearFromLanguageCode() {
      bitField0_ = (bitField0_ & ~0x00000001);
      fromLanguageCode_ = getDefaultInstance().getFromLanguageCode();
    }
    /**
     * <pre>
     * Source language of the translation.
     * </pre>
     *
     * <code>optional string from_language_code = 1;</code>
     * @param value The bytes for fromLanguageCode to set.
     */
    private void setFromLanguageCodeBytes(
        com.google.protobuf.ByteString value) {
      fromLanguageCode_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int TO_LANGUAGE_CODE_FIELD_NUMBER = 2;
    private java.lang.String toLanguageCode_;
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @return Whether the toLanguageCode field is set.
     */
    @java.lang.Override
    public boolean hasToLanguageCode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @return The toLanguageCode.
     */
    @java.lang.Override
    public java.lang.String getToLanguageCode() {
      return toLanguageCode_;
    }
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @return The bytes for toLanguageCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getToLanguageCodeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(toLanguageCode_);
    }
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @param value The toLanguageCode to set.
     */
    private void setToLanguageCode(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000002;
      toLanguageCode_ = value;
    }
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     */
    private void clearToLanguageCode() {
      bitField0_ = (bitField0_ & ~0x00000002);
      toLanguageCode_ = getDefaultInstance().getToLanguageCode();
    }
    /**
     * <pre>
     * Target language of the translation.
     * </pre>
     *
     * <code>optional string to_language_code = 2;</code>
     * @param value The bytes for toLanguageCode to set.
     */
    private void setToLanguageCodeBytes(
        com.google.protobuf.ByteString value) {
      toLanguageCode_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int INTERACTION_FIELD_NUMBER = 3;
    private int interaction_;
    /**
     * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
     * @return Whether the interaction field is set.
     */
    @java.lang.Override
    public boolean hasInteraction() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
     * @return The interaction.
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction getInteraction() {
      org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction result = org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction.forNumber(interaction_);
      return result == null ? org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction.UNKNOWN : result;
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
     * @param value The interaction to set.
     */
    private void setInteraction(org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction value) {
      interaction_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
     */
    private void clearInteraction() {
      bitField0_ = (bitField0_ & ~0x00000004);
      interaction_ = 0;
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.Translation prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * User translated a page or interacted with translate suggestion.
     * </pre>
     *
     * Protobuf type {@code sync_pb.UserEventSpecifics.Translation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.sync.protocol.UserEventSpecifics.Translation, Builder> implements
        // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.Translation)
        org.chromium.components.sync.protocol.UserEventSpecifics.TranslationOrBuilder {
      // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.Translation.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Source language of the translation.
       * </pre>
       *
       * <code>optional string from_language_code = 1;</code>
       * @return Whether the fromLanguageCode field is set.
       */
      @java.lang.Override
      public boolean hasFromLanguageCode() {
        return instance.hasFromLanguageCode();
      }
      /**
       * <pre>
       * Source language of the translation.
       * </pre>
       *
       * <code>optional string from_language_code = 1;</code>
       * @return The fromLanguageCode.
       */
      @java.lang.Override
      public java.lang.String getFromLanguageCode() {
        return instance.getFromLanguageCode();
      }
      /**
       * <pre>
       * Source language of the translation.
       * </pre>
       *
       * <code>optional string from_language_code = 1;</code>
       * @return The bytes for fromLanguageCode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFromLanguageCodeBytes() {
        return instance.getFromLanguageCodeBytes();
      }
      /**
       * <pre>
       * Source language of the translation.
       * </pre>
       *
       * <code>optional string from_language_code = 1;</code>
       * @param value The fromLanguageCode to set.
       * @return This builder for chaining.
       */
      public Builder setFromLanguageCode(
          java.lang.String value) {
        copyOnWrite();
        instance.setFromLanguageCode(value);
        return this;
      }
      /**
       * <pre>
       * Source language of the translation.
       * </pre>
       *
       * <code>optional string from_language_code = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFromLanguageCode() {
        copyOnWrite();
        instance.clearFromLanguageCode();
        return this;
      }
      /**
       * <pre>
       * Source language of the translation.
       * </pre>
       *
       * <code>optional string from_language_code = 1;</code>
       * @param value The bytes for fromLanguageCode to set.
       * @return This builder for chaining.
       */
      public Builder setFromLanguageCodeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFromLanguageCodeBytes(value);
        return this;
      }

      /**
       * <pre>
       * Target language of the translation.
       * </pre>
       *
       * <code>optional string to_language_code = 2;</code>
       * @return Whether the toLanguageCode field is set.
       */
      @java.lang.Override
      public boolean hasToLanguageCode() {
        return instance.hasToLanguageCode();
      }
      /**
       * <pre>
       * Target language of the translation.
       * </pre>
       *
       * <code>optional string to_language_code = 2;</code>
       * @return The toLanguageCode.
       */
      @java.lang.Override
      public java.lang.String getToLanguageCode() {
        return instance.getToLanguageCode();
      }
      /**
       * <pre>
       * Target language of the translation.
       * </pre>
       *
       * <code>optional string to_language_code = 2;</code>
       * @return The bytes for toLanguageCode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getToLanguageCodeBytes() {
        return instance.getToLanguageCodeBytes();
      }
      /**
       * <pre>
       * Target language of the translation.
       * </pre>
       *
       * <code>optional string to_language_code = 2;</code>
       * @param value The toLanguageCode to set.
       * @return This builder for chaining.
       */
      public Builder setToLanguageCode(
          java.lang.String value) {
        copyOnWrite();
        instance.setToLanguageCode(value);
        return this;
      }
      /**
       * <pre>
       * Target language of the translation.
       * </pre>
       *
       * <code>optional string to_language_code = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearToLanguageCode() {
        copyOnWrite();
        instance.clearToLanguageCode();
        return this;
      }
      /**
       * <pre>
       * Target language of the translation.
       * </pre>
       *
       * <code>optional string to_language_code = 2;</code>
       * @param value The bytes for toLanguageCode to set.
       * @return This builder for chaining.
       */
      public Builder setToLanguageCodeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setToLanguageCodeBytes(value);
        return this;
      }

      /**
       * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
       * @return Whether the interaction field is set.
       */
      @java.lang.Override
      public boolean hasInteraction() {
        return instance.hasInteraction();
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
       * @return The interaction.
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction getInteraction() {
        return instance.getInteraction();
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
       * @param value The enum numeric value on the wire for interaction to set.
       * @return This builder for chaining.
       */
      public Builder setInteraction(org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction value) {
        copyOnWrite();
        instance.setInteraction(value);
        return this;
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearInteraction() {
        copyOnWrite();
        instance.clearInteraction();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.Translation)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.sync.protocol.UserEventSpecifics.Translation();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "fromLanguageCode_",
              "toLanguageCode_",
              "interaction_",
              org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Interaction.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u1008\u0001\u0003\u100c\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.Translation> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.Translation.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.Translation>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.Translation)
    private static final org.chromium.components.sync.protocol.UserEventSpecifics.Translation DEFAULT_INSTANCE;
    static {
      Translation defaultInstance = new Translation();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Translation.class, defaultInstance);
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.Translation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Translation> PARSER;

    public static com.google.protobuf.Parser<Translation> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  @java.lang.Deprecated public interface UserConsentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.UserConsent)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @return Whether the locale field is set.
     */
    boolean hasLocale();
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @return The locale.
     */
    java.lang.String getLocale();
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @return The bytes for locale.
     */
    com.google.protobuf.ByteString
        getLocaleBytes();

    /**
     * <pre>
     * The local time on the client when the user consent was recorded. The time
     * as measured by client is given in microseconds since Windows epoch. This
     * is needed since user consent recording may happen when a client is
     * offline.
     * </pre>
     *
     * <code>optional int64 client_consent_time_usec = 12;</code>
     * @return Whether the clientConsentTimeUsec field is set.
     */
    boolean hasClientConsentTimeUsec();
    /**
     * <pre>
     * The local time on the client when the user consent was recorded. The time
     * as measured by client is given in microseconds since Windows epoch. This
     * is needed since user consent recording may happen when a client is
     * offline.
     * </pre>
     *
     * <code>optional int64 client_consent_time_usec = 12;</code>
     * @return The clientConsentTimeUsec.
     */
    long getClientConsentTimeUsec();

    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     * @return Whether the syncConsent field is set.
     */
    boolean hasSyncConsent();
    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     * @return The syncConsent.
     */
    org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent getSyncConsent();

    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     * @return Whether the arcBackupAndRestoreConsent field is set.
     */
    boolean hasArcBackupAndRestoreConsent();
    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     * @return The arcBackupAndRestoreConsent.
     */
    org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent getArcBackupAndRestoreConsent();

    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     * @return Whether the arcLocationServiceConsent field is set.
     */
    boolean hasArcLocationServiceConsent();
    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     * @return The arcLocationServiceConsent.
     */
    org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent getArcLocationServiceConsent();

    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     * @return Whether the arcPlayTermsOfServiceConsent field is set.
     */
    boolean hasArcPlayTermsOfServiceConsent();
    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     * @return The arcPlayTermsOfServiceConsent.
     */
    org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent getArcPlayTermsOfServiceConsent();

    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     * @return Whether the unifiedConsent field is set.
     */
    boolean hasUnifiedConsent();
    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     * @return The unifiedConsent.
     */
    org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent getUnifiedConsent();

    /**
     * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
     * @return Whether the feature field is set.
     */
    @java.lang.Deprecated boolean hasFeature();
    /**
     * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
     * @return The feature.
     */
    @java.lang.Deprecated org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature getFeature();

    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @return A list containing the descriptionGrdIds.
     */
    @java.lang.Deprecated java.util.List<java.lang.Integer> getDescriptionGrdIdsList();
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @return The count of descriptionGrdIds.
     */
    @java.lang.Deprecated int getDescriptionGrdIdsCount();
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @param index The index of the element to return.
     * @return The descriptionGrdIds at the given index.
     */
    @java.lang.Deprecated int getDescriptionGrdIds(int index);

    /**
     * <pre>
     * Id of the string of the UI element the user clicked when consenting.
     * </pre>
     *
     * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
     * @return Whether the confirmationGrdId field is set.
     */
    @java.lang.Deprecated boolean hasConfirmationGrdId();
    /**
     * <pre>
     * Id of the string of the UI element the user clicked when consenting.
     * </pre>
     *
     * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
     * @return The confirmationGrdId.
     */
    @java.lang.Deprecated int getConfirmationGrdId();

    /**
     * <pre>
     * Was the consent for |feature| given or not given (denied/revoked)?
     * </pre>
     *
     * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
     * @return Whether the status field is set.
     */
    @java.lang.Deprecated boolean hasStatus();
    /**
     * <pre>
     * Was the consent for |feature| given or not given (denied/revoked)?
     * </pre>
     *
     * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
     * @return The status.
     */
    @java.lang.Deprecated org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus getStatus();

    public org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.ConsentCase getConsentCase();
  }
  /**
   * <pre>
   * User consented to the usage of a feature or denied/revoked a consent.
   * This is not used anymore; consents were migrated to a separate data type.
   * The message has to stay though since the server must keep supporting legacy
   * consent formats like this.
   * Next id: 14
   * </pre>
   *
   * Protobuf type {@code sync_pb.UserEventSpecifics.UserConsent}
   */
  @java.lang.Deprecated public  static final class UserConsent extends
      com.google.protobuf.GeneratedMessageLite<
          UserConsent, UserConsent.Builder> implements
      // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.UserConsent)
      UserConsentOrBuilder {
    private UserConsent() {
      locale_ = "";
      descriptionGrdIds_ = emptyIntList();
    }
    /**
     * <pre>
     * Which feature does the consent apply to?
     * </pre>
     *
     * Protobuf enum {@code sync_pb.UserEventSpecifics.UserConsent.Feature}
     */
    public enum Feature
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>FEATURE_UNSPECIFIED = 0;</code>
       */
      FEATURE_UNSPECIFIED(0),
      /**
       * <code>CHROME_SYNC = 1;</code>
       */
      CHROME_SYNC(1),
      /**
       * <code>PLAY_STORE = 2;</code>
       */
      PLAY_STORE(2),
      /**
       * <code>BACKUP_AND_RESTORE = 3;</code>
       */
      BACKUP_AND_RESTORE(3),
      /**
       * <code>GOOGLE_LOCATION_SERVICE = 4;</code>
       */
      GOOGLE_LOCATION_SERVICE(4),
      /**
       * <code>CHROME_UNIFIED_CONSENT = 5;</code>
       */
      CHROME_UNIFIED_CONSENT(5),
      /**
       * <pre>
       * TODO(markusheintz): ASSISTANT_ACTIVITY_CONTROL was only added as
       * emergency fallback. Remove if not needed.
       * </pre>
       *
       * <code>ASSISTANT_ACTIVITY_CONTROL = 6;</code>
       */
      ASSISTANT_ACTIVITY_CONTROL(6),
      ;

      /**
       * <code>FEATURE_UNSPECIFIED = 0;</code>
       */
      public static final int FEATURE_UNSPECIFIED_VALUE = 0;
      /**
       * <code>CHROME_SYNC = 1;</code>
       */
      public static final int CHROME_SYNC_VALUE = 1;
      /**
       * <code>PLAY_STORE = 2;</code>
       */
      public static final int PLAY_STORE_VALUE = 2;
      /**
       * <code>BACKUP_AND_RESTORE = 3;</code>
       */
      public static final int BACKUP_AND_RESTORE_VALUE = 3;
      /**
       * <code>GOOGLE_LOCATION_SERVICE = 4;</code>
       */
      public static final int GOOGLE_LOCATION_SERVICE_VALUE = 4;
      /**
       * <code>CHROME_UNIFIED_CONSENT = 5;</code>
       */
      public static final int CHROME_UNIFIED_CONSENT_VALUE = 5;
      /**
       * <pre>
       * TODO(markusheintz): ASSISTANT_ACTIVITY_CONTROL was only added as
       * emergency fallback. Remove if not needed.
       * </pre>
       *
       * <code>ASSISTANT_ACTIVITY_CONTROL = 6;</code>
       */
      public static final int ASSISTANT_ACTIVITY_CONTROL_VALUE = 6;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Feature valueOf(int value) {
        return forNumber(value);
      }

      public static Feature forNumber(int value) {
        switch (value) {
          case 0: return FEATURE_UNSPECIFIED;
          case 1: return CHROME_SYNC;
          case 2: return PLAY_STORE;
          case 3: return BACKUP_AND_RESTORE;
          case 4: return GOOGLE_LOCATION_SERVICE;
          case 5: return CHROME_UNIFIED_CONSENT;
          case 6: return ASSISTANT_ACTIVITY_CONTROL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Feature>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Feature> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Feature>() {
              @java.lang.Override
              public Feature findValueByNumber(int number) {
                return Feature.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return FeatureVerifier.INSTANCE;
      }

      private static final class FeatureVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new FeatureVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Feature.forNumber(number) != null;
              }
            };

      private final int value;

      private Feature(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:sync_pb.UserEventSpecifics.UserConsent.Feature)
    }

    private int bitField0_;
    private int consentCase_ = 0;
    private java.lang.Object consent_;
    public enum ConsentCase {
      SYNC_CONSENT(7),
      ARC_BACKUP_AND_RESTORE_CONSENT(8),
      ARC_LOCATION_SERVICE_CONSENT(9),
      ARC_PLAY_TERMS_OF_SERVICE_CONSENT(10),
      UNIFIED_CONSENT(13),
      CONSENT_NOT_SET(0);
      private final int value;
      private ConsentCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ConsentCase valueOf(int value) {
        return forNumber(value);
      }

      public static ConsentCase forNumber(int value) {
        switch (value) {
          case 7: return SYNC_CONSENT;
          case 8: return ARC_BACKUP_AND_RESTORE_CONSENT;
          case 9: return ARC_LOCATION_SERVICE_CONSENT;
          case 10: return ARC_PLAY_TERMS_OF_SERVICE_CONSENT;
          case 13: return UNIFIED_CONSENT;
          case 0: return CONSENT_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public ConsentCase
    getConsentCase() {
      return ConsentCase.forNumber(
          consentCase_);
    }

    private void clearConsent() {
      consentCase_ = 0;
      consent_ = null;
    }

    public static final int LOCALE_FIELD_NUMBER = 4;
    private java.lang.String locale_;
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @return Whether the locale field is set.
     */
    @java.lang.Override
    public boolean hasLocale() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @return The locale.
     */
    @java.lang.Override
    public java.lang.String getLocale() {
      return locale_;
    }
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @return The bytes for locale.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLocaleBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(locale_);
    }
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @param value The locale to set.
     */
    private void setLocale(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      locale_ = value;
    }
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     */
    private void clearLocale() {
      bitField0_ = (bitField0_ & ~0x00000001);
      locale_ = getDefaultInstance().getLocale();
    }
    /**
     * <pre>
     * The UI language Chrome is using, represented as the IETF language tag
     * defined in BCP 47. The region subtag is not included when it adds no
     * distinguishing information to the language tag (e.g. both "en-US"
     * and "fr" are correct here).
     * </pre>
     *
     * <code>optional string locale = 4;</code>
     * @param value The bytes for locale to set.
     */
    private void setLocaleBytes(
        com.google.protobuf.ByteString value) {
      locale_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int CLIENT_CONSENT_TIME_USEC_FIELD_NUMBER = 12;
    private long clientConsentTimeUsec_;
    /**
     * <pre>
     * The local time on the client when the user consent was recorded. The time
     * as measured by client is given in microseconds since Windows epoch. This
     * is needed since user consent recording may happen when a client is
     * offline.
     * </pre>
     *
     * <code>optional int64 client_consent_time_usec = 12;</code>
     * @return Whether the clientConsentTimeUsec field is set.
     */
    @java.lang.Override
    public boolean hasClientConsentTimeUsec() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The local time on the client when the user consent was recorded. The time
     * as measured by client is given in microseconds since Windows epoch. This
     * is needed since user consent recording may happen when a client is
     * offline.
     * </pre>
     *
     * <code>optional int64 client_consent_time_usec = 12;</code>
     * @return The clientConsentTimeUsec.
     */
    @java.lang.Override
    public long getClientConsentTimeUsec() {
      return clientConsentTimeUsec_;
    }
    /**
     * <pre>
     * The local time on the client when the user consent was recorded. The time
     * as measured by client is given in microseconds since Windows epoch. This
     * is needed since user consent recording may happen when a client is
     * offline.
     * </pre>
     *
     * <code>optional int64 client_consent_time_usec = 12;</code>
     * @param value The clientConsentTimeUsec to set.
     */
    private void setClientConsentTimeUsec(long value) {
      bitField0_ |= 0x00000002;
      clientConsentTimeUsec_ = value;
    }
    /**
     * <pre>
     * The local time on the client when the user consent was recorded. The time
     * as measured by client is given in microseconds since Windows epoch. This
     * is needed since user consent recording may happen when a client is
     * offline.
     * </pre>
     *
     * <code>optional int64 client_consent_time_usec = 12;</code>
     */
    private void clearClientConsentTimeUsec() {
      bitField0_ = (bitField0_ & ~0x00000002);
      clientConsentTimeUsec_ = 0L;
    }

    public static final int SYNC_CONSENT_FIELD_NUMBER = 7;
    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     */
    @java.lang.Override
    public boolean hasSyncConsent() {
      return consentCase_ == 7;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent getSyncConsent() {
      if (consentCase_ == 7) {
         return (org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent) consent_;
      }
      return org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent.getDefaultInstance();
    }
    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     */
    private void setSyncConsent(org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent value) {
      value.getClass();
  consent_ = value;
      consentCase_ = 7;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     */
    private void mergeSyncConsent(org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent value) {
      value.getClass();
  if (consentCase_ == 7 &&
          consent_ != org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent.getDefaultInstance()) {
        consent_ = org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent.newBuilder((org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent) consent_)
            .mergeFrom(value).buildPartial();
      } else {
        consent_ = value;
      }
      consentCase_ = 7;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
     */
    private void clearSyncConsent() {
      if (consentCase_ == 7) {
        consentCase_ = 0;
        consent_ = null;
      }
    }

    public static final int ARC_BACKUP_AND_RESTORE_CONSENT_FIELD_NUMBER = 8;
    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     */
    @java.lang.Override
    public boolean hasArcBackupAndRestoreConsent() {
      return consentCase_ == 8;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent getArcBackupAndRestoreConsent() {
      if (consentCase_ == 8) {
         return (org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent) consent_;
      }
      return org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent.getDefaultInstance();
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     */
    private void setArcBackupAndRestoreConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent value) {
      value.getClass();
  consent_ = value;
      consentCase_ = 8;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     */
    private void mergeArcBackupAndRestoreConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent value) {
      value.getClass();
  if (consentCase_ == 8 &&
          consent_ != org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent.getDefaultInstance()) {
        consent_ = org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent.newBuilder((org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent) consent_)
            .mergeFrom(value).buildPartial();
      } else {
        consent_ = value;
      }
      consentCase_ = 8;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
     */
    private void clearArcBackupAndRestoreConsent() {
      if (consentCase_ == 8) {
        consentCase_ = 0;
        consent_ = null;
      }
    }

    public static final int ARC_LOCATION_SERVICE_CONSENT_FIELD_NUMBER = 9;
    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     */
    @java.lang.Override
    public boolean hasArcLocationServiceConsent() {
      return consentCase_ == 9;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent getArcLocationServiceConsent() {
      if (consentCase_ == 9) {
         return (org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent) consent_;
      }
      return org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent.getDefaultInstance();
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     */
    private void setArcLocationServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent value) {
      value.getClass();
  consent_ = value;
      consentCase_ = 9;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     */
    private void mergeArcLocationServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent value) {
      value.getClass();
  if (consentCase_ == 9 &&
          consent_ != org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent.getDefaultInstance()) {
        consent_ = org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent.newBuilder((org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent) consent_)
            .mergeFrom(value).buildPartial();
      } else {
        consent_ = value;
      }
      consentCase_ = 9;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
     */
    private void clearArcLocationServiceConsent() {
      if (consentCase_ == 9) {
        consentCase_ = 0;
        consent_ = null;
      }
    }

    public static final int ARC_PLAY_TERMS_OF_SERVICE_CONSENT_FIELD_NUMBER = 10;
    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     */
    @java.lang.Override
    public boolean hasArcPlayTermsOfServiceConsent() {
      return consentCase_ == 10;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent getArcPlayTermsOfServiceConsent() {
      if (consentCase_ == 10) {
         return (org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent) consent_;
      }
      return org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent.getDefaultInstance();
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     */
    private void setArcPlayTermsOfServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent value) {
      value.getClass();
  consent_ = value;
      consentCase_ = 10;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     */
    private void mergeArcPlayTermsOfServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent value) {
      value.getClass();
  if (consentCase_ == 10 &&
          consent_ != org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent.getDefaultInstance()) {
        consent_ = org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent.newBuilder((org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent) consent_)
            .mergeFrom(value).buildPartial();
      } else {
        consent_ = value;
      }
      consentCase_ = 10;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
     */
    private void clearArcPlayTermsOfServiceConsent() {
      if (consentCase_ == 10) {
        consentCase_ = 0;
        consent_ = null;
      }
    }

    public static final int UNIFIED_CONSENT_FIELD_NUMBER = 13;
    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     */
    @java.lang.Override
    public boolean hasUnifiedConsent() {
      return consentCase_ == 13;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent getUnifiedConsent() {
      if (consentCase_ == 13) {
         return (org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent) consent_;
      }
      return org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent.getDefaultInstance();
    }
    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     */
    private void setUnifiedConsent(org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent value) {
      value.getClass();
  consent_ = value;
      consentCase_ = 13;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     */
    private void mergeUnifiedConsent(org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent value) {
      value.getClass();
  if (consentCase_ == 13 &&
          consent_ != org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent.getDefaultInstance()) {
        consent_ = org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent.newBuilder((org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent) consent_)
            .mergeFrom(value).buildPartial();
      } else {
        consent_ = value;
      }
      consentCase_ = 13;
    }
    /**
     * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
     */
    private void clearUnifiedConsent() {
      if (consentCase_ == 13) {
        consentCase_ = 0;
        consent_ = null;
      }
    }

    public static final int FEATURE_FIELD_NUMBER = 1;
    private int feature_;
    /**
     * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
     * @return Whether the feature field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasFeature() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
     * @return The feature.
     */
    @java.lang.Override
    @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature getFeature() {
      org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature result = org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature.forNumber(feature_);
      return result == null ? org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature.FEATURE_UNSPECIFIED : result;
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
     * @param value The feature to set.
     */
    private void setFeature(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature value) {
      feature_ = value.getNumber();
      bitField0_ |= 0x00000080;
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
     */
    private void clearFeature() {
      bitField0_ = (bitField0_ & ~0x00000080);
      feature_ = 0;
    }

    public static final int DESCRIPTION_GRD_IDS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.IntList descriptionGrdIds_;
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @return A list containing the descriptionGrdIds.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.util.List<java.lang.Integer>
        getDescriptionGrdIdsList() {
      return descriptionGrdIds_;
    }
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @return The count of descriptionGrdIds.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getDescriptionGrdIdsCount() {
      return descriptionGrdIds_.size();
    }
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @param index The index of the element to return.
     * @return The descriptionGrdIds at the given index.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getDescriptionGrdIds(int index) {
      return descriptionGrdIds_.getInt(index);
    }
    private void ensureDescriptionGrdIdsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = descriptionGrdIds_;
      if (!tmp.isModifiable()) {
        descriptionGrdIds_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @param index The index to set the value at.
     * @param value The descriptionGrdIds to set.
     */
    private void setDescriptionGrdIds(
        int index, int value) {
      ensureDescriptionGrdIdsIsMutable();
      descriptionGrdIds_.setInt(index, value);
    }
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @param value The descriptionGrdIds to add.
     */
    private void addDescriptionGrdIds(int value) {
      ensureDescriptionGrdIdsIsMutable();
      descriptionGrdIds_.addInt(value);
    }
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     * @param values The descriptionGrdIds to add.
     */
    private void addAllDescriptionGrdIds(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureDescriptionGrdIdsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, descriptionGrdIds_);
    }
    /**
     * <pre>
     * Ids of the strings of the consent text presented to the user.
     * </pre>
     *
     * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
     */
    private void clearDescriptionGrdIds() {
      descriptionGrdIds_ = emptyIntList();
    }

    public static final int CONFIRMATION_GRD_ID_FIELD_NUMBER = 3;
    private int confirmationGrdId_;
    /**
     * <pre>
     * Id of the string of the UI element the user clicked when consenting.
     * </pre>
     *
     * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
     * @return Whether the confirmationGrdId field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasConfirmationGrdId() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Id of the string of the UI element the user clicked when consenting.
     * </pre>
     *
     * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
     * @return The confirmationGrdId.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getConfirmationGrdId() {
      return confirmationGrdId_;
    }
    /**
     * <pre>
     * Id of the string of the UI element the user clicked when consenting.
     * </pre>
     *
     * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
     * @param value The confirmationGrdId to set.
     */
    private void setConfirmationGrdId(int value) {
      bitField0_ |= 0x00000100;
      confirmationGrdId_ = value;
    }
    /**
     * <pre>
     * Id of the string of the UI element the user clicked when consenting.
     * </pre>
     *
     * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
     */
    private void clearConfirmationGrdId() {
      bitField0_ = (bitField0_ & ~0x00000100);
      confirmationGrdId_ = 0;
    }

    public static final int STATUS_FIELD_NUMBER = 5;
    private int status_;
    /**
     * <pre>
     * Was the consent for |feature| given or not given (denied/revoked)?
     * </pre>
     *
     * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasStatus() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Was the consent for |feature| given or not given (denied/revoked)?
     * </pre>
     *
     * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
     * @return The status.
     */
    @java.lang.Override
    @java.lang.Deprecated public org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus getStatus() {
      org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus result = org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus.forNumber(status_);
      return result == null ? org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus.CONSENT_STATUS_UNSPECIFIED : result;
    }
    /**
     * <pre>
     * Was the consent for |feature| given or not given (denied/revoked)?
     * </pre>
     *
     * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
     * @param value The status to set.
     */
    private void setStatus(org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus value) {
      status_ = value.getNumber();
      bitField0_ |= 0x00000200;
    }
    /**
     * <pre>
     * Was the consent for |feature| given or not given (denied/revoked)?
     * </pre>
     *
     * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
     */
    private void clearStatus() {
      bitField0_ = (bitField0_ & ~0x00000200);
      status_ = 0;
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * User consented to the usage of a feature or denied/revoked a consent.
     * This is not used anymore; consents were migrated to a separate data type.
     * The message has to stay though since the server must keep supporting legacy
     * consent formats like this.
     * Next id: 14
     * </pre>
     *
     * Protobuf type {@code sync_pb.UserEventSpecifics.UserConsent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent, Builder> implements
        // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.UserConsent)
        org.chromium.components.sync.protocol.UserEventSpecifics.UserConsentOrBuilder {
      // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public ConsentCase
          getConsentCase() {
        return instance.getConsentCase();
      }

      public Builder clearConsent() {
        copyOnWrite();
        instance.clearConsent();
        return this;
      }


      /**
       * <pre>
       * The UI language Chrome is using, represented as the IETF language tag
       * defined in BCP 47. The region subtag is not included when it adds no
       * distinguishing information to the language tag (e.g. both "en-US"
       * and "fr" are correct here).
       * </pre>
       *
       * <code>optional string locale = 4;</code>
       * @return Whether the locale field is set.
       */
      @java.lang.Override
      public boolean hasLocale() {
        return instance.hasLocale();
      }
      /**
       * <pre>
       * The UI language Chrome is using, represented as the IETF language tag
       * defined in BCP 47. The region subtag is not included when it adds no
       * distinguishing information to the language tag (e.g. both "en-US"
       * and "fr" are correct here).
       * </pre>
       *
       * <code>optional string locale = 4;</code>
       * @return The locale.
       */
      @java.lang.Override
      public java.lang.String getLocale() {
        return instance.getLocale();
      }
      /**
       * <pre>
       * The UI language Chrome is using, represented as the IETF language tag
       * defined in BCP 47. The region subtag is not included when it adds no
       * distinguishing information to the language tag (e.g. both "en-US"
       * and "fr" are correct here).
       * </pre>
       *
       * <code>optional string locale = 4;</code>
       * @return The bytes for locale.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLocaleBytes() {
        return instance.getLocaleBytes();
      }
      /**
       * <pre>
       * The UI language Chrome is using, represented as the IETF language tag
       * defined in BCP 47. The region subtag is not included when it adds no
       * distinguishing information to the language tag (e.g. both "en-US"
       * and "fr" are correct here).
       * </pre>
       *
       * <code>optional string locale = 4;</code>
       * @param value The locale to set.
       * @return This builder for chaining.
       */
      public Builder setLocale(
          java.lang.String value) {
        copyOnWrite();
        instance.setLocale(value);
        return this;
      }
      /**
       * <pre>
       * The UI language Chrome is using, represented as the IETF language tag
       * defined in BCP 47. The region subtag is not included when it adds no
       * distinguishing information to the language tag (e.g. both "en-US"
       * and "fr" are correct here).
       * </pre>
       *
       * <code>optional string locale = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocale() {
        copyOnWrite();
        instance.clearLocale();
        return this;
      }
      /**
       * <pre>
       * The UI language Chrome is using, represented as the IETF language tag
       * defined in BCP 47. The region subtag is not included when it adds no
       * distinguishing information to the language tag (e.g. both "en-US"
       * and "fr" are correct here).
       * </pre>
       *
       * <code>optional string locale = 4;</code>
       * @param value The bytes for locale to set.
       * @return This builder for chaining.
       */
      public Builder setLocaleBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLocaleBytes(value);
        return this;
      }

      /**
       * <pre>
       * The local time on the client when the user consent was recorded. The time
       * as measured by client is given in microseconds since Windows epoch. This
       * is needed since user consent recording may happen when a client is
       * offline.
       * </pre>
       *
       * <code>optional int64 client_consent_time_usec = 12;</code>
       * @return Whether the clientConsentTimeUsec field is set.
       */
      @java.lang.Override
      public boolean hasClientConsentTimeUsec() {
        return instance.hasClientConsentTimeUsec();
      }
      /**
       * <pre>
       * The local time on the client when the user consent was recorded. The time
       * as measured by client is given in microseconds since Windows epoch. This
       * is needed since user consent recording may happen when a client is
       * offline.
       * </pre>
       *
       * <code>optional int64 client_consent_time_usec = 12;</code>
       * @return The clientConsentTimeUsec.
       */
      @java.lang.Override
      public long getClientConsentTimeUsec() {
        return instance.getClientConsentTimeUsec();
      }
      /**
       * <pre>
       * The local time on the client when the user consent was recorded. The time
       * as measured by client is given in microseconds since Windows epoch. This
       * is needed since user consent recording may happen when a client is
       * offline.
       * </pre>
       *
       * <code>optional int64 client_consent_time_usec = 12;</code>
       * @param value The clientConsentTimeUsec to set.
       * @return This builder for chaining.
       */
      public Builder setClientConsentTimeUsec(long value) {
        copyOnWrite();
        instance.setClientConsentTimeUsec(value);
        return this;
      }
      /**
       * <pre>
       * The local time on the client when the user consent was recorded. The time
       * as measured by client is given in microseconds since Windows epoch. This
       * is needed since user consent recording may happen when a client is
       * offline.
       * </pre>
       *
       * <code>optional int64 client_consent_time_usec = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientConsentTimeUsec() {
        copyOnWrite();
        instance.clearClientConsentTimeUsec();
        return this;
      }

      /**
       * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
       */
      @java.lang.Override
      public boolean hasSyncConsent() {
        return instance.hasSyncConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent getSyncConsent() {
        return instance.getSyncConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
       */
      public Builder setSyncConsent(org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent value) {
        copyOnWrite();
        instance.setSyncConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
       */
      public Builder setSyncConsent(
          org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent.Builder builderForValue) {
        copyOnWrite();
        instance.setSyncConsent(builderForValue.build());
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
       */
      public Builder mergeSyncConsent(org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent value) {
        copyOnWrite();
        instance.mergeSyncConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.SyncConsent sync_consent = 7;</code>
       */
      public Builder clearSyncConsent() {
        copyOnWrite();
        instance.clearSyncConsent();
        return this;
      }

      /**
       * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
       */
      @java.lang.Override
      public boolean hasArcBackupAndRestoreConsent() {
        return instance.hasArcBackupAndRestoreConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent getArcBackupAndRestoreConsent() {
        return instance.getArcBackupAndRestoreConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
       */
      public Builder setArcBackupAndRestoreConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent value) {
        copyOnWrite();
        instance.setArcBackupAndRestoreConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
       */
      public Builder setArcBackupAndRestoreConsent(
          org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent.Builder builderForValue) {
        copyOnWrite();
        instance.setArcBackupAndRestoreConsent(builderForValue.build());
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
       */
      public Builder mergeArcBackupAndRestoreConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent value) {
        copyOnWrite();
        instance.mergeArcBackupAndRestoreConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent arc_backup_and_restore_consent = 8;</code>
       */
      public Builder clearArcBackupAndRestoreConsent() {
        copyOnWrite();
        instance.clearArcBackupAndRestoreConsent();
        return this;
      }

      /**
       * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
       */
      @java.lang.Override
      public boolean hasArcLocationServiceConsent() {
        return instance.hasArcLocationServiceConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent getArcLocationServiceConsent() {
        return instance.getArcLocationServiceConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
       */
      public Builder setArcLocationServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent value) {
        copyOnWrite();
        instance.setArcLocationServiceConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
       */
      public Builder setArcLocationServiceConsent(
          org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent.Builder builderForValue) {
        copyOnWrite();
        instance.setArcLocationServiceConsent(builderForValue.build());
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
       */
      public Builder mergeArcLocationServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent value) {
        copyOnWrite();
        instance.mergeArcLocationServiceConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent arc_location_service_consent = 9;</code>
       */
      public Builder clearArcLocationServiceConsent() {
        copyOnWrite();
        instance.clearArcLocationServiceConsent();
        return this;
      }

      /**
       * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
       */
      @java.lang.Override
      public boolean hasArcPlayTermsOfServiceConsent() {
        return instance.hasArcPlayTermsOfServiceConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent getArcPlayTermsOfServiceConsent() {
        return instance.getArcPlayTermsOfServiceConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
       */
      public Builder setArcPlayTermsOfServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent value) {
        copyOnWrite();
        instance.setArcPlayTermsOfServiceConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
       */
      public Builder setArcPlayTermsOfServiceConsent(
          org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent.Builder builderForValue) {
        copyOnWrite();
        instance.setArcPlayTermsOfServiceConsent(builderForValue.build());
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
       */
      public Builder mergeArcPlayTermsOfServiceConsent(org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent value) {
        copyOnWrite();
        instance.mergeArcPlayTermsOfServiceConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent arc_play_terms_of_service_consent = 10;</code>
       */
      public Builder clearArcPlayTermsOfServiceConsent() {
        copyOnWrite();
        instance.clearArcPlayTermsOfServiceConsent();
        return this;
      }

      /**
       * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
       */
      @java.lang.Override
      public boolean hasUnifiedConsent() {
        return instance.hasUnifiedConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent getUnifiedConsent() {
        return instance.getUnifiedConsent();
      }
      /**
       * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
       */
      public Builder setUnifiedConsent(org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent value) {
        copyOnWrite();
        instance.setUnifiedConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
       */
      public Builder setUnifiedConsent(
          org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent.Builder builderForValue) {
        copyOnWrite();
        instance.setUnifiedConsent(builderForValue.build());
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
       */
      public Builder mergeUnifiedConsent(org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent value) {
        copyOnWrite();
        instance.mergeUnifiedConsent(value);
        return this;
      }
      /**
       * <code>.sync_pb.UserConsentTypes.UnifiedConsent unified_consent = 13;</code>
       */
      public Builder clearUnifiedConsent() {
        copyOnWrite();
        instance.clearUnifiedConsent();
        return this;
      }

      /**
       * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
       * @return Whether the feature field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasFeature() {
        return instance.hasFeature();
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
       * @return The feature.
       */
      @java.lang.Override
      @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature getFeature() {
        return instance.getFeature();
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
       * @param value The enum numeric value on the wire for feature to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setFeature(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature value) {
        copyOnWrite();
        instance.setFeature(value);
        return this;
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.UserConsent.Feature feature = 1 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearFeature() {
        copyOnWrite();
        instance.clearFeature();
        return this;
      }

      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @return A list containing the descriptionGrdIds.
       */
      @java.lang.Override
      @java.lang.Deprecated public java.util.List<java.lang.Integer>
          getDescriptionGrdIdsList() {
        return java.util.Collections.unmodifiableList(
            instance.getDescriptionGrdIdsList());
      }
      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @return The count of descriptionGrdIds.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getDescriptionGrdIdsCount() {
        return instance.getDescriptionGrdIdsCount();
      }
      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @param index The index of the element to return.
       * @return The descriptionGrdIds at the given index.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getDescriptionGrdIds(int index) {
        return instance.getDescriptionGrdIds(index);
      }
      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @param value The descriptionGrdIds to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setDescriptionGrdIds(
          int index, int value) {
        copyOnWrite();
        instance.setDescriptionGrdIds(index, value);
        return this;
      }
      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @param value The descriptionGrdIds to add.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder addDescriptionGrdIds(int value) {
        copyOnWrite();
        instance.addDescriptionGrdIds(value);
        return this;
      }
      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @param values The descriptionGrdIds to add.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder addAllDescriptionGrdIds(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllDescriptionGrdIds(values);
        return this;
      }
      /**
       * <pre>
       * Ids of the strings of the consent text presented to the user.
       * </pre>
       *
       * <code>repeated int32 description_grd_ids = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearDescriptionGrdIds() {
        copyOnWrite();
        instance.clearDescriptionGrdIds();
        return this;
      }

      /**
       * <pre>
       * Id of the string of the UI element the user clicked when consenting.
       * </pre>
       *
       * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
       * @return Whether the confirmationGrdId field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasConfirmationGrdId() {
        return instance.hasConfirmationGrdId();
      }
      /**
       * <pre>
       * Id of the string of the UI element the user clicked when consenting.
       * </pre>
       *
       * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
       * @return The confirmationGrdId.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getConfirmationGrdId() {
        return instance.getConfirmationGrdId();
      }
      /**
       * <pre>
       * Id of the string of the UI element the user clicked when consenting.
       * </pre>
       *
       * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
       * @param value The confirmationGrdId to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setConfirmationGrdId(int value) {
        copyOnWrite();
        instance.setConfirmationGrdId(value);
        return this;
      }
      /**
       * <pre>
       * Id of the string of the UI element the user clicked when consenting.
       * </pre>
       *
       * <code>optional int32 confirmation_grd_id = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearConfirmationGrdId() {
        copyOnWrite();
        instance.clearConfirmationGrdId();
        return this;
      }

      /**
       * <pre>
       * Was the consent for |feature| given or not given (denied/revoked)?
       * </pre>
       *
       * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
       * @return Whether the status field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasStatus() {
        return instance.hasStatus();
      }
      /**
       * <pre>
       * Was the consent for |feature| given or not given (denied/revoked)?
       * </pre>
       *
       * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
       * @return The status.
       */
      @java.lang.Override
      @java.lang.Deprecated public org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus getStatus() {
        return instance.getStatus();
      }
      /**
       * <pre>
       * Was the consent for |feature| given or not given (denied/revoked)?
       * </pre>
       *
       * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setStatus(org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus value) {
        copyOnWrite();
        instance.setStatus(value);
        return this;
      }
      /**
       * <pre>
       * Was the consent for |feature| given or not given (denied/revoked)?
       * </pre>
       *
       * <code>optional .sync_pb.UserConsentTypes.ConsentStatus status = 5 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearStatus() {
        copyOnWrite();
        instance.clearStatus();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.UserConsent)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "consent_",
              "consentCase_",
              "bitField0_",
              "feature_",
              org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Feature.internalGetVerifier(),
              "descriptionGrdIds_",
              "confirmationGrdId_",
              "locale_",
              "status_",
              org.chromium.components.sync.protocol.UserConsentTypes.ConsentStatus.internalGetVerifier(),
              org.chromium.components.sync.protocol.UserConsentTypes.SyncConsent.class,
              org.chromium.components.sync.protocol.UserConsentTypes.ArcBackupAndRestoreConsent.class,
              org.chromium.components.sync.protocol.UserConsentTypes.ArcGoogleLocationServiceConsent.class,
              org.chromium.components.sync.protocol.UserConsentTypes.ArcPlayTermsOfServiceConsent.class,
              "clientConsentTimeUsec_",
              org.chromium.components.sync.protocol.UserConsentTypes.UnifiedConsent.class,
            };
            java.lang.String info =
                "\u0001\u000b\u0001\u0001\u0001\r\u000b\u0000\u0001\u0000\u0001\u100c\u0007\u0002" +
                "\u0016\u0003\u1004\b\u0004\u1008\u0000\u0005\u100c\t\u0007\u103c\u0000\b\u103c\u0000" +
                "\t\u103c\u0000\n\u103c\u0000\f\u1002\u0001\r\u103c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.UserConsent)
    private static final org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent DEFAULT_INSTANCE;
    static {
      UserConsent defaultInstance = new UserConsent();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        UserConsent.class, defaultInstance);
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<UserConsent> PARSER;

    public static com.google.protobuf.Parser<UserConsent> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GaiaPasswordCapturedOrBuilder extends
      // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
     * @return Whether the eventTrigger field is set.
     */
    boolean hasEventTrigger();
    /**
     * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
     * @return The eventTrigger.
     */
    org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger getEventTrigger();
  }
  /**
   * <pre>
   * Logged when the user logs into Google, and at least once per 28d.
   * </pre>
   *
   * Protobuf type {@code sync_pb.UserEventSpecifics.GaiaPasswordCaptured}
   */
  public  static final class GaiaPasswordCaptured extends
      com.google.protobuf.GeneratedMessageLite<
          GaiaPasswordCaptured, GaiaPasswordCaptured.Builder> implements
      // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
      GaiaPasswordCapturedOrBuilder {
    private GaiaPasswordCaptured() {
    }
    /**
     * Protobuf enum {@code sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger}
     */
    public enum EventTrigger
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNSPECIFIED = 0;</code>
       */
      UNSPECIFIED(0),
      /**
       * <pre>
       * Event added because user logged in.
       * </pre>
       *
       * <code>USER_LOGGED_IN = 1;</code>
       */
      USER_LOGGED_IN(1),
      /**
       * <pre>
       * Event added because 28d timer fired.
       * </pre>
       *
       * <code>EXPIRED_28D_TIMER = 2;</code>
       */
      EXPIRED_28D_TIMER(2),
      ;

      /**
       * <code>UNSPECIFIED = 0;</code>
       */
      public static final int UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * Event added because user logged in.
       * </pre>
       *
       * <code>USER_LOGGED_IN = 1;</code>
       */
      public static final int USER_LOGGED_IN_VALUE = 1;
      /**
       * <pre>
       * Event added because 28d timer fired.
       * </pre>
       *
       * <code>EXPIRED_28D_TIMER = 2;</code>
       */
      public static final int EXPIRED_28D_TIMER_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EventTrigger valueOf(int value) {
        return forNumber(value);
      }

      public static EventTrigger forNumber(int value) {
        switch (value) {
          case 0: return UNSPECIFIED;
          case 1: return USER_LOGGED_IN;
          case 2: return EXPIRED_28D_TIMER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<EventTrigger>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          EventTrigger> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EventTrigger>() {
              @java.lang.Override
              public EventTrigger findValueByNumber(int number) {
                return EventTrigger.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return EventTriggerVerifier.INSTANCE;
      }

      private static final class EventTriggerVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new EventTriggerVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return EventTrigger.forNumber(number) != null;
              }
            };

      private final int value;

      private EventTrigger(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger)
    }

    private int bitField0_;
    public static final int EVENT_TRIGGER_FIELD_NUMBER = 1;
    private int eventTrigger_;
    /**
     * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
     * @return Whether the eventTrigger field is set.
     */
    @java.lang.Override
    public boolean hasEventTrigger() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
     * @return The eventTrigger.
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger getEventTrigger() {
      org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger result = org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger.forNumber(eventTrigger_);
      return result == null ? org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger.UNSPECIFIED : result;
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
     * @param value The eventTrigger to set.
     */
    private void setEventTrigger(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger value) {
      eventTrigger_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
     */
    private void clearEventTrigger() {
      bitField0_ = (bitField0_ & ~0x00000001);
      eventTrigger_ = 0;
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Logged when the user logs into Google, and at least once per 28d.
     * </pre>
     *
     * Protobuf type {@code sync_pb.UserEventSpecifics.GaiaPasswordCaptured}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured, Builder> implements
        // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
        org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCapturedOrBuilder {
      // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
       * @return Whether the eventTrigger field is set.
       */
      @java.lang.Override
      public boolean hasEventTrigger() {
        return instance.hasEventTrigger();
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
       * @return The eventTrigger.
       */
      @java.lang.Override
      public org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger getEventTrigger() {
        return instance.getEventTrigger();
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
       * @param value The enum numeric value on the wire for eventTrigger to set.
       * @return This builder for chaining.
       */
      public Builder setEventTrigger(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger value) {
        copyOnWrite();
        instance.setEventTrigger(value);
        return this;
      }
      /**
       * <code>optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearEventTrigger() {
        copyOnWrite();
        instance.clearEventTrigger();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "eventTrigger_",
              org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u100c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    private static final org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured DEFAULT_INSTANCE;
    static {
      GaiaPasswordCaptured defaultInstance = new GaiaPasswordCaptured();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GaiaPasswordCaptured.class, defaultInstance);
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GaiaPasswordCaptured> PARSER;

    public static com.google.protobuf.Parser<GaiaPasswordCaptured> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FlocIdComputedOrBuilder extends
      // @@protoc_insertion_point(interface_extends:sync_pb.UserEventSpecifics.FlocIdComputed)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * If not set, it means that the floc is disabled.
     * </pre>
     *
     * <code>optional uint64 floc_id = 2;</code>
     * @return Whether the flocId field is set.
     */
    boolean hasFlocId();
    /**
     * <pre>
     * If not set, it means that the floc is disabled.
     * </pre>
     *
     * <code>optional uint64 floc_id = 2;</code>
     * @return The flocId.
     */
    long getFlocId();
  }
  /**
   * Protobuf type {@code sync_pb.UserEventSpecifics.FlocIdComputed}
   */
  public  static final class FlocIdComputed extends
      com.google.protobuf.GeneratedMessageLite<
          FlocIdComputed, FlocIdComputed.Builder> implements
      // @@protoc_insertion_point(message_implements:sync_pb.UserEventSpecifics.FlocIdComputed)
      FlocIdComputedOrBuilder {
    private FlocIdComputed() {
    }
    /**
     * Protobuf enum {@code sync_pb.UserEventSpecifics.FlocIdComputed.EventTrigger}
     */
    public enum EventTrigger
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNSPECIFIED = 0;</code>
       */
      UNSPECIFIED(0),
      /**
       * <pre>
       * Event added because the floc id is computed for the 1st floc session.
       * </pre>
       *
       * <code>NEW = 1;</code>
       */
      NEW(1),
      /**
       * <pre>
       * Event added because the floc id is re-computed due to a long period of
       * time has passed since the last computation.
       * </pre>
       *
       * <code>REFRESHED = 2;</code>
       */
      REFRESHED(2),
      /**
       * <pre>
       * Event added because the floc id is re-computed due to history deletion.
       * </pre>
       *
       * <code>HISTORY_DELETE = 3;</code>
       */
      HISTORY_DELETE(3),
      ;

      /**
       * <code>UNSPECIFIED = 0;</code>
       */
      public static final int UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * Event added because the floc id is computed for the 1st floc session.
       * </pre>
       *
       * <code>NEW = 1;</code>
       */
      public static final int NEW_VALUE = 1;
      /**
       * <pre>
       * Event added because the floc id is re-computed due to a long period of
       * time has passed since the last computation.
       * </pre>
       *
       * <code>REFRESHED = 2;</code>
       */
      public static final int REFRESHED_VALUE = 2;
      /**
       * <pre>
       * Event added because the floc id is re-computed due to history deletion.
       * </pre>
       *
       * <code>HISTORY_DELETE = 3;</code>
       */
      public static final int HISTORY_DELETE_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EventTrigger valueOf(int value) {
        return forNumber(value);
      }

      public static EventTrigger forNumber(int value) {
        switch (value) {
          case 0: return UNSPECIFIED;
          case 1: return NEW;
          case 2: return REFRESHED;
          case 3: return HISTORY_DELETE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<EventTrigger>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          EventTrigger> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EventTrigger>() {
              @java.lang.Override
              public EventTrigger findValueByNumber(int number) {
                return EventTrigger.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return EventTriggerVerifier.INSTANCE;
      }

      private static final class EventTriggerVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new EventTriggerVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return EventTrigger.forNumber(number) != null;
              }
            };

      private final int value;

      private EventTrigger(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:sync_pb.UserEventSpecifics.FlocIdComputed.EventTrigger)
    }

    private int bitField0_;
    public static final int FLOC_ID_FIELD_NUMBER = 2;
    private long flocId_;
    /**
     * <pre>
     * If not set, it means that the floc is disabled.
     * </pre>
     *
     * <code>optional uint64 floc_id = 2;</code>
     * @return Whether the flocId field is set.
     */
    @java.lang.Override
    public boolean hasFlocId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If not set, it means that the floc is disabled.
     * </pre>
     *
     * <code>optional uint64 floc_id = 2;</code>
     * @return The flocId.
     */
    @java.lang.Override
    public long getFlocId() {
      return flocId_;
    }
    /**
     * <pre>
     * If not set, it means that the floc is disabled.
     * </pre>
     *
     * <code>optional uint64 floc_id = 2;</code>
     * @param value The flocId to set.
     */
    private void setFlocId(long value) {
      bitField0_ |= 0x00000001;
      flocId_ = value;
    }
    /**
     * <pre>
     * If not set, it means that the floc is disabled.
     * </pre>
     *
     * <code>optional uint64 floc_id = 2;</code>
     */
    private void clearFlocId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      flocId_ = 0L;
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code sync_pb.UserEventSpecifics.FlocIdComputed}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed, Builder> implements
        // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics.FlocIdComputed)
        org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputedOrBuilder {
      // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * If not set, it means that the floc is disabled.
       * </pre>
       *
       * <code>optional uint64 floc_id = 2;</code>
       * @return Whether the flocId field is set.
       */
      @java.lang.Override
      public boolean hasFlocId() {
        return instance.hasFlocId();
      }
      /**
       * <pre>
       * If not set, it means that the floc is disabled.
       * </pre>
       *
       * <code>optional uint64 floc_id = 2;</code>
       * @return The flocId.
       */
      @java.lang.Override
      public long getFlocId() {
        return instance.getFlocId();
      }
      /**
       * <pre>
       * If not set, it means that the floc is disabled.
       * </pre>
       *
       * <code>optional uint64 floc_id = 2;</code>
       * @param value The flocId to set.
       * @return This builder for chaining.
       */
      public Builder setFlocId(long value) {
        copyOnWrite();
        instance.setFlocId(value);
        return this;
      }
      /**
       * <pre>
       * If not set, it means that the floc is disabled.
       * </pre>
       *
       * <code>optional uint64 floc_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlocId() {
        copyOnWrite();
        instance.clearFlocId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics.FlocIdComputed)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "flocId_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0002\u0002\u0001\u0000\u0000\u0000\u0002\u1003\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics.FlocIdComputed)
    private static final org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed DEFAULT_INSTANCE;
    static {
      FlocIdComputed defaultInstance = new FlocIdComputed();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FlocIdComputed.class, defaultInstance);
    }

    public static org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FlocIdComputed> PARSER;

    public static com.google.protobuf.Parser<FlocIdComputed> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  private int bitField0_;
  private int eventCase_ = 0;
  private java.lang.Object event_;
  public enum EventCase {
    TEST_EVENT(8),
    LANGUAGE_DETECTION_EVENT(10),
    TRANSLATION_EVENT(11),
    USER_CONSENT(12),
    GAIA_PASSWORD_REUSE_EVENT(104),
    GAIA_PASSWORD_CAPTURED_EVENT(15),
    FLOC_ID_COMPUTED_EVENT(16),
    EVENT_NOT_SET(0);
    private final int value;
    private EventCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static EventCase valueOf(int value) {
      return forNumber(value);
    }

    public static EventCase forNumber(int value) {
      switch (value) {
        case 8: return TEST_EVENT;
        case 10: return LANGUAGE_DETECTION_EVENT;
        case 11: return TRANSLATION_EVENT;
        case 12: return USER_CONSENT;
        case 104: return GAIA_PASSWORD_REUSE_EVENT;
        case 15: return GAIA_PASSWORD_CAPTURED_EVENT;
        case 16: return FLOC_ID_COMPUTED_EVENT;
        case 0: return EVENT_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  @java.lang.Override
  public EventCase
  getEventCase() {
    return EventCase.forNumber(
        eventCase_);
  }

  private void clearEvent() {
    eventCase_ = 0;
    event_ = null;
  }

  public static final int EVENT_TIME_USEC_FIELD_NUMBER = 1;
  private long eventTimeUsec_;
  /**
   * <pre>
   * Time of event, as measured by client in microseconds since Windows epoch.
   * </pre>
   *
   * <code>optional int64 event_time_usec = 1;</code>
   * @return Whether the eventTimeUsec field is set.
   */
  @java.lang.Override
  public boolean hasEventTimeUsec() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * Time of event, as measured by client in microseconds since Windows epoch.
   * </pre>
   *
   * <code>optional int64 event_time_usec = 1;</code>
   * @return The eventTimeUsec.
   */
  @java.lang.Override
  public long getEventTimeUsec() {
    return eventTimeUsec_;
  }
  /**
   * <pre>
   * Time of event, as measured by client in microseconds since Windows epoch.
   * </pre>
   *
   * <code>optional int64 event_time_usec = 1;</code>
   * @param value The eventTimeUsec to set.
   */
  private void setEventTimeUsec(long value) {
    bitField0_ |= 0x00000001;
    eventTimeUsec_ = value;
  }
  /**
   * <pre>
   * Time of event, as measured by client in microseconds since Windows epoch.
   * </pre>
   *
   * <code>optional int64 event_time_usec = 1;</code>
   */
  private void clearEventTimeUsec() {
    bitField0_ = (bitField0_ & ~0x00000001);
    eventTimeUsec_ = 0L;
  }

  public static final int NAVIGATION_ID_FIELD_NUMBER = 2;
  private long navigationId_;
  /**
   * <pre>
   * The |global_id| field of the associated navigation, if there is one.
   * </pre>
   *
   * <code>optional int64 navigation_id = 2;</code>
   * @return Whether the navigationId field is set.
   */
  @java.lang.Override
  public boolean hasNavigationId() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * The |global_id| field of the associated navigation, if there is one.
   * </pre>
   *
   * <code>optional int64 navigation_id = 2;</code>
   * @return The navigationId.
   */
  @java.lang.Override
  public long getNavigationId() {
    return navigationId_;
  }
  /**
   * <pre>
   * The |global_id| field of the associated navigation, if there is one.
   * </pre>
   *
   * <code>optional int64 navigation_id = 2;</code>
   * @param value The navigationId to set.
   */
  private void setNavigationId(long value) {
    bitField0_ |= 0x00000002;
    navigationId_ = value;
  }
  /**
   * <pre>
   * The |global_id| field of the associated navigation, if there is one.
   * </pre>
   *
   * <code>optional int64 navigation_id = 2;</code>
   */
  private void clearNavigationId() {
    bitField0_ = (bitField0_ & ~0x00000002);
    navigationId_ = 0L;
  }

  public static final int SESSION_ID_FIELD_NUMBER = 3;
  private long sessionId_;
  /**
   * <pre>
   * On startup we generate a new random id to identify which FieldTrialEvents
   * other events belonged to.
   * </pre>
   *
   * <code>optional fixed64 session_id = 3;</code>
   * @return Whether the sessionId field is set.
   */
  @java.lang.Override
  public boolean hasSessionId() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * On startup we generate a new random id to identify which FieldTrialEvents
   * other events belonged to.
   * </pre>
   *
   * <code>optional fixed64 session_id = 3;</code>
   * @return The sessionId.
   */
  @java.lang.Override
  public long getSessionId() {
    return sessionId_;
  }
  /**
   * <pre>
   * On startup we generate a new random id to identify which FieldTrialEvents
   * other events belonged to.
   * </pre>
   *
   * <code>optional fixed64 session_id = 3;</code>
   * @param value The sessionId to set.
   */
  private void setSessionId(long value) {
    bitField0_ |= 0x00000004;
    sessionId_ = value;
  }
  /**
   * <pre>
   * On startup we generate a new random id to identify which FieldTrialEvents
   * other events belonged to.
   * </pre>
   *
   * <code>optional fixed64 session_id = 3;</code>
   */
  private void clearSessionId() {
    bitField0_ = (bitField0_ & ~0x00000004);
    sessionId_ = 0L;
  }

  public static final int TEST_EVENT_FIELD_NUMBER = 8;
  /**
   * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
   */
  @java.lang.Override
  public boolean hasTestEvent() {
    return eventCase_ == 8;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.UserEventSpecifics.Test getTestEvent() {
    if (eventCase_ == 8) {
       return (org.chromium.components.sync.protocol.UserEventSpecifics.Test) event_;
    }
    return org.chromium.components.sync.protocol.UserEventSpecifics.Test.getDefaultInstance();
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
   */
  private void setTestEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Test value) {
    value.getClass();
  event_ = value;
    eventCase_ = 8;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
   */
  private void mergeTestEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Test value) {
    value.getClass();
  if (eventCase_ == 8 &&
        event_ != org.chromium.components.sync.protocol.UserEventSpecifics.Test.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.UserEventSpecifics.Test.newBuilder((org.chromium.components.sync.protocol.UserEventSpecifics.Test) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 8;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
   */
  private void clearTestEvent() {
    if (eventCase_ == 8) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static final int LANGUAGE_DETECTION_EVENT_FIELD_NUMBER = 10;
  /**
   * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasLanguageDetectionEvent() {
    return eventCase_ == 10;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection getLanguageDetectionEvent() {
    if (eventCase_ == 10) {
       return (org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection) event_;
    }
    return org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.getDefaultInstance();
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
   */
  private void setLanguageDetectionEvent(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection value) {
    value.getClass();
  event_ = value;
    eventCase_ = 10;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
   */
  private void mergeLanguageDetectionEvent(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection value) {
    value.getClass();
  if (eventCase_ == 10 &&
        event_ != org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.newBuilder((org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 10;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
   */
  private void clearLanguageDetectionEvent() {
    if (eventCase_ == 10) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static final int TRANSLATION_EVENT_FIELD_NUMBER = 11;
  /**
   * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasTranslationEvent() {
    return eventCase_ == 11;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.Translation getTranslationEvent() {
    if (eventCase_ == 11) {
       return (org.chromium.components.sync.protocol.UserEventSpecifics.Translation) event_;
    }
    return org.chromium.components.sync.protocol.UserEventSpecifics.Translation.getDefaultInstance();
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
   */
  private void setTranslationEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Translation value) {
    value.getClass();
  event_ = value;
    eventCase_ = 11;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
   */
  private void mergeTranslationEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Translation value) {
    value.getClass();
  if (eventCase_ == 11 &&
        event_ != org.chromium.components.sync.protocol.UserEventSpecifics.Translation.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.UserEventSpecifics.Translation.newBuilder((org.chromium.components.sync.protocol.UserEventSpecifics.Translation) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 11;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
   */
  private void clearTranslationEvent() {
    if (eventCase_ == 11) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static final int USER_CONSENT_FIELD_NUMBER = 12;
  /**
   * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasUserConsent() {
    return eventCase_ == 12;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent getUserConsent() {
    if (eventCase_ == 12) {
       return (org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent) event_;
    }
    return org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.getDefaultInstance();
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
   */
  private void setUserConsent(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent value) {
    value.getClass();
  event_ = value;
    eventCase_ = 12;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
   */
  private void mergeUserConsent(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent value) {
    value.getClass();
  if (eventCase_ == 12 &&
        event_ != org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.newBuilder((org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 12;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
   */
  private void clearUserConsent() {
    if (eventCase_ == 12) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static final int GAIA_PASSWORD_REUSE_EVENT_FIELD_NUMBER = 104;
  /**
   * <pre>
   * Happens when a user types their Google account password on another site.
   * </pre>
   *
   * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
   */
  @java.lang.Override
  public boolean hasGaiaPasswordReuseEvent() {
    return eventCase_ == 104;
  }
  /**
   * <pre>
   * Happens when a user types their Google account password on another site.
   * </pre>
   *
   * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.GaiaPasswordReuse getGaiaPasswordReuseEvent() {
    if (eventCase_ == 104) {
       return (org.chromium.components.sync.protocol.GaiaPasswordReuse) event_;
    }
    return org.chromium.components.sync.protocol.GaiaPasswordReuse.getDefaultInstance();
  }
  /**
   * <pre>
   * Happens when a user types their Google account password on another site.
   * </pre>
   *
   * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
   */
  private void setGaiaPasswordReuseEvent(org.chromium.components.sync.protocol.GaiaPasswordReuse value) {
    value.getClass();
  event_ = value;
    eventCase_ = 104;
  }
  /**
   * <pre>
   * Happens when a user types their Google account password on another site.
   * </pre>
   *
   * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
   */
  private void mergeGaiaPasswordReuseEvent(org.chromium.components.sync.protocol.GaiaPasswordReuse value) {
    value.getClass();
  if (eventCase_ == 104 &&
        event_ != org.chromium.components.sync.protocol.GaiaPasswordReuse.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.GaiaPasswordReuse.newBuilder((org.chromium.components.sync.protocol.GaiaPasswordReuse) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 104;
  }
  /**
   * <pre>
   * Happens when a user types their Google account password on another site.
   * </pre>
   *
   * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
   */
  private void clearGaiaPasswordReuseEvent() {
    if (eventCase_ == 104) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static final int GAIA_PASSWORD_CAPTURED_EVENT_FIELD_NUMBER = 15;
  /**
   * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
   */
  @java.lang.Override
  public boolean hasGaiaPasswordCapturedEvent() {
    return eventCase_ == 15;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured getGaiaPasswordCapturedEvent() {
    if (eventCase_ == 15) {
       return (org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured) event_;
    }
    return org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.getDefaultInstance();
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
   */
  private void setGaiaPasswordCapturedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured value) {
    value.getClass();
  event_ = value;
    eventCase_ = 15;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
   */
  private void mergeGaiaPasswordCapturedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured value) {
    value.getClass();
  if (eventCase_ == 15 &&
        event_ != org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.newBuilder((org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 15;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
   */
  private void clearGaiaPasswordCapturedEvent() {
    if (eventCase_ == 15) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static final int FLOC_ID_COMPUTED_EVENT_FIELD_NUMBER = 16;
  /**
   * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
   */
  @java.lang.Override
  public boolean hasFlocIdComputedEvent() {
    return eventCase_ == 16;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
   */
  @java.lang.Override
  public org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed getFlocIdComputedEvent() {
    if (eventCase_ == 16) {
       return (org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed) event_;
    }
    return org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.getDefaultInstance();
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
   */
  private void setFlocIdComputedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed value) {
    value.getClass();
  event_ = value;
    eventCase_ = 16;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
   */
  private void mergeFlocIdComputedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed value) {
    value.getClass();
  if (eventCase_ == 16 &&
        event_ != org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.getDefaultInstance()) {
      event_ = org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.newBuilder((org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed) event_)
          .mergeFrom(value).buildPartial();
    } else {
      event_ = value;
    }
    eventCase_ = 16;
  }
  /**
   * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
   */
  private void clearFlocIdComputedEvent() {
    if (eventCase_ == 16) {
      eventCase_ = 0;
      event_ = null;
    }
  }

  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.UserEventSpecifics parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.UserEventSpecifics prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.UserEventSpecifics}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.UserEventSpecifics, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.UserEventSpecifics)
      org.chromium.components.sync.protocol.UserEventSpecificsOrBuilder {
    // Construct using org.chromium.components.sync.protocol.UserEventSpecifics.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }

    @java.lang.Override
    public EventCase
        getEventCase() {
      return instance.getEventCase();
    }

    public Builder clearEvent() {
      copyOnWrite();
      instance.clearEvent();
      return this;
    }


    /**
     * <pre>
     * Time of event, as measured by client in microseconds since Windows epoch.
     * </pre>
     *
     * <code>optional int64 event_time_usec = 1;</code>
     * @return Whether the eventTimeUsec field is set.
     */
    @java.lang.Override
    public boolean hasEventTimeUsec() {
      return instance.hasEventTimeUsec();
    }
    /**
     * <pre>
     * Time of event, as measured by client in microseconds since Windows epoch.
     * </pre>
     *
     * <code>optional int64 event_time_usec = 1;</code>
     * @return The eventTimeUsec.
     */
    @java.lang.Override
    public long getEventTimeUsec() {
      return instance.getEventTimeUsec();
    }
    /**
     * <pre>
     * Time of event, as measured by client in microseconds since Windows epoch.
     * </pre>
     *
     * <code>optional int64 event_time_usec = 1;</code>
     * @param value The eventTimeUsec to set.
     * @return This builder for chaining.
     */
    public Builder setEventTimeUsec(long value) {
      copyOnWrite();
      instance.setEventTimeUsec(value);
      return this;
    }
    /**
     * <pre>
     * Time of event, as measured by client in microseconds since Windows epoch.
     * </pre>
     *
     * <code>optional int64 event_time_usec = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearEventTimeUsec() {
      copyOnWrite();
      instance.clearEventTimeUsec();
      return this;
    }

    /**
     * <pre>
     * The |global_id| field of the associated navigation, if there is one.
     * </pre>
     *
     * <code>optional int64 navigation_id = 2;</code>
     * @return Whether the navigationId field is set.
     */
    @java.lang.Override
    public boolean hasNavigationId() {
      return instance.hasNavigationId();
    }
    /**
     * <pre>
     * The |global_id| field of the associated navigation, if there is one.
     * </pre>
     *
     * <code>optional int64 navigation_id = 2;</code>
     * @return The navigationId.
     */
    @java.lang.Override
    public long getNavigationId() {
      return instance.getNavigationId();
    }
    /**
     * <pre>
     * The |global_id| field of the associated navigation, if there is one.
     * </pre>
     *
     * <code>optional int64 navigation_id = 2;</code>
     * @param value The navigationId to set.
     * @return This builder for chaining.
     */
    public Builder setNavigationId(long value) {
      copyOnWrite();
      instance.setNavigationId(value);
      return this;
    }
    /**
     * <pre>
     * The |global_id| field of the associated navigation, if there is one.
     * </pre>
     *
     * <code>optional int64 navigation_id = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearNavigationId() {
      copyOnWrite();
      instance.clearNavigationId();
      return this;
    }

    /**
     * <pre>
     * On startup we generate a new random id to identify which FieldTrialEvents
     * other events belonged to.
     * </pre>
     *
     * <code>optional fixed64 session_id = 3;</code>
     * @return Whether the sessionId field is set.
     */
    @java.lang.Override
    public boolean hasSessionId() {
      return instance.hasSessionId();
    }
    /**
     * <pre>
     * On startup we generate a new random id to identify which FieldTrialEvents
     * other events belonged to.
     * </pre>
     *
     * <code>optional fixed64 session_id = 3;</code>
     * @return The sessionId.
     */
    @java.lang.Override
    public long getSessionId() {
      return instance.getSessionId();
    }
    /**
     * <pre>
     * On startup we generate a new random id to identify which FieldTrialEvents
     * other events belonged to.
     * </pre>
     *
     * <code>optional fixed64 session_id = 3;</code>
     * @param value The sessionId to set.
     * @return This builder for chaining.
     */
    public Builder setSessionId(long value) {
      copyOnWrite();
      instance.setSessionId(value);
      return this;
    }
    /**
     * <pre>
     * On startup we generate a new random id to identify which FieldTrialEvents
     * other events belonged to.
     * </pre>
     *
     * <code>optional fixed64 session_id = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearSessionId() {
      copyOnWrite();
      instance.clearSessionId();
      return this;
    }

    /**
     * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
     */
    @java.lang.Override
    public boolean hasTestEvent() {
      return instance.hasTestEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserEventSpecifics.Test getTestEvent() {
      return instance.getTestEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
     */
    public Builder setTestEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Test value) {
      copyOnWrite();
      instance.setTestEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
     */
    public Builder setTestEvent(
        org.chromium.components.sync.protocol.UserEventSpecifics.Test.Builder builderForValue) {
      copyOnWrite();
      instance.setTestEvent(builderForValue.build());
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
     */
    public Builder mergeTestEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Test value) {
      copyOnWrite();
      instance.mergeTestEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Test test_event = 8;</code>
     */
    public Builder clearTestEvent() {
      copyOnWrite();
      instance.clearTestEvent();
      return this;
    }

    /**
     * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasLanguageDetectionEvent() {
      return instance.hasLanguageDetectionEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection getLanguageDetectionEvent() {
      return instance.getLanguageDetectionEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setLanguageDetectionEvent(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection value) {
      copyOnWrite();
      instance.setLanguageDetectionEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setLanguageDetectionEvent(
        org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.Builder builderForValue) {
      copyOnWrite();
      instance.setLanguageDetectionEvent(builderForValue.build());
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder mergeLanguageDetectionEvent(org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection value) {
      copyOnWrite();
      instance.mergeLanguageDetectionEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearLanguageDetectionEvent() {
      copyOnWrite();
      instance.clearLanguageDetectionEvent();
      return this;
    }

    /**
     * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasTranslationEvent() {
      return instance.hasTranslationEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.Translation getTranslationEvent() {
      return instance.getTranslationEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setTranslationEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Translation value) {
      copyOnWrite();
      instance.setTranslationEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setTranslationEvent(
        org.chromium.components.sync.protocol.UserEventSpecifics.Translation.Builder builderForValue) {
      copyOnWrite();
      instance.setTranslationEvent(builderForValue.build());
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder mergeTranslationEvent(org.chromium.components.sync.protocol.UserEventSpecifics.Translation value) {
      copyOnWrite();
      instance.mergeTranslationEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearTranslationEvent() {
      copyOnWrite();
      instance.clearTranslationEvent();
      return this;
    }

    /**
     * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasUserConsent() {
      return instance.hasUserConsent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent getUserConsent() {
      return instance.getUserConsent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setUserConsent(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent value) {
      copyOnWrite();
      instance.setUserConsent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setUserConsent(
        org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.Builder builderForValue) {
      copyOnWrite();
      instance.setUserConsent(builderForValue.build());
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder mergeUserConsent(org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent value) {
      copyOnWrite();
      instance.mergeUserConsent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.UserConsent user_consent = 12 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearUserConsent() {
      copyOnWrite();
      instance.clearUserConsent();
      return this;
    }

    /**
     * <pre>
     * Happens when a user types their Google account password on another site.
     * </pre>
     *
     * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
     */
    @java.lang.Override
    public boolean hasGaiaPasswordReuseEvent() {
      return instance.hasGaiaPasswordReuseEvent();
    }
    /**
     * <pre>
     * Happens when a user types their Google account password on another site.
     * </pre>
     *
     * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.GaiaPasswordReuse getGaiaPasswordReuseEvent() {
      return instance.getGaiaPasswordReuseEvent();
    }
    /**
     * <pre>
     * Happens when a user types their Google account password on another site.
     * </pre>
     *
     * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
     */
    public Builder setGaiaPasswordReuseEvent(org.chromium.components.sync.protocol.GaiaPasswordReuse value) {
      copyOnWrite();
      instance.setGaiaPasswordReuseEvent(value);
      return this;
    }
    /**
     * <pre>
     * Happens when a user types their Google account password on another site.
     * </pre>
     *
     * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
     */
    public Builder setGaiaPasswordReuseEvent(
        org.chromium.components.sync.protocol.GaiaPasswordReuse.Builder builderForValue) {
      copyOnWrite();
      instance.setGaiaPasswordReuseEvent(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Happens when a user types their Google account password on another site.
     * </pre>
     *
     * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
     */
    public Builder mergeGaiaPasswordReuseEvent(org.chromium.components.sync.protocol.GaiaPasswordReuse value) {
      copyOnWrite();
      instance.mergeGaiaPasswordReuseEvent(value);
      return this;
    }
    /**
     * <pre>
     * Happens when a user types their Google account password on another site.
     * </pre>
     *
     * <code>.sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;</code>
     */
    public Builder clearGaiaPasswordReuseEvent() {
      copyOnWrite();
      instance.clearGaiaPasswordReuseEvent();
      return this;
    }

    /**
     * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
     */
    @java.lang.Override
    public boolean hasGaiaPasswordCapturedEvent() {
      return instance.hasGaiaPasswordCapturedEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured getGaiaPasswordCapturedEvent() {
      return instance.getGaiaPasswordCapturedEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
     */
    public Builder setGaiaPasswordCapturedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured value) {
      copyOnWrite();
      instance.setGaiaPasswordCapturedEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
     */
    public Builder setGaiaPasswordCapturedEvent(
        org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.Builder builderForValue) {
      copyOnWrite();
      instance.setGaiaPasswordCapturedEvent(builderForValue.build());
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
     */
    public Builder mergeGaiaPasswordCapturedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured value) {
      copyOnWrite();
      instance.mergeGaiaPasswordCapturedEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;</code>
     */
    public Builder clearGaiaPasswordCapturedEvent() {
      copyOnWrite();
      instance.clearGaiaPasswordCapturedEvent();
      return this;
    }

    /**
     * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
     */
    @java.lang.Override
    public boolean hasFlocIdComputedEvent() {
      return instance.hasFlocIdComputedEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
     */
    @java.lang.Override
    public org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed getFlocIdComputedEvent() {
      return instance.getFlocIdComputedEvent();
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
     */
    public Builder setFlocIdComputedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed value) {
      copyOnWrite();
      instance.setFlocIdComputedEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
     */
    public Builder setFlocIdComputedEvent(
        org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.Builder builderForValue) {
      copyOnWrite();
      instance.setFlocIdComputedEvent(builderForValue.build());
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
     */
    public Builder mergeFlocIdComputedEvent(org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed value) {
      copyOnWrite();
      instance.mergeFlocIdComputedEvent(value);
      return this;
    }
    /**
     * <code>.sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;</code>
     */
    public Builder clearFlocIdComputedEvent() {
      copyOnWrite();
      instance.clearFlocIdComputedEvent();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.UserEventSpecifics)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.UserEventSpecifics();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "event_",
            "eventCase_",
            "bitField0_",
            "eventTimeUsec_",
            "navigationId_",
            "sessionId_",
            org.chromium.components.sync.protocol.UserEventSpecifics.Test.class,
            org.chromium.components.sync.protocol.UserEventSpecifics.LanguageDetection.class,
            org.chromium.components.sync.protocol.UserEventSpecifics.Translation.class,
            org.chromium.components.sync.protocol.UserEventSpecifics.UserConsent.class,
            org.chromium.components.sync.protocol.UserEventSpecifics.GaiaPasswordCaptured.class,
            org.chromium.components.sync.protocol.UserEventSpecifics.FlocIdComputed.class,
            org.chromium.components.sync.protocol.GaiaPasswordReuse.class,
          };
          java.lang.String info =
              "\u0001\n\u0001\u0001\u0001h\n\u0000\u0000\u0000\u0001\u1002\u0000\u0002\u1002\u0001" +
              "\u0003\u1005\u0002\b\u103c\u0000\n\u103c\u0000\u000b\u103c\u0000\f\u103c\u0000\u000f" +
              "\u103c\u0000\u0010\u103c\u0000h\u103c\u0000";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.components.sync.protocol.UserEventSpecifics> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.components.sync.protocol.UserEventSpecifics.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.components.sync.protocol.UserEventSpecifics>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.UserEventSpecifics)
  private static final org.chromium.components.sync.protocol.UserEventSpecifics DEFAULT_INSTANCE;
  static {
    UserEventSpecifics defaultInstance = new UserEventSpecifics();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      UserEventSpecifics.class, defaultInstance);
  }

  public static org.chromium.components.sync.protocol.UserEventSpecifics getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<UserEventSpecifics> PARSER;

  public static com.google.protobuf.Parser<UserEventSpecifics> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

