// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/ui/piet/errors.proto

package org.chromium.components.feed.core.proto.ui.piet;

public final class ErrorsProto {
  private ErrorsProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  /**
   * <pre>
   * clang-format off
   * +----------+--------------------------+--------------------------+------------------------+
   * | Level    | Server                   | Client Prod Build        | Client Dev Build       |
   * +----------+--------------------------+--------------------------+------------------------+
   * | UNKNOWN  | Should never be raised   | Should never be raised   | Should never be raised |
   * +----------+--------------------------+--------------------------+------------------------+
   * | FATAL    | Log to Console           | Log to Console           | Crash                  |
   * |          | Fail when building proto | Log to Clearcut          |                        |
   * |          | Fail tests               | Drop all affected Frames |                        |
   * +----------+--------------------------+--------------------------+------------------------+
   * | ERROR    | Log to Console           | Log to Console           | Crash                  |
   * |          | Refuse to build proto    | Log to Clearcut          |                        |
   * |          | Fail tests               | Drop current Frame       |                        |
   * |          |                          | Proceed with next Frame  |                        |
   * +----------+--------------------------+--------------------------+------------------------+
   * | WARNING  | Log to Console           | Log to Console           | Log to Console         |
   * |          | OK to build proto        | Log to Clearcut          | Annotate Frame         |
   * |          | Warn during tests        |                          |                        |
   * +----------+--------------------------+--------------------------+------------------------+
   * | NOTICE   | Log to Console           | Nothing                  | Log to Console         |
   * |          | OK to build proto        |                          |                        |
   * +----------+--------------------------+--------------------------+------------------------+
   * | QUIET    | Nothing                  | Nothing                  | Nothing                |
   * +----------+--------------------------+--------------------------+------------------------+
   * clang-format on
   * A note on client build types:
   * * Dev: Only those builds used by developers who can see the source and have
   *   the power/ability to fix things should be considered Dev builds.
   *   E.g. AGSA built from source, or Chromium.
   * * Prod: Most builds should be classified as prod, for the purposes of the
   *   table above.
   *   E.g. AGSA Stable, AGSA Alpha, AGSA Beta, Chrome Stable, Chrome Beta, Chrome
   *   Dev, Chrome Canary.
   * </pre>
   *
   * Protobuf enum {@code components.feed.core.proto.ui.piet.ErrorLevel}
   */
  public enum ErrorLevel
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * UNKNOWN is used when it is not possible to detect a particular kind of
     * error, but is needed as a proto option. E.g. detecting a poor frame rate is
     * not possible server-side, so `server_error = UNKNOWN` is appropriate for
     * `ERR_POOR_FRAME_RATE`.
     * </pre>
     *
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <pre>
     * Piet has encountered an invalid PietSharedState, which affects all Frames
     * in the current response. Piet has determined that it cannot proceed with
     * rendering any Frame at all.
     * </pre>
     *
     * <code>FATAL = 1;</code>
     */
    FATAL(1),
    /**
     * <pre>
     * Piet has encountered an invalid Frame, so it cannot proceed with rendering
     * that particular Frame. It is possible to render all the other Frames in the
     * current response.
     * </pre>
     *
     * <code>ERROR = 2;</code>
     */
    ERROR(2),
    /**
     * <pre>
     * Piet can use reasonably sane strategies to recover, but feature authors
     * need to be aware that something unexpected happened.
     * </pre>
     *
     * <code>WARNING = 3;</code>
     */
    WARNING(3),
    /**
     * <pre>
     * Debug purposes only; notices are not visible in production builds.
     * </pre>
     *
     * <code>NOTICE = 4;</code>
     */
    NOTICE(4),
    /**
     * <pre>
     * No reporting is performed; this class of errors can be silently ignored
     * with no negative consequences. This level exists because certain types of
     * errors can be treated as loud on the server but quiet on the client.
     * </pre>
     *
     * <code>QUIET = 5;</code>
     */
    QUIET(5),
    ;

    /**
     * <pre>
     * UNKNOWN is used when it is not possible to detect a particular kind of
     * error, but is needed as a proto option. E.g. detecting a poor frame rate is
     * not possible server-side, so `server_error = UNKNOWN` is appropriate for
     * `ERR_POOR_FRAME_RATE`.
     * </pre>
     *
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <pre>
     * Piet has encountered an invalid PietSharedState, which affects all Frames
     * in the current response. Piet has determined that it cannot proceed with
     * rendering any Frame at all.
     * </pre>
     *
     * <code>FATAL = 1;</code>
     */
    public static final int FATAL_VALUE = 1;
    /**
     * <pre>
     * Piet has encountered an invalid Frame, so it cannot proceed with rendering
     * that particular Frame. It is possible to render all the other Frames in the
     * current response.
     * </pre>
     *
     * <code>ERROR = 2;</code>
     */
    public static final int ERROR_VALUE = 2;
    /**
     * <pre>
     * Piet can use reasonably sane strategies to recover, but feature authors
     * need to be aware that something unexpected happened.
     * </pre>
     *
     * <code>WARNING = 3;</code>
     */
    public static final int WARNING_VALUE = 3;
    /**
     * <pre>
     * Debug purposes only; notices are not visible in production builds.
     * </pre>
     *
     * <code>NOTICE = 4;</code>
     */
    public static final int NOTICE_VALUE = 4;
    /**
     * <pre>
     * No reporting is performed; this class of errors can be silently ignored
     * with no negative consequences. This level exists because certain types of
     * errors can be treated as loud on the server but quiet on the client.
     * </pre>
     *
     * <code>QUIET = 5;</code>
     */
    public static final int QUIET_VALUE = 5;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ErrorLevel valueOf(int value) {
      return forNumber(value);
    }

    public static ErrorLevel forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return FATAL;
        case 2: return ERROR;
        case 3: return WARNING;
        case 4: return NOTICE;
        case 5: return QUIET;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ErrorLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ErrorLevel> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ErrorLevel>() {
            @java.lang.Override
            public ErrorLevel findValueByNumber(int number) {
              return ErrorLevel.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return ErrorLevelVerifier.INSTANCE;
    }

    private static final class ErrorLevelVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ErrorLevelVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return ErrorLevel.forNumber(number) != null;
            }
          };

    private final int value;

    private ErrorLevel(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:components.feed.core.proto.ui.piet.ErrorLevel)
  }

  /**
   * Protobuf enum {@code components.feed.core.proto.ui.piet.ErrorCode}
   */
  public enum ErrorCode
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * Not to be used for real errors; this only exists because proto enums must
     * have a default value.
     * </pre>
     *
     * <code>ERR_UNSPECIFIED = 0;</code>
     */
    ERR_UNSPECIFIED(0),
    /**
     * <pre>
     * When the client tries to reference a SharedState that is not found, the
     * Frame cannot be rendered, and likely no frames can be rendered.
     * This error code must be reported by the Piet host app, as the Piet
     * implementation assumes that all shared states have been provided already.
     * </pre>
     *
     * <code>ERR_MISSING_SHARED_STATE = 12;</code>
     */
    ERR_MISSING_SHARED_STATE(12),
    /**
     * <pre>
     * When a Template cannot be located, it only affects Frames that reference
     * it, so we can proceed to render other unaffected Frames, making this an
     * ERROR, not FATAL.
     * </pre>
     *
     * <code>ERR_MISSING_TEMPLATE = 5;</code>
     */
    ERR_MISSING_TEMPLATE(5),
    /**
     * <pre>
     * When two or more Templates with the same conflicting ID are found in
     * PietSharedState, rendering of all Frames becomes unpredictable, making this
     * FATAL.
     * </pre>
     *
     * <code>ERR_DUPLICATE_TEMPLATE = 6;</code>
     */
    ERR_DUPLICATE_TEMPLATE(6),
    /**
     * <pre>
     * When a stylesheet cannot be located, it only affects Frames that reference
     * it, so we can proceed to render other unaffected Frames, making this an
     * ERROR, not FATAL.
     * </pre>
     *
     * <code>ERR_MISSING_STYLESHEET = 1;</code>
     */
    ERR_MISSING_STYLESHEET(1),
    /**
     * <pre>
     * When two or more Stylesheets with the same conflicting ID are found in
     * PietSharedState, rendering of all Frames becomes unpredictable, making this
     * FATAL.
     * </pre>
     *
     * <code>ERR_DUPLICATE_STYLESHEET = 2;</code>
     */
    ERR_DUPLICATE_STYLESHEET(2),
    /**
     * <code>ERR_MISSING_STYLE = 3;</code>
     */
    ERR_MISSING_STYLE(3),
    /**
     * <pre>
     * If two or more Styles with the same conflicting ID are found in the same
     * BindingContext, rendering of the affected Frame is unpredictable.
     * </pre>
     *
     * <code>ERR_DUPLICATE_STYLE = 4;</code>
     */
    ERR_DUPLICATE_STYLE(4),
    /**
     * <pre>
     * If a BindingValue is missing for a BindingRef that is required (i.e. not
     * marked is_optional), this error is raised.
     * </pre>
     *
     * <code>ERR_MISSING_BINDING_VALUE = 8;</code>
     */
    ERR_MISSING_BINDING_VALUE(8),
    /**
     * <pre>
     * If two or more BindingValues with the same conflicting ID are found in the
     * same binding context, rendering of the affected Frame is unpredictable.
     * </pre>
     *
     * <code>ERR_DUPLICATE_BINDING_VALUE = 9;</code>
     */
    ERR_DUPLICATE_BINDING_VALUE(9),
    /**
     * <pre>
     * BindingValues must be of the same type as the BindingRefs they are expected
     * to replace at runtime.
     * </pre>
     *
     * <code>ERR_BINDING_VALUE_TYPE_MISMATCH = 10;</code>
     */
    ERR_BINDING_VALUE_TYPE_MISMATCH(10),
    /**
     * <pre>
     * Bindings are not supported in Frames or within Bound Elements.
     * </pre>
     *
     * <code>ERR_UNSUPPORTED_CONTEXT_FOR_BINDING = 11;</code>
     */
    ERR_UNSUPPORTED_CONTEXT_FOR_BINDING(11),
    /**
     * <pre>
     * If and only if *all* fonts specified in the style are unavailable on the
     * client at runtime, this error will be raised. If at least one font (from
     * among the ordered list of fonts) is available, then this error MUST NOT be
     * raised.
     * </pre>
     *
     * <code>ERR_MISSING_FONTS = 101;</code>
     */
    ERR_MISSING_FONTS(101),
    /**
     * <pre>
     * If and only if *all* ImageSources specified for a single ImageElement lack
     * a valid URL this error should be raised. If at least one URL is present,
     * this error MUST NOT be raised. Note that this error is only related to
     * whether a URL is present or absent. Adverse network conditions should have
     * no impact on this, and MUST NOT raise this error.
     * </pre>
     *
     * <code>ERR_MISSING_IMAGE_URL = 102;</code>
     */
    ERR_MISSING_IMAGE_URL(102),
    /**
     * <pre>
     * If and only if *all* ImageSources specified for a single ImageElement
     * cannot be located at runtime (due of a temporary network issue, or if the
     * asset cannot be located in the app binary), this error should be raised.
     * If at least one URL can be correctly resolved, this error MUST NOT be
     * raised.
     * </pre>
     *
     * <code>ERR_IMAGE_UNAVAILABLE = 103;</code>
     */
    ERR_IMAGE_UNAVAILABLE(103),
    /**
     * <pre>
     * If Piet encounters a CustomElement, and the Host is unable to locate a
     * custom renderer for that CustomElement, this error will be raised.
     * </pre>
     *
     * <code>ERR_MISSING_CUSTOM_ELEMENT_RENDERER = 104;</code>
     */
    ERR_MISSING_CUSTOM_ELEMENT_RENDERER(104),
    /**
     * <pre>
     * Gradient directions should be in the range [0, 360).
     * </pre>
     *
     * <code>ERR_INVALID_GRADIENT_DIRECTION = 105;</code>
     */
    ERR_INVALID_GRADIENT_DIRECTION(105),
    /**
     * <pre>
     * If an Action Handler delegate (which is part of a Piet Host) encounters an
     * `Action` proto that it cannot handle (e.g. because none of the extensions
     * it can process are present), this error will be raised.
     * </pre>
     *
     * <code>ERR_MISSING_ACTION_HANDLER = 106;</code>
     */
    ERR_MISSING_ACTION_HANDLER(106),
    /**
     * <pre>
     * If a GridCell with Content width has a content that is not TextElement or
     * ImageElement, this error will be raised.
     * </pre>
     *
     * <code>ERR_CONTENT_WIDTH_GRID_CELL_WITH_INVALID_CONTENT = 107;</code>
     */
    ERR_CONTENT_WIDTH_GRID_CELL_WITH_INVALID_CONTENT(107),
    /**
     * <pre>
     * It does not make sense to have a GridCell where GridCellWidth is specified
     * but nothing inside the GridCellWidth is populated. Looks like missing data.
     * </pre>
     *
     * <code>ERR_GRID_CELL_WIDTH_WITHOUT_CONTENTS = 108;</code>
     */
    ERR_GRID_CELL_WIDTH_WITHOUT_CONTENTS(108),
    /**
     * <pre>
     * If a MediaQueryCondition is specified with any parameter unchanged from its
     * default value, this error is raised.
     * </pre>
     *
     * <code>ERR_INVALID_MEDIA_QUERY_CONDITION = 109;</code>
     */
    ERR_INVALID_MEDIA_QUERY_CONDITION(109),
    /**
     * <pre>
     * If an Element is passed to an adapter but is missing the required type of
     * content (ex. an Element without a TextElement in TextElementAdapter).
     * </pre>
     *
     * <code>ERR_MISSING_ELEMENT_CONTENTS = 110;</code>
     */
    ERR_MISSING_ELEMENT_CONTENTS(110),
    /**
     * <pre>
     * A proto is missing some of the content it is expected to have.
     * Ex. getting an unrecognized value for an enum or oneof case.
     * </pre>
     *
     * <code>ERR_MISSING_OR_UNHANDLED_CONTENT = 111;</code>
     */
    ERR_MISSING_OR_UNHANDLED_CONTENT(111),
    /**
     * <pre>
     * It is possible and likely that different client implementations of Piet
     * will not support all features equally at all points of time. Incomplete
     * implementations MAY raise this error to indicate their lack of support for
     * certain Piet features. It is not guaranteed that every implementation will
     * raise this error for every feature.
     * </pre>
     *
     * <code>ERR_UNSUPPORTED_FEATURE = 201;</code>
     */
    ERR_UNSUPPORTED_FEATURE(201),
    /**
     * <pre>
     * Certain platforms, e.g. Android, have limitations on how large a proto can
     * be, because it needs to be serialized/deserialized into structures with
     * limited memory. On certain low-RAM devices, this error may be raised to
     * inform the server of a potential performance implication.
     * </pre>
     *
     * <code>ERR_PROTO_TOO_LARGE = 202;</code>
     */
    ERR_PROTO_TOO_LARGE(202),
    /**
     * <pre>
     * If a Piet renderer is unable to render content at 60 fps, it attempts to
     * inform the server. Feature authors can monitor the number of dropped frames
     * and consider if they want to make improvements, e.g. simplifying the visual
     * design to reduce nesting levels.
     * </pre>
     *
     * <code>ERR_POOR_FRAME_RATE = 203;</code>
     */
    ERR_POOR_FRAME_RATE(203),
    /**
     * <pre>
     * ChunkedText should be used only when there's more than one chunk in it,
     * othewise, either ParameterizedText, or Image should be used.
     * </pre>
     *
     * <code>ERR_CHUNKED_TEXT_WITH_SINGLE_CHUNK = 204;</code>
     */
    ERR_CHUNKED_TEXT_WITH_SINGLE_CHUNK(204),
    ;

    /**
     * <pre>
     * Not to be used for real errors; this only exists because proto enums must
     * have a default value.
     * </pre>
     *
     * <code>ERR_UNSPECIFIED = 0;</code>
     */
    public static final int ERR_UNSPECIFIED_VALUE = 0;
    /**
     * <pre>
     * When the client tries to reference a SharedState that is not found, the
     * Frame cannot be rendered, and likely no frames can be rendered.
     * This error code must be reported by the Piet host app, as the Piet
     * implementation assumes that all shared states have been provided already.
     * </pre>
     *
     * <code>ERR_MISSING_SHARED_STATE = 12;</code>
     */
    public static final int ERR_MISSING_SHARED_STATE_VALUE = 12;
    /**
     * <pre>
     * When a Template cannot be located, it only affects Frames that reference
     * it, so we can proceed to render other unaffected Frames, making this an
     * ERROR, not FATAL.
     * </pre>
     *
     * <code>ERR_MISSING_TEMPLATE = 5;</code>
     */
    public static final int ERR_MISSING_TEMPLATE_VALUE = 5;
    /**
     * <pre>
     * When two or more Templates with the same conflicting ID are found in
     * PietSharedState, rendering of all Frames becomes unpredictable, making this
     * FATAL.
     * </pre>
     *
     * <code>ERR_DUPLICATE_TEMPLATE = 6;</code>
     */
    public static final int ERR_DUPLICATE_TEMPLATE_VALUE = 6;
    /**
     * <pre>
     * When a stylesheet cannot be located, it only affects Frames that reference
     * it, so we can proceed to render other unaffected Frames, making this an
     * ERROR, not FATAL.
     * </pre>
     *
     * <code>ERR_MISSING_STYLESHEET = 1;</code>
     */
    public static final int ERR_MISSING_STYLESHEET_VALUE = 1;
    /**
     * <pre>
     * When two or more Stylesheets with the same conflicting ID are found in
     * PietSharedState, rendering of all Frames becomes unpredictable, making this
     * FATAL.
     * </pre>
     *
     * <code>ERR_DUPLICATE_STYLESHEET = 2;</code>
     */
    public static final int ERR_DUPLICATE_STYLESHEET_VALUE = 2;
    /**
     * <code>ERR_MISSING_STYLE = 3;</code>
     */
    public static final int ERR_MISSING_STYLE_VALUE = 3;
    /**
     * <pre>
     * If two or more Styles with the same conflicting ID are found in the same
     * BindingContext, rendering of the affected Frame is unpredictable.
     * </pre>
     *
     * <code>ERR_DUPLICATE_STYLE = 4;</code>
     */
    public static final int ERR_DUPLICATE_STYLE_VALUE = 4;
    /**
     * <pre>
     * If a BindingValue is missing for a BindingRef that is required (i.e. not
     * marked is_optional), this error is raised.
     * </pre>
     *
     * <code>ERR_MISSING_BINDING_VALUE = 8;</code>
     */
    public static final int ERR_MISSING_BINDING_VALUE_VALUE = 8;
    /**
     * <pre>
     * If two or more BindingValues with the same conflicting ID are found in the
     * same binding context, rendering of the affected Frame is unpredictable.
     * </pre>
     *
     * <code>ERR_DUPLICATE_BINDING_VALUE = 9;</code>
     */
    public static final int ERR_DUPLICATE_BINDING_VALUE_VALUE = 9;
    /**
     * <pre>
     * BindingValues must be of the same type as the BindingRefs they are expected
     * to replace at runtime.
     * </pre>
     *
     * <code>ERR_BINDING_VALUE_TYPE_MISMATCH = 10;</code>
     */
    public static final int ERR_BINDING_VALUE_TYPE_MISMATCH_VALUE = 10;
    /**
     * <pre>
     * Bindings are not supported in Frames or within Bound Elements.
     * </pre>
     *
     * <code>ERR_UNSUPPORTED_CONTEXT_FOR_BINDING = 11;</code>
     */
    public static final int ERR_UNSUPPORTED_CONTEXT_FOR_BINDING_VALUE = 11;
    /**
     * <pre>
     * If and only if *all* fonts specified in the style are unavailable on the
     * client at runtime, this error will be raised. If at least one font (from
     * among the ordered list of fonts) is available, then this error MUST NOT be
     * raised.
     * </pre>
     *
     * <code>ERR_MISSING_FONTS = 101;</code>
     */
    public static final int ERR_MISSING_FONTS_VALUE = 101;
    /**
     * <pre>
     * If and only if *all* ImageSources specified for a single ImageElement lack
     * a valid URL this error should be raised. If at least one URL is present,
     * this error MUST NOT be raised. Note that this error is only related to
     * whether a URL is present or absent. Adverse network conditions should have
     * no impact on this, and MUST NOT raise this error.
     * </pre>
     *
     * <code>ERR_MISSING_IMAGE_URL = 102;</code>
     */
    public static final int ERR_MISSING_IMAGE_URL_VALUE = 102;
    /**
     * <pre>
     * If and only if *all* ImageSources specified for a single ImageElement
     * cannot be located at runtime (due of a temporary network issue, or if the
     * asset cannot be located in the app binary), this error should be raised.
     * If at least one URL can be correctly resolved, this error MUST NOT be
     * raised.
     * </pre>
     *
     * <code>ERR_IMAGE_UNAVAILABLE = 103;</code>
     */
    public static final int ERR_IMAGE_UNAVAILABLE_VALUE = 103;
    /**
     * <pre>
     * If Piet encounters a CustomElement, and the Host is unable to locate a
     * custom renderer for that CustomElement, this error will be raised.
     * </pre>
     *
     * <code>ERR_MISSING_CUSTOM_ELEMENT_RENDERER = 104;</code>
     */
    public static final int ERR_MISSING_CUSTOM_ELEMENT_RENDERER_VALUE = 104;
    /**
     * <pre>
     * Gradient directions should be in the range [0, 360).
     * </pre>
     *
     * <code>ERR_INVALID_GRADIENT_DIRECTION = 105;</code>
     */
    public static final int ERR_INVALID_GRADIENT_DIRECTION_VALUE = 105;
    /**
     * <pre>
     * If an Action Handler delegate (which is part of a Piet Host) encounters an
     * `Action` proto that it cannot handle (e.g. because none of the extensions
     * it can process are present), this error will be raised.
     * </pre>
     *
     * <code>ERR_MISSING_ACTION_HANDLER = 106;</code>
     */
    public static final int ERR_MISSING_ACTION_HANDLER_VALUE = 106;
    /**
     * <pre>
     * If a GridCell with Content width has a content that is not TextElement or
     * ImageElement, this error will be raised.
     * </pre>
     *
     * <code>ERR_CONTENT_WIDTH_GRID_CELL_WITH_INVALID_CONTENT = 107;</code>
     */
    public static final int ERR_CONTENT_WIDTH_GRID_CELL_WITH_INVALID_CONTENT_VALUE = 107;
    /**
     * <pre>
     * It does not make sense to have a GridCell where GridCellWidth is specified
     * but nothing inside the GridCellWidth is populated. Looks like missing data.
     * </pre>
     *
     * <code>ERR_GRID_CELL_WIDTH_WITHOUT_CONTENTS = 108;</code>
     */
    public static final int ERR_GRID_CELL_WIDTH_WITHOUT_CONTENTS_VALUE = 108;
    /**
     * <pre>
     * If a MediaQueryCondition is specified with any parameter unchanged from its
     * default value, this error is raised.
     * </pre>
     *
     * <code>ERR_INVALID_MEDIA_QUERY_CONDITION = 109;</code>
     */
    public static final int ERR_INVALID_MEDIA_QUERY_CONDITION_VALUE = 109;
    /**
     * <pre>
     * If an Element is passed to an adapter but is missing the required type of
     * content (ex. an Element without a TextElement in TextElementAdapter).
     * </pre>
     *
     * <code>ERR_MISSING_ELEMENT_CONTENTS = 110;</code>
     */
    public static final int ERR_MISSING_ELEMENT_CONTENTS_VALUE = 110;
    /**
     * <pre>
     * A proto is missing some of the content it is expected to have.
     * Ex. getting an unrecognized value for an enum or oneof case.
     * </pre>
     *
     * <code>ERR_MISSING_OR_UNHANDLED_CONTENT = 111;</code>
     */
    public static final int ERR_MISSING_OR_UNHANDLED_CONTENT_VALUE = 111;
    /**
     * <pre>
     * It is possible and likely that different client implementations of Piet
     * will not support all features equally at all points of time. Incomplete
     * implementations MAY raise this error to indicate their lack of support for
     * certain Piet features. It is not guaranteed that every implementation will
     * raise this error for every feature.
     * </pre>
     *
     * <code>ERR_UNSUPPORTED_FEATURE = 201;</code>
     */
    public static final int ERR_UNSUPPORTED_FEATURE_VALUE = 201;
    /**
     * <pre>
     * Certain platforms, e.g. Android, have limitations on how large a proto can
     * be, because it needs to be serialized/deserialized into structures with
     * limited memory. On certain low-RAM devices, this error may be raised to
     * inform the server of a potential performance implication.
     * </pre>
     *
     * <code>ERR_PROTO_TOO_LARGE = 202;</code>
     */
    public static final int ERR_PROTO_TOO_LARGE_VALUE = 202;
    /**
     * <pre>
     * If a Piet renderer is unable to render content at 60 fps, it attempts to
     * inform the server. Feature authors can monitor the number of dropped frames
     * and consider if they want to make improvements, e.g. simplifying the visual
     * design to reduce nesting levels.
     * </pre>
     *
     * <code>ERR_POOR_FRAME_RATE = 203;</code>
     */
    public static final int ERR_POOR_FRAME_RATE_VALUE = 203;
    /**
     * <pre>
     * ChunkedText should be used only when there's more than one chunk in it,
     * othewise, either ParameterizedText, or Image should be used.
     * </pre>
     *
     * <code>ERR_CHUNKED_TEXT_WITH_SINGLE_CHUNK = 204;</code>
     */
    public static final int ERR_CHUNKED_TEXT_WITH_SINGLE_CHUNK_VALUE = 204;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ErrorCode valueOf(int value) {
      return forNumber(value);
    }

    public static ErrorCode forNumber(int value) {
      switch (value) {
        case 0: return ERR_UNSPECIFIED;
        case 12: return ERR_MISSING_SHARED_STATE;
        case 5: return ERR_MISSING_TEMPLATE;
        case 6: return ERR_DUPLICATE_TEMPLATE;
        case 1: return ERR_MISSING_STYLESHEET;
        case 2: return ERR_DUPLICATE_STYLESHEET;
        case 3: return ERR_MISSING_STYLE;
        case 4: return ERR_DUPLICATE_STYLE;
        case 8: return ERR_MISSING_BINDING_VALUE;
        case 9: return ERR_DUPLICATE_BINDING_VALUE;
        case 10: return ERR_BINDING_VALUE_TYPE_MISMATCH;
        case 11: return ERR_UNSUPPORTED_CONTEXT_FOR_BINDING;
        case 101: return ERR_MISSING_FONTS;
        case 102: return ERR_MISSING_IMAGE_URL;
        case 103: return ERR_IMAGE_UNAVAILABLE;
        case 104: return ERR_MISSING_CUSTOM_ELEMENT_RENDERER;
        case 105: return ERR_INVALID_GRADIENT_DIRECTION;
        case 106: return ERR_MISSING_ACTION_HANDLER;
        case 107: return ERR_CONTENT_WIDTH_GRID_CELL_WITH_INVALID_CONTENT;
        case 108: return ERR_GRID_CELL_WIDTH_WITHOUT_CONTENTS;
        case 109: return ERR_INVALID_MEDIA_QUERY_CONDITION;
        case 110: return ERR_MISSING_ELEMENT_CONTENTS;
        case 111: return ERR_MISSING_OR_UNHANDLED_CONTENT;
        case 201: return ERR_UNSUPPORTED_FEATURE;
        case 202: return ERR_PROTO_TOO_LARGE;
        case 203: return ERR_POOR_FRAME_RATE;
        case 204: return ERR_CHUNKED_TEXT_WITH_SINGLE_CHUNK;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ErrorCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ErrorCode> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ErrorCode>() {
            @java.lang.Override
            public ErrorCode findValueByNumber(int number) {
              return ErrorCode.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return ErrorCodeVerifier.INSTANCE;
    }

    private static final class ErrorCodeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ErrorCodeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return ErrorCode.forNumber(number) != null;
            }
          };

    private final int value;

    private ErrorCode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:components.feed.core.proto.ui.piet.ErrorCode)
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
