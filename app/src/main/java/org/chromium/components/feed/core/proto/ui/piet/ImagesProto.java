// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/ui/piet/images.proto

package org.chromium.components.feed.core.proto.ui.piet;

public final class ImagesProto {
  private ImagesProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface ImageOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:components.feed.core.proto.ui.piet.Image)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                Image, Image.Builder> {

    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    java.util.List<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> 
        getSourcesList();
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource getSources(int index);
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    int getSourcesCount();
  }
  /**
   * <pre>
   * An image asset.
   * </pre>
   *
   * Protobuf type {@code components.feed.core.proto.ui.piet.Image}
   */
  public  static final class Image extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        Image, Image.Builder> implements
      // @@protoc_insertion_point(message_implements:components.feed.core.proto.ui.piet.Image)
      ImageOrBuilder {
    private Image() {
      sources_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The type of scaling to apply.
     * </pre>
     *
     * Protobuf enum {@code components.feed.core.proto.ui.piet.Image.ScaleType}
     */
    public enum ScaleType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * When scale type is unspecified, we err on the side of preserving all
       * areas of the image, so this is equivalent to CENTER_INSIDE.
       * </pre>
       *
       * <code>SCALE_TYPE_UNSPECIFIED = 0;</code>
       */
      SCALE_TYPE_UNSPECIFIED(0),
      /**
       * <pre>
       * Scale the image uniformly such that width or height will be equal to the
       * size of its view. The image will not be cropped.
       * </pre>
       *
       * <code>CENTER_INSIDE = 1;</code>
       */
      CENTER_INSIDE(1),
      /**
       * <pre>
       * Scale the image uniformly to fill its view. Some portion of the image
       * will be cropped.
       * </pre>
       *
       * <code>CENTER_CROP = 2;</code>
       */
      CENTER_CROP(2),
      ;

      /**
       * <pre>
       * When scale type is unspecified, we err on the side of preserving all
       * areas of the image, so this is equivalent to CENTER_INSIDE.
       * </pre>
       *
       * <code>SCALE_TYPE_UNSPECIFIED = 0;</code>
       */
      public static final int SCALE_TYPE_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * Scale the image uniformly such that width or height will be equal to the
       * size of its view. The image will not be cropped.
       * </pre>
       *
       * <code>CENTER_INSIDE = 1;</code>
       */
      public static final int CENTER_INSIDE_VALUE = 1;
      /**
       * <pre>
       * Scale the image uniformly to fill its view. Some portion of the image
       * will be cropped.
       * </pre>
       *
       * <code>CENTER_CROP = 2;</code>
       */
      public static final int CENTER_CROP_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ScaleType valueOf(int value) {
        return forNumber(value);
      }

      public static ScaleType forNumber(int value) {
        switch (value) {
          case 0: return SCALE_TYPE_UNSPECIFIED;
          case 1: return CENTER_INSIDE;
          case 2: return CENTER_CROP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ScaleType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ScaleType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ScaleType>() {
              @java.lang.Override
              public ScaleType findValueByNumber(int number) {
                return ScaleType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ScaleTypeVerifier.INSTANCE;
      }

      private static final class ScaleTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ScaleTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ScaleType.forNumber(number) != null;
              }
            };

      private final int value;

      private ScaleType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:components.feed.core.proto.ui.piet.Image.ScaleType)
    }

    public static final int SOURCES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> sources_;
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> getSourcesList() {
      return sources_;
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    public java.util.List<? extends org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSourceOrBuilder> 
        getSourcesOrBuilderList() {
      return sources_;
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    @java.lang.Override
    public int getSourcesCount() {
      return sources_.size();
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    @java.lang.Override
    public org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource getSources(int index) {
      return sources_.get(index);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    public org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSourceOrBuilder getSourcesOrBuilder(
        int index) {
      return sources_.get(index);
    }
    private void ensureSourcesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> tmp = sources_;
      if (!tmp.isModifiable()) {
        sources_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    private void setSources(
        int index, org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource value) {
      value.getClass();
  ensureSourcesIsMutable();
      sources_.set(index, value);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    private void addSources(org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource value) {
      value.getClass();
  ensureSourcesIsMutable();
      sources_.add(value);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    private void addSources(
        int index, org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource value) {
      value.getClass();
  ensureSourcesIsMutable();
      sources_.add(index, value);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    private void addAllSources(
        java.lang.Iterable<? extends org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> values) {
      ensureSourcesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, sources_);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    private void clearSources() {
      sources_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
     */
    private void removeSources(int index) {
      ensureSourcesIsMutable();
      sources_.remove(index);
    }

    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * An image asset.
     * </pre>
     *
     * Protobuf type {@code components.feed.core.proto.ui.piet.Image}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image, Builder> implements
        // @@protoc_insertion_point(builder_implements:components.feed.core.proto.ui.piet.Image)
        org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageOrBuilder {
      // Construct using org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> getSourcesList() {
        return java.util.Collections.unmodifiableList(
            instance.getSourcesList());
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      @java.lang.Override
      public int getSourcesCount() {
        return instance.getSourcesCount();
      }/**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      @java.lang.Override
      public org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource getSources(int index) {
        return instance.getSources(index);
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder setSources(
          int index, org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource value) {
        copyOnWrite();
        instance.setSources(index, value);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder setSources(
          int index, org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
        copyOnWrite();
        instance.setSources(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource value) {
        copyOnWrite();
        instance.addSources(value);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(
          int index, org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource value) {
        copyOnWrite();
        instance.addSources(index, value);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(
          org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
        copyOnWrite();
        instance.addSources(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(
          int index, org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
        copyOnWrite();
        instance.addSources(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addAllSources(
          java.lang.Iterable<? extends org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> values) {
        copyOnWrite();
        instance.addAllSources(values);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder clearSources() {
        copyOnWrite();
        instance.clearSources();
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder removeSources(int index) {
        copyOnWrite();
        instance.removeSources(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:components.feed.core.proto.ui.piet.Image)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "sources_",
              org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:components.feed.core.proto.ui.piet.Image)
    private static final org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image DEFAULT_INSTANCE;
    static {
      Image defaultInstance = new Image();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Image.class, defaultInstance);
    }

    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.Image getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Image> PARSER;

    public static com.google.protobuf.Parser<Image> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ImageSourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:components.feed.core.proto.ui.piet.ImageSource)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @return Whether the url field is set.
     */
    boolean hasUrl();
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @return The url.
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @return The bytes for url.
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    java.util.List<org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> 
        getConditionsList();
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition getConditions(int index);
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    int getConditionsCount();

    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     * @return Whether the widthPx field is set.
     */
    boolean hasWidthPx();
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     * @return The widthPx.
     */
    int getWidthPx();

    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     * @return Whether the heightPx field is set.
     */
    boolean hasHeightPx();
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     * @return The heightPx.
     */
    int getHeightPx();
  }
  /**
   * <pre>
   * A single physical image, as contained in a single image file or embedded
   * resource. To accommodate devices with varying Device Pixel Ratios, each image
   * in a different DPI bucket can be represented as a separate `ImageSource`.
   * E.g. the same image can be offered as multiple resources as:
   *     ImageSource{
   *       url="ic_icon_24&#64;1x.png",
   *       width=24,
   *       height=24
   *     }
   * and:
   *     ImageSource{
   *       url="ic_icon_24&#64;2x.png",
   *       width=48,
   *       height=48
   *     }
   * This enables clients to choose which image to fetch based on the expected
   * width and height, without actually having to fetch it first.
   * These dimensions also allow clients to pre-size the view for the image before
   * it loads so that the view's size doesn't change once the image is loaded.
   * </pre>
   *
   * Protobuf type {@code components.feed.core.proto.ui.piet.ImageSource}
   */
  public  static final class ImageSource extends
      com.google.protobuf.GeneratedMessageLite<
          ImageSource, ImageSource.Builder> implements
      // @@protoc_insertion_point(message_implements:components.feed.core.proto.ui.piet.ImageSource)
      ImageSourceOrBuilder {
    private ImageSource() {
      url_ = "";
      conditions_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int URL_FIELD_NUMBER = 1;
    private java.lang.String url_;
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @return Whether the url field is set.
     */
    @java.lang.Override
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @return The url.
     */
    @java.lang.Override
    public java.lang.String getUrl() {
      return url_;
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @return The bytes for url.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUrlBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(url_);
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @param value The url to set.
     */
    private void setUrl(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      url_ = value;
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    private void clearUrl() {
      bitField0_ = (bitField0_ & ~0x00000001);
      url_ = getDefaultInstance().getUrl();
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     * @param value The bytes for url to set.
     */
    private void setUrlBytes(
        com.google.protobuf.ByteString value) {
      url_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> conditions_;
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public java.util.List<? extends org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    @java.lang.Override
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    @java.lang.Override
    public org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }
    private void ensureConditionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> tmp = conditions_;
      if (!tmp.isModifiable()) {
        conditions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void setConditions(
        int index, org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
      value.getClass();
  ensureConditionsIsMutable();
      conditions_.set(index, value);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addConditions(org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
      value.getClass();
  ensureConditionsIsMutable();
      conditions_.add(value);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addConditions(
        int index, org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
      value.getClass();
  ensureConditionsIsMutable();
      conditions_.add(index, value);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addAllConditions(
        java.lang.Iterable<? extends org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> values) {
      ensureConditionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, conditions_);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void clearConditions() {
      conditions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void removeConditions(int index) {
      ensureConditionsIsMutable();
      conditions_.remove(index);
    }

    public static final int WIDTH_PX_FIELD_NUMBER = 4;
    private int widthPx_;
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     * @return Whether the widthPx field is set.
     */
    @java.lang.Override
    public boolean hasWidthPx() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     * @return The widthPx.
     */
    @java.lang.Override
    public int getWidthPx() {
      return widthPx_;
    }
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     * @param value The widthPx to set.
     */
    private void setWidthPx(int value) {
      bitField0_ |= 0x00000002;
      widthPx_ = value;
    }
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    private void clearWidthPx() {
      bitField0_ = (bitField0_ & ~0x00000002);
      widthPx_ = 0;
    }

    public static final int HEIGHT_PX_FIELD_NUMBER = 5;
    private int heightPx_;
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     * @return Whether the heightPx field is set.
     */
    @java.lang.Override
    public boolean hasHeightPx() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     * @return The heightPx.
     */
    @java.lang.Override
    public int getHeightPx() {
      return heightPx_;
    }
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     * @param value The heightPx to set.
     */
    private void setHeightPx(int value) {
      bitField0_ |= 0x00000004;
      heightPx_ = value;
    }
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    private void clearHeightPx() {
      bitField0_ = (bitField0_ & ~0x00000004);
      heightPx_ = 0;
    }

    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A single physical image, as contained in a single image file or embedded
     * resource. To accommodate devices with varying Device Pixel Ratios, each image
     * in a different DPI bucket can be represented as a separate `ImageSource`.
     * E.g. the same image can be offered as multiple resources as:
     *     ImageSource{
     *       url="ic_icon_24&#64;1x.png",
     *       width=24,
     *       height=24
     *     }
     * and:
     *     ImageSource{
     *       url="ic_icon_24&#64;2x.png",
     *       width=48,
     *       height=48
     *     }
     * This enables clients to choose which image to fetch based on the expected
     * width and height, without actually having to fetch it first.
     * These dimensions also allow clients to pre-size the view for the image before
     * it loads so that the view's size doesn't change once the image is loaded.
     * </pre>
     *
     * Protobuf type {@code components.feed.core.proto.ui.piet.ImageSource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource, Builder> implements
        // @@protoc_insertion_point(builder_implements:components.feed.core.proto.ui.piet.ImageSource)
        org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSourceOrBuilder {
      // Construct using org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return Whether the url field is set.
       */
      @java.lang.Override
      public boolean hasUrl() {
        return instance.hasUrl();
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return The url.
       */
      @java.lang.Override
      public java.lang.String getUrl() {
        return instance.getUrl();
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return The bytes for url.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUrlBytes() {
        return instance.getUrlBytes();
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @param value The url to set.
       * @return This builder for chaining.
       */
      public Builder setUrl(
          java.lang.String value) {
        copyOnWrite();
        instance.setUrl(value);
        return this;
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUrl() {
        copyOnWrite();
        instance.clearUrl();
        return this;
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       * @param value The bytes for url to set.
       * @return This builder for chaining.
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUrlBytes(value);
        return this;
      }

      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      @java.lang.Override
      public java.util.List<org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> getConditionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getConditionsList());
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      @java.lang.Override
      public int getConditionsCount() {
        return instance.getConditionsCount();
      }/**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      @java.lang.Override
      public org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition getConditions(int index) {
        return instance.getConditions(index);
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder setConditions(
          int index, org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
        copyOnWrite();
        instance.setConditions(index, value);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder setConditions(
          int index, org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
        copyOnWrite();
        instance.setConditions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
        copyOnWrite();
        instance.addConditions(value);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(
          int index, org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
        copyOnWrite();
        instance.addConditions(index, value);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(
          org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
        copyOnWrite();
        instance.addConditions(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(
          int index, org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
        copyOnWrite();
        instance.addConditions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition> values) {
        copyOnWrite();
        instance.addAllConditions(values);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder clearConditions() {
        copyOnWrite();
        instance.clearConditions();
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .components.feed.core.proto.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder removeConditions(int index) {
        copyOnWrite();
        instance.removeConditions(index);
        return this;
      }

      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       * @return Whether the widthPx field is set.
       */
      @java.lang.Override
      public boolean hasWidthPx() {
        return instance.hasWidthPx();
      }
      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       * @return The widthPx.
       */
      @java.lang.Override
      public int getWidthPx() {
        return instance.getWidthPx();
      }
      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       * @param value The widthPx to set.
       * @return This builder for chaining.
       */
      public Builder setWidthPx(int value) {
        copyOnWrite();
        instance.setWidthPx(value);
        return this;
      }
      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearWidthPx() {
        copyOnWrite();
        instance.clearWidthPx();
        return this;
      }

      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       * @return Whether the heightPx field is set.
       */
      @java.lang.Override
      public boolean hasHeightPx() {
        return instance.hasHeightPx();
      }
      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       * @return The heightPx.
       */
      @java.lang.Override
      public int getHeightPx() {
        return instance.getHeightPx();
      }
      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       * @param value The heightPx to set.
       * @return This builder for chaining.
       */
      public Builder setHeightPx(int value) {
        copyOnWrite();
        instance.setHeightPx(value);
        return this;
      }
      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHeightPx() {
        copyOnWrite();
        instance.clearHeightPx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:components.feed.core.proto.ui.piet.ImageSource)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "url_",
              "conditions_",
              org.chromium.components.feed.core.proto.ui.piet.MediaQueriesProto.MediaQueryCondition.class,
              "widthPx_",
              "heightPx_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0005\u0004\u0000\u0001\u0000\u0001\u1008\u0000\u0002" +
                "\u001b\u0004\u1004\u0001\u0005\u1004\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:components.feed.core.proto.ui.piet.ImageSource)
    private static final org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource DEFAULT_INSTANCE;
    static {
      ImageSource defaultInstance = new ImageSource();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ImageSource.class, defaultInstance);
    }

    public static org.chromium.components.feed.core.proto.ui.piet.ImagesProto.ImageSource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ImageSource> PARSER;

    public static com.google.protobuf.Parser<ImageSource> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
