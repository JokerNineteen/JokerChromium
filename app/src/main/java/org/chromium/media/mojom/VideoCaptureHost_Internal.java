// VideoCaptureHost_Internal.java is auto generated by mojom_bindings_generator.py, do not edit


// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     media/capture/mojom/video_capture.mojom
//

package org.chromium.media.mojom;


class VideoCaptureHost_Internal {

    public static final org.chromium.mojo.bindings.Interface.Manager<VideoCaptureHost, VideoCaptureHost.Proxy> MANAGER =
            new org.chromium.mojo.bindings.Interface.Manager<VideoCaptureHost, VideoCaptureHost.Proxy>() {

        @Override
        public String getName() {
            return "media.mojom.VideoCaptureHost";
        }

        @Override
        public int getVersion() {
          return 0;
        }

        @Override
        public Proxy buildProxy(org.chromium.mojo.system.Core core,
                                org.chromium.mojo.bindings.MessageReceiverWithResponder messageReceiver) {
            return new Proxy(core, messageReceiver);
        }

        @Override
        public Stub buildStub(org.chromium.mojo.system.Core core, VideoCaptureHost impl) {
            return new Stub(core, impl);
        }

        @Override
        public VideoCaptureHost[] buildArray(int size) {
          return new VideoCaptureHost[size];
        }
    };


    private static final int START_ORDINAL = 0;

    private static final int STOP_ORDINAL = 1;

    private static final int PAUSE_ORDINAL = 2;

    private static final int RESUME_ORDINAL = 3;

    private static final int REQUEST_REFRESH_FRAME_ORDINAL = 4;

    private static final int RELEASE_BUFFER_ORDINAL = 5;

    private static final int GET_DEVICE_SUPPORTED_FORMATS_ORDINAL = 6;

    private static final int GET_DEVICE_FORMATS_IN_USE_ORDINAL = 7;

    private static final int ON_FRAME_DROPPED_ORDINAL = 8;

    private static final int ON_LOG_ORDINAL = 9;


    static final class Proxy extends org.chromium.mojo.bindings.Interface.AbstractProxy implements VideoCaptureHost.Proxy {

        Proxy(org.chromium.mojo.system.Core core,
              org.chromium.mojo.bindings.MessageReceiverWithResponder messageReceiver) {
            super(core, messageReceiver);
        }


        @Override
        public void start(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, org.chromium.mojo_base.mojom.UnguessableToken sessionId, VideoCaptureParams params, VideoCaptureObserver observer) {

            VideoCaptureHostStartParams _message = new VideoCaptureHostStartParams();

            _message.deviceId = deviceId;

            _message.sessionId = sessionId;

            _message.params = params;

            _message.observer = observer;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(START_ORDINAL)));

        }


        @Override
        public void stop(
org.chromium.mojo_base.mojom.UnguessableToken deviceId) {

            VideoCaptureHostStopParams _message = new VideoCaptureHostStopParams();

            _message.deviceId = deviceId;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(STOP_ORDINAL)));

        }


        @Override
        public void pause(
org.chromium.mojo_base.mojom.UnguessableToken deviceId) {

            VideoCaptureHostPauseParams _message = new VideoCaptureHostPauseParams();

            _message.deviceId = deviceId;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(PAUSE_ORDINAL)));

        }


        @Override
        public void resume(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, org.chromium.mojo_base.mojom.UnguessableToken sessionId, VideoCaptureParams params) {

            VideoCaptureHostResumeParams _message = new VideoCaptureHostResumeParams();

            _message.deviceId = deviceId;

            _message.sessionId = sessionId;

            _message.params = params;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(RESUME_ORDINAL)));

        }


        @Override
        public void requestRefreshFrame(
org.chromium.mojo_base.mojom.UnguessableToken deviceId) {

            VideoCaptureHostRequestRefreshFrameParams _message = new VideoCaptureHostRequestRefreshFrameParams();

            _message.deviceId = deviceId;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(REQUEST_REFRESH_FRAME_ORDINAL)));

        }


        @Override
        public void releaseBuffer(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, int bufferId, VideoFrameFeedback feedback) {

            VideoCaptureHostReleaseBufferParams _message = new VideoCaptureHostReleaseBufferParams();

            _message.deviceId = deviceId;

            _message.bufferId = bufferId;

            _message.feedback = feedback;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(RELEASE_BUFFER_ORDINAL)));

        }


        @Override
        public void getDeviceSupportedFormats(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, org.chromium.mojo_base.mojom.UnguessableToken sessionId, 
GetDeviceSupportedFormatsResponse callback) {

            VideoCaptureHostGetDeviceSupportedFormatsParams _message = new VideoCaptureHostGetDeviceSupportedFormatsParams();

            _message.deviceId = deviceId;

            _message.sessionId = sessionId;


            getProxyHandler().getMessageReceiver().acceptWithResponder(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(
                                    GET_DEVICE_SUPPORTED_FORMATS_ORDINAL,
                                    org.chromium.mojo.bindings.MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG,
                                    0)),
                    new VideoCaptureHostGetDeviceSupportedFormatsResponseParamsForwardToCallback(callback));

        }


        @Override
        public void getDeviceFormatsInUse(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, org.chromium.mojo_base.mojom.UnguessableToken sessionId, 
GetDeviceFormatsInUseResponse callback) {

            VideoCaptureHostGetDeviceFormatsInUseParams _message = new VideoCaptureHostGetDeviceFormatsInUseParams();

            _message.deviceId = deviceId;

            _message.sessionId = sessionId;


            getProxyHandler().getMessageReceiver().acceptWithResponder(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(
                                    GET_DEVICE_FORMATS_IN_USE_ORDINAL,
                                    org.chromium.mojo.bindings.MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG,
                                    0)),
                    new VideoCaptureHostGetDeviceFormatsInUseResponseParamsForwardToCallback(callback));

        }


        @Override
        public void onFrameDropped(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, int reason) {

            VideoCaptureHostOnFrameDroppedParams _message = new VideoCaptureHostOnFrameDroppedParams();

            _message.deviceId = deviceId;

            _message.reason = reason;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(ON_FRAME_DROPPED_ORDINAL)));

        }


        @Override
        public void onLog(
org.chromium.mojo_base.mojom.UnguessableToken deviceId, String message) {

            VideoCaptureHostOnLogParams _message = new VideoCaptureHostOnLogParams();

            _message.deviceId = deviceId;

            _message.message = message;


            getProxyHandler().getMessageReceiver().accept(
                    _message.serializeWithHeader(
                            getProxyHandler().getCore(),
                            new org.chromium.mojo.bindings.MessageHeader(ON_LOG_ORDINAL)));

        }


    }

    static final class Stub extends org.chromium.mojo.bindings.Interface.Stub<VideoCaptureHost> {

        Stub(org.chromium.mojo.system.Core core, VideoCaptureHost impl) {
            super(core, impl);
        }

        @Override
        public boolean accept(org.chromium.mojo.bindings.Message message) {
            try {
                org.chromium.mojo.bindings.ServiceMessage messageWithHeader =
                        message.asServiceMessage();
                org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
                int flags = org.chromium.mojo.bindings.MessageHeader.NO_FLAG;
                if (header.hasFlag(org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
                    flags = flags | org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG;
                }
                if (!header.validateHeader(flags)) {
                    return false;
                }
                switch(header.getType()) {

                    case org.chromium.mojo.bindings.interfacecontrol.InterfaceControlMessagesConstants.RUN_OR_CLOSE_PIPE_MESSAGE_ID:
                        return org.chromium.mojo.bindings.InterfaceControlMessagesHelper.handleRunOrClosePipe(
                                VideoCaptureHost_Internal.MANAGER, messageWithHeader);





                    case START_ORDINAL: {

                        VideoCaptureHostStartParams data =
                                VideoCaptureHostStartParams.deserialize(messageWithHeader.getPayload());

                        getImpl().start(data.deviceId, data.sessionId, data.params, data.observer);
                        return true;
                    }





                    case STOP_ORDINAL: {

                        VideoCaptureHostStopParams data =
                                VideoCaptureHostStopParams.deserialize(messageWithHeader.getPayload());

                        getImpl().stop(data.deviceId);
                        return true;
                    }





                    case PAUSE_ORDINAL: {

                        VideoCaptureHostPauseParams data =
                                VideoCaptureHostPauseParams.deserialize(messageWithHeader.getPayload());

                        getImpl().pause(data.deviceId);
                        return true;
                    }





                    case RESUME_ORDINAL: {

                        VideoCaptureHostResumeParams data =
                                VideoCaptureHostResumeParams.deserialize(messageWithHeader.getPayload());

                        getImpl().resume(data.deviceId, data.sessionId, data.params);
                        return true;
                    }





                    case REQUEST_REFRESH_FRAME_ORDINAL: {

                        VideoCaptureHostRequestRefreshFrameParams data =
                                VideoCaptureHostRequestRefreshFrameParams.deserialize(messageWithHeader.getPayload());

                        getImpl().requestRefreshFrame(data.deviceId);
                        return true;
                    }





                    case RELEASE_BUFFER_ORDINAL: {

                        VideoCaptureHostReleaseBufferParams data =
                                VideoCaptureHostReleaseBufferParams.deserialize(messageWithHeader.getPayload());

                        getImpl().releaseBuffer(data.deviceId, data.bufferId, data.feedback);
                        return true;
                    }









                    case ON_FRAME_DROPPED_ORDINAL: {

                        VideoCaptureHostOnFrameDroppedParams data =
                                VideoCaptureHostOnFrameDroppedParams.deserialize(messageWithHeader.getPayload());

                        getImpl().onFrameDropped(data.deviceId, data.reason);
                        return true;
                    }





                    case ON_LOG_ORDINAL: {

                        VideoCaptureHostOnLogParams data =
                                VideoCaptureHostOnLogParams.deserialize(messageWithHeader.getPayload());

                        getImpl().onLog(data.deviceId, data.message);
                        return true;
                    }


                    default:
                        return false;
                }
            } catch (org.chromium.mojo.bindings.DeserializationException e) {
                System.err.println(e.toString());
                return false;
            }
        }

        @Override
        public boolean acceptWithResponder(org.chromium.mojo.bindings.Message message, org.chromium.mojo.bindings.MessageReceiver receiver) {
            try {
                org.chromium.mojo.bindings.ServiceMessage messageWithHeader =
                        message.asServiceMessage();
                org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
                int flags = org.chromium.mojo.bindings.MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG;
                if (header.hasFlag(org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
                    flags = flags | org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG;
                }
                if (!header.validateHeader(flags)) {
                    return false;
                }
                switch(header.getType()) {

                    case org.chromium.mojo.bindings.interfacecontrol.InterfaceControlMessagesConstants.RUN_MESSAGE_ID:
                        return org.chromium.mojo.bindings.InterfaceControlMessagesHelper.handleRun(
                                getCore(), VideoCaptureHost_Internal.MANAGER, messageWithHeader, receiver);



















                    case GET_DEVICE_SUPPORTED_FORMATS_ORDINAL: {

                        VideoCaptureHostGetDeviceSupportedFormatsParams data =
                                VideoCaptureHostGetDeviceSupportedFormatsParams.deserialize(messageWithHeader.getPayload());

                        getImpl().getDeviceSupportedFormats(data.deviceId, data.sessionId, new VideoCaptureHostGetDeviceSupportedFormatsResponseParamsProxyToResponder(getCore(), receiver, header.getRequestId()));
                        return true;
                    }







                    case GET_DEVICE_FORMATS_IN_USE_ORDINAL: {

                        VideoCaptureHostGetDeviceFormatsInUseParams data =
                                VideoCaptureHostGetDeviceFormatsInUseParams.deserialize(messageWithHeader.getPayload());

                        getImpl().getDeviceFormatsInUse(data.deviceId, data.sessionId, new VideoCaptureHostGetDeviceFormatsInUseResponseParamsProxyToResponder(getCore(), receiver, header.getRequestId()));
                        return true;
                    }






                    default:
                        return false;
                }
            } catch (org.chromium.mojo.bindings.DeserializationException e) {
                System.err.println(e.toString());
                return false;
            }
        }
    }


    
    static final class VideoCaptureHostStartParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 40;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(40, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public org.chromium.mojo_base.mojom.UnguessableToken sessionId;
        public VideoCaptureParams params;
        public VideoCaptureObserver observer;

        private VideoCaptureHostStartParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostStartParams() {
            this(0);
        }

        public static VideoCaptureHostStartParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostStartParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostStartParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostStartParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostStartParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(16, false);
                    result.sessionId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(24, false);
                    result.params = VideoCaptureParams.decode(decoder1);
                    }
                    {
                        
                    result.observer = decoder0.readServiceInterface(32, false, VideoCaptureObserver.MANAGER);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.sessionId, 16, false);
            
            encoder0.encode(this.params, 24, false);
            
            encoder0.encode(this.observer, 32, false, VideoCaptureObserver.MANAGER);
        }
    }



    
    static final class VideoCaptureHostStopParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 16;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(16, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;

        private VideoCaptureHostStopParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostStopParams() {
            this(0);
        }

        public static VideoCaptureHostStopParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostStopParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostStopParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostStopParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostStopParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
        }
    }



    
    static final class VideoCaptureHostPauseParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 16;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(16, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;

        private VideoCaptureHostPauseParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostPauseParams() {
            this(0);
        }

        public static VideoCaptureHostPauseParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostPauseParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostPauseParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostPauseParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostPauseParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
        }
    }



    
    static final class VideoCaptureHostResumeParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 32;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(32, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public org.chromium.mojo_base.mojom.UnguessableToken sessionId;
        public VideoCaptureParams params;

        private VideoCaptureHostResumeParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostResumeParams() {
            this(0);
        }

        public static VideoCaptureHostResumeParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostResumeParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostResumeParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostResumeParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostResumeParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(16, false);
                    result.sessionId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(24, false);
                    result.params = VideoCaptureParams.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.sessionId, 16, false);
            
            encoder0.encode(this.params, 24, false);
        }
    }



    
    static final class VideoCaptureHostRequestRefreshFrameParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 16;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(16, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;

        private VideoCaptureHostRequestRefreshFrameParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostRequestRefreshFrameParams() {
            this(0);
        }

        public static VideoCaptureHostRequestRefreshFrameParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostRequestRefreshFrameParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostRequestRefreshFrameParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostRequestRefreshFrameParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostRequestRefreshFrameParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
        }
    }



    
    static final class VideoCaptureHostReleaseBufferParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 32;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(32, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public int bufferId;
        public VideoFrameFeedback feedback;

        private VideoCaptureHostReleaseBufferParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostReleaseBufferParams() {
            this(0);
        }

        public static VideoCaptureHostReleaseBufferParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostReleaseBufferParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostReleaseBufferParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostReleaseBufferParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostReleaseBufferParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    result.bufferId = decoder0.readInt(16);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(24, false);
                    result.feedback = VideoFrameFeedback.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.bufferId, 16);
            
            encoder0.encode(this.feedback, 24, false);
        }
    }



    
    static final class VideoCaptureHostGetDeviceSupportedFormatsParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 24;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(24, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public org.chromium.mojo_base.mojom.UnguessableToken sessionId;

        private VideoCaptureHostGetDeviceSupportedFormatsParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostGetDeviceSupportedFormatsParams() {
            this(0);
        }

        public static VideoCaptureHostGetDeviceSupportedFormatsParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostGetDeviceSupportedFormatsParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostGetDeviceSupportedFormatsParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostGetDeviceSupportedFormatsParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostGetDeviceSupportedFormatsParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(16, false);
                    result.sessionId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.sessionId, 16, false);
        }
    }



    
    static final class VideoCaptureHostGetDeviceSupportedFormatsResponseParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 16;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(16, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public VideoCaptureFormat[] formatsSupported;

        private VideoCaptureHostGetDeviceSupportedFormatsResponseParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostGetDeviceSupportedFormatsResponseParams() {
            this(0);
        }

        public static VideoCaptureHostGetDeviceSupportedFormatsResponseParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostGetDeviceSupportedFormatsResponseParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostGetDeviceSupportedFormatsResponseParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostGetDeviceSupportedFormatsResponseParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostGetDeviceSupportedFormatsResponseParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    {
                        org.chromium.mojo.bindings.DataHeader si1 = decoder1.readDataHeaderForPointerArray(org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
                        result.formatsSupported = new VideoCaptureFormat[si1.elementsOrVersion];
                        for (int i1 = 0; i1 < si1.elementsOrVersion; ++i1) {
                            
                            org.chromium.mojo.bindings.Decoder decoder2 = decoder1.readPointer(org.chromium.mojo.bindings.DataHeader.HEADER_SIZE + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i1, false);
                            result.formatsSupported[i1] = VideoCaptureFormat.decode(decoder2);
                        }
                    }
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            if (this.formatsSupported == null) {
                encoder0.encodeNullPointer(8, false);
            } else {
                org.chromium.mojo.bindings.Encoder encoder1 = encoder0.encodePointerArray(this.formatsSupported.length, 8, org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
                for (int i0 = 0; i0 < this.formatsSupported.length; ++i0) {
                    
                    encoder1.encode(this.formatsSupported[i0], org.chromium.mojo.bindings.DataHeader.HEADER_SIZE + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i0, false);
                }
            }
        }
    }

    static class VideoCaptureHostGetDeviceSupportedFormatsResponseParamsForwardToCallback extends org.chromium.mojo.bindings.SideEffectFreeCloseable
            implements org.chromium.mojo.bindings.MessageReceiver {
        private final VideoCaptureHost.GetDeviceSupportedFormatsResponse mCallback;

        VideoCaptureHostGetDeviceSupportedFormatsResponseParamsForwardToCallback(VideoCaptureHost.GetDeviceSupportedFormatsResponse callback) {
            this.mCallback = callback;
        }

        @Override
        public boolean accept(org.chromium.mojo.bindings.Message message) {
            try {
                org.chromium.mojo.bindings.ServiceMessage messageWithHeader =
                        message.asServiceMessage();
                org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
                if (!header.validateHeader(GET_DEVICE_SUPPORTED_FORMATS_ORDINAL,
                                           org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_RESPONSE_FLAG)) {
                    return false;
                }

                VideoCaptureHostGetDeviceSupportedFormatsResponseParams response = VideoCaptureHostGetDeviceSupportedFormatsResponseParams.deserialize(messageWithHeader.getPayload());

                mCallback.call(response.formatsSupported);
                return true;
            } catch (org.chromium.mojo.bindings.DeserializationException e) {
                return false;
            }
        }
    }

    static class VideoCaptureHostGetDeviceSupportedFormatsResponseParamsProxyToResponder implements VideoCaptureHost.GetDeviceSupportedFormatsResponse {

        private final org.chromium.mojo.system.Core mCore;
        private final org.chromium.mojo.bindings.MessageReceiver mMessageReceiver;
        private final long mRequestId;

        VideoCaptureHostGetDeviceSupportedFormatsResponseParamsProxyToResponder(
                org.chromium.mojo.system.Core core,
                org.chromium.mojo.bindings.MessageReceiver messageReceiver,
                long requestId) {
            mCore = core;
            mMessageReceiver = messageReceiver;
            mRequestId = requestId;
        }

        @Override
        public void call(VideoCaptureFormat[] formatsSupported) {
            VideoCaptureHostGetDeviceSupportedFormatsResponseParams _response = new VideoCaptureHostGetDeviceSupportedFormatsResponseParams();

            _response.formatsSupported = formatsSupported;

            org.chromium.mojo.bindings.ServiceMessage _message =
                    _response.serializeWithHeader(
                            mCore,
                            new org.chromium.mojo.bindings.MessageHeader(
                                    GET_DEVICE_SUPPORTED_FORMATS_ORDINAL,
                                    org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_RESPONSE_FLAG,
                                    mRequestId));
            mMessageReceiver.accept(_message);
        }
    }



    
    static final class VideoCaptureHostGetDeviceFormatsInUseParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 24;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(24, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public org.chromium.mojo_base.mojom.UnguessableToken sessionId;

        private VideoCaptureHostGetDeviceFormatsInUseParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostGetDeviceFormatsInUseParams() {
            this(0);
        }

        public static VideoCaptureHostGetDeviceFormatsInUseParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostGetDeviceFormatsInUseParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostGetDeviceFormatsInUseParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostGetDeviceFormatsInUseParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostGetDeviceFormatsInUseParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(16, false);
                    result.sessionId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.sessionId, 16, false);
        }
    }



    
    static final class VideoCaptureHostGetDeviceFormatsInUseResponseParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 16;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(16, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public VideoCaptureFormat[] formatsInUse;

        private VideoCaptureHostGetDeviceFormatsInUseResponseParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostGetDeviceFormatsInUseResponseParams() {
            this(0);
        }

        public static VideoCaptureHostGetDeviceFormatsInUseResponseParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostGetDeviceFormatsInUseResponseParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostGetDeviceFormatsInUseResponseParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostGetDeviceFormatsInUseResponseParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostGetDeviceFormatsInUseResponseParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    {
                        org.chromium.mojo.bindings.DataHeader si1 = decoder1.readDataHeaderForPointerArray(org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
                        result.formatsInUse = new VideoCaptureFormat[si1.elementsOrVersion];
                        for (int i1 = 0; i1 < si1.elementsOrVersion; ++i1) {
                            
                            org.chromium.mojo.bindings.Decoder decoder2 = decoder1.readPointer(org.chromium.mojo.bindings.DataHeader.HEADER_SIZE + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i1, false);
                            result.formatsInUse[i1] = VideoCaptureFormat.decode(decoder2);
                        }
                    }
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            if (this.formatsInUse == null) {
                encoder0.encodeNullPointer(8, false);
            } else {
                org.chromium.mojo.bindings.Encoder encoder1 = encoder0.encodePointerArray(this.formatsInUse.length, 8, org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
                for (int i0 = 0; i0 < this.formatsInUse.length; ++i0) {
                    
                    encoder1.encode(this.formatsInUse[i0], org.chromium.mojo.bindings.DataHeader.HEADER_SIZE + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i0, false);
                }
            }
        }
    }

    static class VideoCaptureHostGetDeviceFormatsInUseResponseParamsForwardToCallback extends org.chromium.mojo.bindings.SideEffectFreeCloseable
            implements org.chromium.mojo.bindings.MessageReceiver {
        private final VideoCaptureHost.GetDeviceFormatsInUseResponse mCallback;

        VideoCaptureHostGetDeviceFormatsInUseResponseParamsForwardToCallback(VideoCaptureHost.GetDeviceFormatsInUseResponse callback) {
            this.mCallback = callback;
        }

        @Override
        public boolean accept(org.chromium.mojo.bindings.Message message) {
            try {
                org.chromium.mojo.bindings.ServiceMessage messageWithHeader =
                        message.asServiceMessage();
                org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
                if (!header.validateHeader(GET_DEVICE_FORMATS_IN_USE_ORDINAL,
                                           org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_RESPONSE_FLAG)) {
                    return false;
                }

                VideoCaptureHostGetDeviceFormatsInUseResponseParams response = VideoCaptureHostGetDeviceFormatsInUseResponseParams.deserialize(messageWithHeader.getPayload());

                mCallback.call(response.formatsInUse);
                return true;
            } catch (org.chromium.mojo.bindings.DeserializationException e) {
                return false;
            }
        }
    }

    static class VideoCaptureHostGetDeviceFormatsInUseResponseParamsProxyToResponder implements VideoCaptureHost.GetDeviceFormatsInUseResponse {

        private final org.chromium.mojo.system.Core mCore;
        private final org.chromium.mojo.bindings.MessageReceiver mMessageReceiver;
        private final long mRequestId;

        VideoCaptureHostGetDeviceFormatsInUseResponseParamsProxyToResponder(
                org.chromium.mojo.system.Core core,
                org.chromium.mojo.bindings.MessageReceiver messageReceiver,
                long requestId) {
            mCore = core;
            mMessageReceiver = messageReceiver;
            mRequestId = requestId;
        }

        @Override
        public void call(VideoCaptureFormat[] formatsInUse) {
            VideoCaptureHostGetDeviceFormatsInUseResponseParams _response = new VideoCaptureHostGetDeviceFormatsInUseResponseParams();

            _response.formatsInUse = formatsInUse;

            org.chromium.mojo.bindings.ServiceMessage _message =
                    _response.serializeWithHeader(
                            mCore,
                            new org.chromium.mojo.bindings.MessageHeader(
                                    GET_DEVICE_FORMATS_IN_USE_ORDINAL,
                                    org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_RESPONSE_FLAG,
                                    mRequestId));
            mMessageReceiver.accept(_message);
        }
    }



    
    static final class VideoCaptureHostOnFrameDroppedParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 24;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(24, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public int reason;

        private VideoCaptureHostOnFrameDroppedParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostOnFrameDroppedParams() {
            this(0);
        }

        public static VideoCaptureHostOnFrameDroppedParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostOnFrameDroppedParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostOnFrameDroppedParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostOnFrameDroppedParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostOnFrameDroppedParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    result.reason = decoder0.readInt(16);
                        VideoCaptureFrameDropReason.validate(result.reason);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.reason, 16);
        }
    }



    
    static final class VideoCaptureHostOnLogParams extends org.chromium.mojo.bindings.Struct {

        private static final int STRUCT_SIZE = 24;
        private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY = new org.chromium.mojo.bindings.DataHeader[] {new org.chromium.mojo.bindings.DataHeader(24, 0)};
        private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO = VERSION_ARRAY[0];
        public org.chromium.mojo_base.mojom.UnguessableToken deviceId;
        public String message;

        private VideoCaptureHostOnLogParams(int version) {
            super(STRUCT_SIZE, version);
        }

        public VideoCaptureHostOnLogParams() {
            this(0);
        }

        public static VideoCaptureHostOnLogParams deserialize(org.chromium.mojo.bindings.Message message) {
            return decode(new org.chromium.mojo.bindings.Decoder(message));
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        public static VideoCaptureHostOnLogParams deserialize(java.nio.ByteBuffer data) {
            return deserialize(new org.chromium.mojo.bindings.Message(
                    data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
        }

        @SuppressWarnings("unchecked")
        public static VideoCaptureHostOnLogParams decode(org.chromium.mojo.bindings.Decoder decoder0) {
            if (decoder0 == null) {
                return null;
            }
            decoder0.increaseStackDepth();
            VideoCaptureHostOnLogParams result;
            try {
                org.chromium.mojo.bindings.DataHeader mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY);
                final int elementsOrVersion = mainDataHeader.elementsOrVersion;
                result = new VideoCaptureHostOnLogParams(elementsOrVersion);
                    {
                        
                    org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
                    result.deviceId = org.chromium.mojo_base.mojom.UnguessableToken.decode(decoder1);
                    }
                    {
                        
                    result.message = decoder0.readString(16, false);
                    }

            } finally {
                decoder0.decreaseStackDepth();
            }
            return result;
        }

        @SuppressWarnings("unchecked")
        @Override
        protected final void encode(org.chromium.mojo.bindings.Encoder encoder) {
            org.chromium.mojo.bindings.Encoder encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);
            
            encoder0.encode(this.deviceId, 8, false);
            
            encoder0.encode(this.message, 16, false);
        }
    }



}
